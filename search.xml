<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>追女孩子好难。。。</title>
      <link href="/2019/01/16/zhui-nu-hai-zi-hao-nan-hao-nan/"/>
      <url>/2019/01/16/zhui-nu-hai-zi-hao-nan-hao-nan/</url>
      
        <content type="html"><![CDATA[<p><strong>1.</strong> </p><p>一室友，周末的时候，给一个女生发微信，想要约出来看电影。结果很惨，人家一天都没回复他，到了晚上的时候才说：对不起啊，才看到消息。。。当然，室友很生气，觉得自己被套路了，然后忍不住感慨：我终于知道为什么现在男追女越来越少了，遂打开电脑玩游戏。</p><p><strong>2.</strong></p><p>没错，现在的男生追女生总是感觉越来越难了，自己努力半天，嘘寒问暖，笑脸相迎，对面女孩子内心却毫无波澜。于是男生受挫，大多选择放弃，还时不时的吐槽一两句：现在的女人真是特么势利，只喜欢有钱有势有颜的男人！</p><p>仔细分析一下，为什么现在追女孩子越来越难了呢？有钱有势又有颜的男人毕竟是少数，大多还是普通人。但同时不可否认的是，有的女孩子，还就是愿意跟着一个没钱的男人呢，这又怎么解释呢。一些看似普通但是又能够吸引到女生的男人，大多存在一些鲜明的特点，比如长相帅气啊，爱干净啊，有内涵啊，做饭好吃啊之类的，而这些特点总结到一起，可以用一个词来形容，那就是“信息差”。</p><p>什么叫信息差？简单的说，就是你能够让别人感受到不一样，可以是时间上自己和自己的不一样，也可以是空间上自己和别人的不一样。</p><p>你以前总是很邋遢，头发很油，衣服长时间不洗，鞋子很脏。但是突然，在追女孩子的时候，你突然变得爱好打扮了，整个人看起来不一样了，这让女生感到了一种新奇，于是她心里就会有变化。</p><p>毫无疑问，现在随着互联网的发展，微博、微信、QQ 等平台的普及，人与人之间的信息差变得越来越小了。以前，男生只要多看点书，多关注一些新闻，就可以大肆发挥，给女孩子说好半天，女孩听到自己从没听说过的东西，自然觉得高兴，并且认为这男生还是个挺有趣的人，好感顿时就有了。但是现在呢，新闻一出，各大平台在短时间内都能看到了，看书的人越来越少，会思考总结的更少，所以能够和女生分享的东西就屈指可数了。</p><p><strong>3.</strong></p><p>所以，可以看出，现在追女孩子的基本套路，也是较为有效的策略，便是增大自己和对方的信息差。</p><p>从外，可以多打理打理自己的外表形象，发型，穿着之类的，这还是比较重要的。因为处于这个现实的社会，别去相信有了内在美就可以不用在乎外表了，没有后者，可能连表现内在的机会都很少。毕竟现在女生的选择很多，三条腿的蛤蟆不好找，两条腿的男人遍地都是。</p><p>当然，外在的改变，由此带来的信息差是很微妙的，它能达到的效果也很有限：比如对方只会觉得你是一个还不错的人，至少懂得整理自己，大概率不会讨厌你，但要是更进一步，就需要更深层次的信息差。</p><p>深层次的信息差，内在的修养占很大一部分。像上面说到的，既然现在新闻热点已经没有什么值得说道的了，那就可以另辟蹊径，可以把一个知识点弄得很深入，也可以广泛涉猎，拓宽自己的知识面。这样一来，你就能够在和女生的交谈中占得优势，要是你的谈话内容全都是一些关于吃喝拉撒、生活琐碎，那么别人很容易感到厌倦。</p><p>还有，能够有一些大多数人都没有的技能，由此带来的信息差也是较大的。比如你文章写得好，英语说得很溜，篮球打得棒，吉他弹得好，唱歌很好听……这些都行。</p><p>我们以前看电影，发现总是那些学习成绩不好的、类似混混的学生更能追到女生，为什么？因为他们更能够带来新鲜的东西，带着女生逃课啊，逛逛酒吧啊，制造惊喜，浪漫表白，这些东西满足了女生内心深处的幻想，所制造的信息差是巨大的。</p><p>还有一个原则，就是要尽量扬长避短，比如自己明明不擅长打篮球，却指着别人说那些人打得太菜了；自己不会弹吉他，却偏要说弹吉他太简单了，我两三天就能学会；这都是不可取的做法。聪明的人，应该尽量把自己擅长的东西展现在对方面前，让别人感受到你的不一样，这样信息差就制造出来了。</p><p><strong>4.</strong></p><p>站在女生的角度，该如何面对追自己的男生？首先，需要认清现实，就像男生都喜欢胸大臀翘的美女一样，女生肯定也钟情于温柔体贴，长相帅气，有钱，吹拉弹唱样样精通，电脑玩得飞起，打篮球惹得妹子尖叫的男生，但是这种人，大概率只会出现在电视机里面。每个人都会有自己不擅长的东西，每个人都会有缺点，而面对追求自己的男生，女孩子能否和他无压力的相处，能否接受他最大的缺点，是能不能在一起的基本判断标准。</p><p>还有，对于强行制造信息差的男生，也需要谨慎，有些事情，的确会让女生在短期内感觉非常的愉快，像摆脱了笼子的鸟一样，但是这种男人，大多是短期迎合，短期占有。</p><p>更重要的判断因素，就是看一个男人是否有上进心，是否能够专注的做自己的事情，是否愿意为了女生拼尽全力。车子房子固然重要，但是，现在的大部分年轻人，都是没房车没钱的，找一个愿意和自己拼搏的人，也未尝不可。所以，女孩子得注意，像上进心这种精神层面的信息差，就很重要了。</p>]]></content>
      
      
      <categories>
          
          <category> 无事杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无事杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们是怎样被大学上了的？</title>
      <link href="/2019/01/04/wo-men-shi-zen-yang-bei-da-xue-shang-liao-de/"/>
      <url>/2019/01/04/wo-men-shi-zen-yang-bei-da-xue-shang-liao-de/</url>
      
        <content type="html"><![CDATA[<p><strong>1.</strong> </p><p>还记得三年前的那个金秋九月，你刚走进大学校园的时候，就被周围的热闹景象吸引了，热情的学长学姐接过你的行李箱，带你走进宿舍楼。你为一路上的校园美景所陶醉，蓝天白云，时不时滑过脸庞的微风，高耸的图书馆，肃然的教学楼，至今仍历历在目。</p><p><strong>2.</strong> </p><p>大学第一年，你接触到了很多新的课程，其中有的你很喜欢，有的你不喜欢。周围是全新的环境，新的老师，新的同学，新的教室，于是，每一堂课，你都不会缺席。但是你学习成绩又一般，说不上太好，也谈不上太差，几乎没有挂科，所以没啥心气把成绩再往上提一提。你家境并不殷实，父母都在外打工，你总是跟奖学金无缘，所以只能申请助学金聊以自慰。</p><p>你几乎不去图书馆，一下课就会回到寝室，呆坐在椅子上或躺在床上，刷刷手机上的新闻，QQ空间动态，微信朋友圈。然后看看一些搞笑的视频，或者是一些新出的电影电视剧。周末的时候，你一般会睡到中午才醒来，然后吃个饭，下午一恍惚很快就过去了。</p><p>你根据自己的兴趣参与了一些社团学生会，跟其他人在一起，你总是很沉默，一直都是听别人讲。偶尔你会去看看学校举办的篮球赛，歌唱比赛，但你总是旁观者，为别人喝彩的同时，心里却有一些失落。你会幻想自己也是一个篮球高手，或是唱歌很好听，然后赢得很多人的青睐。</p><p><strong>3.</strong> </p><p>大学第二年，第三年。周围的一切你都已经很熟悉了，每天的生活好像都差不多，起床，上课，吃饭，玩手机电脑，睡觉。有时候你会看到某些厉害的人，心里很震惊，同时也暗下决心要努力一把，那一刻，你觉得自己很厉害，很励志，斗志昂然。可是，事情没坚持几天，你就有点撑不住了，注意力分散，然后想想，还是算了吧。于是，每一天，你好像都在重复昨天的生活。</p><p>你偶尔会想到自己毕业之后该做什么呢，自己好像没啥特长，也没有什么特别喜欢的事情，究竟该考研还是直接工作，你心里没什么打算。你心存侥幸，万一毕业的时候能找到一个好工作呢，万一我考研时运气不错，成绩很好呢。总之，离毕业还远 ，你总是想，到时候再说吧。</p><p>放暑假的时候，你会很无聊，没事喜欢逛逛qq空间，微信朋友圈。偶尔会看到一个同学晒出自己在某个地方旅行的照片，阳光明媚，风景秀丽，惹得你很羡慕。同时也在幻想着自己周游世界的美妙，也暗下决心想要存钱，以后也来一次旅行。可是，新学期到来的时候，一切幻想又烟消云散了，你又重复着那些索然无味的日子。</p><p><strong>4.</strong> </p><p>大学第四年，你发现身边的同学都好像变得很忙碌了。他们有的成天待在图书馆，早出晚归，为了考研而努力。有的在到处搜集招聘信息，参加招聘会和面试，为了找到心仪的工作而疲于奔命。而你，却不知道自己该干嘛，学校的课程也基本上结束了，随之而来的是外出实习。</p><p>你懒得做简历，因为发现自己没什么可以写上去的经历，所以你选择了一家很一般的公司，面试很水，去了就能过。你又没有其他的选择，所以只能收拾行囊开始自己的第一次工作经历。</p><p>工作很无趣，并且很累，你打心底里不喜欢，却也没有心气尝试去找另一份工作，想想还是将就一下算了。工作之余，你偶尔会在心里抱怨，为什么自己的专业只能做这样的工作呢，真是个垃圾学校，垃圾专业。你很不甘心，但无奈自己也没有什么能力找到更好的工作，于是，你不得不重复那苟延残喘的生活。</p><p>实习结束了，你回到学校，课程已经所剩无几，最重要的事情便是毕业论文了，日子还是和以前那样不紧不慢的过着。偶尔导师会在群里催促你完成毕业论文，这时候你才想起这事，然后在网上寻找一些现成的东西，东拼西凑，总算过了导师这关。到了大学最后一个学期，完成了毕业答辩，办好了离校手续的时候，你突然发现，自己的大学生活就要结束了。纵然心中有万般不舍，你还是要收拾自己的行李，最后再去吃一顿食堂的饭菜，喝一杯最喜欢的奶茶，逛一下最熟悉的校园，在最熟悉的床上睡最后一晚。</p><p><strong>5.</strong> </p><p>你不知道自己的下一站在哪里，没有什么想要做的工作，父母打电话问你的打算，你总是支支吾吾，他们叫你回去，你又丢不下这面子，婉言拒绝。你不得不找一份工作，但是自己又没有什么突出的能力，所以工作很一般，工资远远不如自己所想象的那样，面对毕业之后的生存压力，你总是感慨，却又无可奈何。身边的同学，他们有的你和你一样迷茫不知所措；有的考上了理想的大学，去读研究生；有的找到了心仪的工作，激动的向人生的下一站出发；有的虽然大学打了四年的游戏，但是家里有钱，父母早就安排好了工作。</p><p>终于，你还是拖着行李箱走出待了四年的大学校园，走到门口，你总是忍不住停下脚步。回头望去，蓝天白云还在，微风还有，图书馆，教学楼，它们还是在那里矗立着；同学们总是脚步匆匆，有的脸上挂着笑容，有的神情严肃，这一切都还在，熟悉又陌生。只是你，却不得不和自己的大学和青春说再见。</p>]]></content>
      
      
      <categories>
          
          <category> 无事杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无事杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记4——集合</title>
      <link href="/2018/12/11/java-xue-xi-bi-ji-4-ji-he/"/>
      <url>/2018/12/11/java-xue-xi-bi-ji-4-ji-he/</url>
      
        <content type="html"><![CDATA[<p>1.对于标准集合中的任何集合，都可以使用foreach循环，遍历整个集合。</p><p><strong>1.队列</strong></p><p>1.双端队列：在队列的头部和尾部都可以添加、删除元素，但是不能在队列中间添加元素。</p><p>2.循环数组队列：ArrayDeque；链表队列：LinkedList；它们都实现了Queue接口，并且都实现了双端队列。</p><p>3.优先级队列;PriorityQueue，可以按任意位置插入元素，却总是按照排序的顺序进行检索。并不是遍历的时候进行排序，而是删除的时候，总会删除最小的元素。</p><p>4.优先级队列使用了一种优雅且高效的数据结构，称为堆。堆是一种可以自我调整的二叉树。</p><p><strong>2.链表</strong></p><p>1.在Java中，所有的链表实际上都是双向链表。</p><p>2.LinkedList类的listIterator方法返回了一个实现了ListIterator接口的迭代器对象。</p><p><code>ListIterator&lt;String&gt; lter = staff.listIterator();</code></p><p>这个iterator不仅有指向下一个元素的next，还有指向前面的元素的previous；nextIndex方法返回下一次调用next方法时返回元素的整数索引，previousIndex方法返回下一次调用previous方法时返回的整数索引。</p><p>3.所以可以使用ListIterator从前后两个方向遍历链表中的元素，并且可以添加、删除元素。</p><p><strong>3.散列集</strong></p><p>1.在Java中，散列表使用链表数组实现的，每个列表称为桶，要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。</p><p>2.HashSet的实现基于散列表的集，元素是无序不重复的。</p><p>3.TreeSet与HashSet类似，唯一的不同在于，TreeSet是一个有序的集，可以以任意顺序插入元素，在对集合进行遍历时，元素自动的按照顺序呈现。底层使用的排序算法是使用红黑树实现的。</p><p>4.将元素添加到树中要比添加到散列表中慢，但是与将元素添加到数组或链表的正确位置相比还是更快，并且树集能够自动的将元素排序。</p><p>5.TreeSet将如何进行元素之间的比较：1.要求比较的对象必须实现Comparable接口，覆盖compareTo方法；2.写一个比较器，实现Comparator接口。覆盖compareTo方法。</p><p><strong>4.映射表</strong></p><p>1.映射表用来储存键值对，如果提供了键，就可以找到对应的值。Java为映射表提供了两个通用的实现：HashMap和TreeMap，HashMap对键进行散列，TreeMap用键的整体顺序对元素进行排序。</p><p>2.Map的键必须是唯一的，不能对同一个键存放两个值，如果对同一个键两次调用put方法，第二个值就会取代第一个值。</p><p>3.Map有三个视图：键集keySet、值集合values、键值对entrySet。</p><p><strong>5.专用集与映射表类</strong></p><p>Java1.4新增了两个类，LinkedHashMap和LinkedHashSet，可以记住插入元素的顺序。当元素插入到散列表中时，就会并入到双向链表中，保证数据是有序的。</p><p><strong>6.工具类方法</strong></p><p>1.数组转换为集合：Arrays的静态方法asList将返回一个包装了普通 Java 数组的 List 包装器。</p><p>集合转换为数组：例如一个 String 数组，转换成List，不能简单的使用 toArray() 方法，因为这样会出现类型转换的错误，可以使用集合的 toArray(new String[size]) 这种形式，指定转换之后的类型。</p><p>2.从 Java5.0 开始，asList方法将声明为一个具有可变数量参数的方法。<code>List&lt;String&gt; list = Arrays.asList(&quot;Amy&quot;,&quot;Bon&quot;,&quot;Cral&quot;);</code></p><p>3.Collections 的 nCopies 方法将创建一个包含 n 个的 List：<code>List&lt;String&gt; list = Collections.nCopies(100, &quot;default&quot;);</code></p><p>4.subList 方法可以获得列表的子范围：<code>List&lt;String&gt; sub = strs.subList(10,20);</code>，这表示从中取出10-19个元素，包含第一个下标，不包含第二个下标。跟 String 类的 subString 方法一样。</p><p>5.Collections 类中的 sort 方法可以对实现了 List 接口的集合进行排序。</p><p>如果想按照降序对列表进行排序，可以使用 Collections.reverseOrder() ，这个方法将返回一个比较器。例如：<code>Collections.sort(list, Collections.reverseOrder());</code>。</p><p>这种排序使用的是归并排序算法 </p><p>6.Collections.shuffle() 的功能与排序相反，即随机的混排列表中的元素。</p><p>7.Collections 的 binarySearch 实现了二分查找算法，集合必须是有序的。只有采用随机访问（例如数组），二分查找才有意义。如果必须使用迭代方式一次次的遍历链表的一半元素来找到中间位置的元素，二分查找就失去了优势。因此，如果为二分查找提供一个链表，它将自动的变为线性查找。</p><p>8.Collections 类的一些其他的方法：min、max、copy、reverse。</p><p><strong>7.遗留的集合</strong></p><p>Hashtable、Vector、Stack（Vector 的子类）。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记3——异常和泛型</title>
      <link href="/2018/12/09/java-xue-xi-bi-ji-3-yi-chang-he-fan-xing/"/>
      <url>/2018/12/09/java-xue-xi-bi-ji-3-yi-chang-he-fan-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="一、异常"><a href="#一、异常" class="headerlink" title="一、异常"></a>一、异常</h4><hr><p><strong>1.异常分类</strong></p><p>所有的异常都是由Throwable继承而来的，分为Error和Exception。</p><p>error表示Java运行时系统的内部错误和资源耗尽的错误，不能抛出这种类型的对象。</p><p>exception分为RuntimeException和其他异常：由程序错误导致的异常属于RuntimeException；而程序本身没有问题，但由于像I/O这样的问题导致的异常属于其他异常。</p><blockquote><p>如果出现RuntimeException，那么就一定是你的问题，这是一条很有道理的规则。</p></blockquote><p><strong>2.声明异常</strong></p><p>1.Java语言规范将派生于Error类和RuntimeException类的所有异常叫做“未检查异常”，所有的其他异常叫做“已检查异常”</p><p>2.在方法首部声明可能抛出的异常（throws Exception），抛出的必须是已检查异常。</p><p>3.如果在子类中覆盖了父类的一个方法，子类方法中声明的已检查异常不能比父类方法中声明的异常更通用。也就是说，子类中的方法可以抛出一个更特定的异常，或者不抛出异常。</p><p>4.如何抛出一个异常？</p><ul><li>找到一个合适的异常类</li><li>创建这个类的对象</li><li>将对象抛出，throw new Exception();</li></ul><p>5.自定义异常：应该继承Exception或其子类。</p><p><strong>3.捕获异常</strong></p><p>1.遇到错误，会跳过try中的剩余内容，执行catch中的内容。</p><p>2.假设利用return语句从try语句中退出，在方法返回前，finally子句的内容将执行。如果finally子句中也有一个return语句，这个返回值将会覆盖原始的返回值。</p><p>3.使用异常机制的技巧：</p><ul><li>异常处理不能代替简单的测试</li><li>不要过分的细化异常</li><li>利用异常层次结构。例如不要只抛出RuntimeExcption，而应该寻找更合适的子类，或者自己创建异常类。</li></ul><h4 id="二、泛型"><a href="#二、泛型" class="headerlink" title="二、泛型"></a>二、泛型</h4><hr><p><strong>1.为什么要使用泛型</strong></p><p>1.泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。</p><p>2.在泛型出现之前，Java使用的继承来解决这个问题，但是会遇到类型转换的问题。泛型提供了一种类型参数的方案，可以让程序的可读性更好。</p><p>3.泛型程序设计的三个级别：1.仅仅使用泛型，不关心它们的工作方式和原因。2.系统的学习Java泛型。3.实现自己的泛型类与泛型方法。</p><p><strong>2.定义泛型</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">private</span> T first<span class="token punctuation">;</span>    <span class="token keyword">private</span> T second<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Pair</span><span class="token punctuation">(</span>T first<span class="token punctuation">,</span> T second<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> first<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span>T first<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span>T second<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.定义泛型方法：<code>public static&lt;T&gt; T getMax(){}</code>，<t>表示这是一个泛型方法，T表示返回值类型。</t></p><p>3.类型变量的限定：<code>public static&lt;T extends Comparable&gt; T getMax(){}</code>，这里表示只能接收实现了Comparable接口的类。</p><p>一个类型变量可以有多个限定，例如：<code>T extends Comparable &amp; Serializable</code>。</p><p><strong>3.泛型约束</strong></p><p>1.不能使用基本类型实例化参数类型，例如不能这样使用：<code>Pair&lt;double&gt;</code>，而应该使用包装类：<code>Pair&lt;Double&gt;</code>。原因：类型擦除之后，Pair中只包含Object，而Object不能存储double值。</p><p>2.不能创建参数化类型的数组，例如<code>Pair&lt;String&gt;[] table = new Pair&lt;&gt;[10];//error</code></p><p>3.不能使用像new T[], new T(), T.class这样的表达式。</p><p>4.如果泛型方法返回一个T[]数组，可以使用反射来构建T[]数组：<code>T[] mm = (T[]) Array.newInstance(a.getClass.getComponentType(), 2);</code>，例如下面这个方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">minmax</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        T min <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        T max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>min<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>max<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        T<span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getComponentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>        result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.不能在静态域或方法中引用类型变量。<code>private static T id;  //error</code></p><p><strong>4.通配符类型</strong></p><p>1.通配符类型<code>Pair&lt;? extends Employee&gt;</code>，表示任何泛型Pair，它的参数类型必须是Employee的子类，例如：<code>Pair&lt;Manager&gt;</code>，而不能是 <code>Pair&lt;String&gt;</code>。实际上，Pair<employee>和Pair<manager>都是Pair&lt;? extendx Employee&gt;的子类型。</manager></employee></p><p>带有这种类型的泛型，可以对其子类型对象进行get，但不能set，例如：</p><pre class="line-numbers language-java"><code class="language-java">        Manager m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token string">"Jack"</span><span class="token punctuation">,</span><span class="token number">3400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Manager m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token string">"Oak"</span><span class="token punctuation">,</span><span class="token number">3600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Pair<span class="token operator">&lt;</span>Manager<span class="token operator">></span> managerPair <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>m1<span class="token punctuation">,</span>m2<span class="token punctuation">)</span><span class="token punctuation">;</span>        Pair<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span><span class="token operator">></span> employeePair <span class="token operator">=</span> managerPair<span class="token punctuation">;</span>        employeePair<span class="token punctuation">.</span><span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token number">232</span><span class="token punctuation">,</span><span class="token string">"Rose"</span><span class="token punctuation">,</span><span class="token number">4300</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//error</span>        Employee first <span class="token operator">=</span> employeePair<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.<code>Pair&lt;? super Manager&gt;</code>表示参数类型是Manager的超类。</p><p>带有这种类型的泛型，可以对其类型对象进行set，但不能get（会返回一个Object对象，但不能强制转换成其父类）。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——排序（四）</title>
      <link href="/2018/12/09/shu-ju-jie-gou-yu-suan-fa-pai-xu-si/"/>
      <url>/2018/12/09/shu-ju-jie-gou-yu-suan-fa-pai-xu-si/</url>
      
        <content type="html"><![CDATA[<h4 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1.回顾"></a>1.回顾</h4><p>前面已经说了几种基于元素比较的排序，其中归并和快速排序的应用稍多，今天就来讨论几种线性排序，这几种排序对数据的要求比较的高，但是如果能够应用起来的话，将会非常的高效，时间复杂度都能达到O(n)的程度。</p><h4 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2.桶排序"></a>2.桶排序</h4><p>桶排序的思路很简单，将一定范围的数据按照其大小，分别放在有序的桶内，然后桶内分别排序，然后再取出来，数据就全部有序了。例如我们要排序一组大小在1-50的订单金额，可以像下图这样做：</p><p><img src="https://roseduan.github.io/images/bucketSort/%E6%A1%B6%E6%8E%92%E5%BA%8F.png" alt=""></p><p>桶排序的时间复杂度可以达到O(n)，但是它对数据的要求十分的苛刻，首先数据在每个子范围必须是差不多的，不能出现有些桶的数据非常的多，而有些桶的数据又十分的少的情况。在极端情况下，假如全部的数据都在一个桶内的话，时间复杂度会退化为O(nlogn)了。</p><p>这里我模仿了一个桶排序，要排序的数据的范围在0-999之间，然后用链表初始化10个桶，每个桶存储的数据范围为：[0-99]、[100-199]、[200-299]、……、[900-999]。代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BucketSort</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//模拟一个桶排序，data中的数据在0-1000之间</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用链表模拟桶，新建10个桶</span>        ArrayList<span class="token operator">&lt;</span>LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化桶</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buckets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//扫描数据，将其放入桶内</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> bucketNum <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span>            buckets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>bucketNum<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将桶内的数据进行排序</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//使用Collections.sort()方法将桶内数据排序</span>            Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>buckets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//排序之后，将数据拷贝到data中</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                data<span class="token punctuation">[</span>index <span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buckets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序之前："</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BucketSort<span class="token punctuation">.</span><span class="token function">bucketSort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序之后："</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-计数排序"><a href="#3-计数排序" class="headerlink" title="3.计数排序"></a>3.计数排序</h4><p>计数排序其实是桶排序的一种特殊情况，假如要排序的数据的范围并不大，最大值是n，那么我们可以初始化n个桶，每个桶内存放数值相同的数据，这样就省去了桶内排序这一步骤。然后按照桶的大小依次取出数据，数据就是有序的了。</p><p>例如，需要给10万人按照年龄排序，应该怎么做呢？使用计数排序就能够很有效的解决，我们可以假设，10万人中，年龄最小的是1，年龄最大的是120，那么我们可以初始化120个桶，将年龄相同的放如到一个桶中，这样数据整体就有序了。</p><p>这里我模拟了一个计数排序：假如要给班上的100个人按照成绩进行排序，成绩最大值是10，最小值是0，那么可以用11个桶，每个桶的下标表示成绩即0-10。    </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountingSort</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//假设有100个考生，分数在0-10之间</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//新建11个桶，每个桶内保存相同的分数</span>        <span class="token comment" spellcheck="true">//使用链表模拟桶，新建11个桶</span>        ArrayList<span class="token operator">&lt;</span>LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化桶</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buckets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将数据放入到桶中</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buckets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将数据取出来</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                data<span class="token punctuation">[</span>index <span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buckets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token comment" spellcheck="true">//100个考生，分数在0-10之间</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CountingSort<span class="token punctuation">.</span><span class="token function">countingSort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实可以发现，计数排序和桶排序在代码上的区别就是：计数排序没有桶内排序这一环节。其他都是类似的。</p><h4 id="4-基数排序"><a href="#4-基数排序" class="headerlink" title="4.基数排序"></a>4.基数排序</h4><p>首先思考一个问题，假如要对10万个手机号码进行排序，应该怎么做呢？手机号码有11位，显然不太适合上面的两种桶排序和计数排序，还记得前面说到的稳定排序吗？我们可以借助稳定的排序，从手机号码的最后一位开始比较，最后按照第一位排序，因为是稳定的，后面位数的号码不会被打乱，排完之后，整个手机号码就有序了。</p><p>我是用几个简单的数组来实现这个排序的过程：</p><p><img src="https://roseduan.github.io/images/bucketSort/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记2——类、继承、接口</title>
      <link href="/2018/12/02/java-xue-xi-bi-ji-2-dui-xiang-yu-lei/"/>
      <url>/2018/12/02/java-xue-xi-bi-ji-2-dui-xiang-yu-lei/</url>
      
        <content type="html"><![CDATA[<p><strong>1.面向对象</strong></p><p>1.类：类是构造对象的蓝图或模板，由类构造对象的过程称为创建类的实例。</p><p>2.对象的三个特性：</p><ul><li>对象的行为</li><li>对象的状态</li><li>对象标识</li></ul><p>3.类之间有常见的三种关系：</p><ul><li>依赖（uses-a）：一个类的方法操纵另一个类的对象</li><li>聚合（has-a）：一个类的对象包含另一个类的对象</li><li>继承（is-a）：一个类继承另一个类</li></ul><p>4.一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</p><p><strong>2.自定义类</strong></p><p>1.在一个源文件当中，只能有一个公共类，可以有任意数目的非共有类。</p><p>2.构造器总是伴随着new操作符的执行被调用，不能用一个对象来调用构造器。</p><p>3.被定义为final的实例域，必须在构造器中对其进行初始化，在后续的操作中，不能修改。</p><p>4.静态变量和静态方法都属于类，不能对对象进行操作。静态方法可以访问自身类中的静态域。</p><p>5.有下面两种情况使用静态方法：</p><ul><li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供。例如Math.pow()</li><li>一个方法只需要访问类的静态域。</li></ul><p><strong>3.方法参数</strong></p><p>1.按值调用表示方法接收的是调用者提供的值，按引用调用表示方法接收的是调用者提供的变量地址。</p><p>2.Java总是采用按值调用，方法不能修改传递给它的任何参数变量的内容。</p><p>3.一个方法不能修改一个基本数据类型的参数；一个方法可以改变一个对象参数的状态；一个方法不能让对象参数引用新的对象。</p><p><strong>4.对象构造</strong></p><p>1.如果多个方法有相同的名称、返回值类型，不同的参数，便产生了重载。</p><p>2.执行顺序：静态初始化块 &gt; 初始化块 &gt; 构造器</p><p>3.访问修饰符：</p><ul><li>public：可以被任意的类使用</li><li>private：只能被定义他们的类使用</li><li>default：同一个包中任意类可访问</li><li>protected：同一个包中和所属子类可访问</li></ul><p>4.关键字this有两个用途：一是引用隐式参数，二是调用该类的其他构造器。</p><p>5.在Java中，只有基本类型不是对象。其余的类型，包括数组，无论是对象数组还是基本类型数组，都扩展于Object类。</p><p><strong>5.类设计技巧</strong></p><p>1.一定要保证数据私有性</p><p>2.一定要对数据初始化</p><p>3.不要在类中使用过多的基本类型，也就是说，可以用其他的类代替多个相关的基本类型的使用。</p><p>4.不是所有的实例域都需要setter和getter方法，视情况而定。</p><p>5.将职责过多的类进行分解。</p><p>6.类名和方法名要体现它们的意义和职责。</p><p><strong>6.继承</strong></p><p>1.使用super调用构造器的语句必须是子类构造器的第一条语句。</p><p>2.super关键字有两个用途：一是调用父类的方法，二是调用父类的构造器。</p><p>3.一个对象变量能够指示多种实际类型的现象称为多态，在运行期间能够自动地选择调用哪个方法的现象称为动态绑定。</p><p>4.在覆盖一个方法的时候，子类方法不能低于父类方法的可见性。</p><p>5.阻止继承：使用final修饰符。如果将一个类声明为final，只有其中的方法自动的成为final，而不包括实例域。</p><p><strong>7.抽象类</strong></p><p>1.为了程序的清晰性，包含一个或多个抽象方法的类本身必须被声明为抽象的。</p><p>2.除了抽象方法外，抽象类还可以包括具体数据和具体方法。</p><p>3.如果将一个类声明为抽象的，就不能创建这个类的对象。但是可以定义一个抽象类的对象变量，引用一个不是抽象的子类的对象。</p><p>4.equals方法：用于检测一个对象是否等于另外一个对象，即判断两个对象是否具有相同的引用。</p><p><strong>8.反射</strong></p><p>1.获取Class类对象的三种方式：</p><ul><li>对象引用.getClass()</li><li>Class.forName(“类路径”);</li><li>类名.class</li></ul><p>2.Class对象有一个newInstance()方法，这个方法要求类必须有一个无参的构造器，因为该方法只调用无参构造器，否则会报错。</p><p>3.反射机制最重要的内容：检查类的结构。在java.lang.reflect包中有三个类Field、Method、Constructor分别描述类的实例域、方法、构造器。</p><p>4.Class类中的getFields、getMethods、getConstructors方法将返回类提供的public域、方法和构造器，其中包括父类的公有成员。而getDeclareFields这些方法将返回类中的全部域、方法和构造器，不包括父类的成员。</p><p><strong>9.继承设计技巧</strong></p><p>1.将公共操作和实例域放在父类当中</p><p>2.不要使用protected声明的实例域</p><p><strong>10.接口</strong></p><p>接口主要用来描述类具有什么功能，而不给出每个功能的具体实现</p><p>1.接口中的所有方法自动的属于public，因为不用提供关键字public。</p><p>2.接口不能含有实例域，也不能在接口中实现方法。接口中可以有变量，但都默认为是final的。接口中可以有静态的实现方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记1——基本程序设计结构</title>
      <link href="/2018/12/01/java-xue-xi-bi-ji-1-ji-ben-cheng-xu-she-ji-jie-gou/"/>
      <url>/2018/12/01/java-xue-xi-bi-ji-1-ji-ben-cheng-xu-she-ji-jie-gou/</url>
      
        <content type="html"><![CDATA[<p><strong>1.Java程序示例</strong></p><pre class="line-numbers language-Java"><code class="language-Java">/*  多行注释  多行注释*/public class HelloWorld {    //单行注释    public static void main(String[] args) {        System.out.println("Hello World!");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.Java对大小写敏感</p><p>2.Java类的命名规范：首字母大写的名词，如果由多个单词组成，则每个单词的首字母都应该大写，称为驼峰式命名。</p><p>3.源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。</p><p>4.//表示单行注释，/**/表示多行注释</p><p><strong>2.数据类型</strong></p><p>1.Java共有8种基本数据类型：</p><ul><li>整型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）</li><li>浮点型：float（4字节）、double（8字节）</li><li>字符型：char（1字节）</li><li>布尔型：boolean</li></ul><p>Java的数据类型范围都是固定的，没有无符号类型的数据。</p><p>2.数字加上前缀：0b表示二进制，0表示八进制，0x表示十六进制</p><p>3.绝大部分的程序都采用double类型，float的数值后一个后缀F，没有后缀F的浮点数值则默认为double类型。</p><p>4.boolean类型有2个值：true和false，用来判断逻辑条件。整型值和布尔值之间不能相互转换。</p><p>5.数值类型之间的转换：</p><ul><li>如果两个操作数中有一个是double，另一个就转换为double</li><li>否则，如果如果其中一个数是float，另一个数就转换为float</li><li>否则，如果其中一个数是long，另一个数转换为long</li><li>否则，两个操作数都转换为int</li></ul><p><strong>3.变量</strong></p><p>1.变量名必须是一个以字母开头的由字母或数字组成的序列。</p><p>2.可以在一行中声明多个变量，例如<code>int i, j;</code>，但是不建议这样做，逐个声明变量有利于提高程序的可读性。</p><p>3.利用关键字final定义常量，习惯上，常量名全大写。</p><p><strong>4.字符串</strong></p><p>1.String类没有提供用于修改字符串的方法，所以String类型字符串是不可变的。</p><p>2.可以使用equals方法检测两个字符串是否相等。</p><p>3.要检测一个字符串既不为null也不是空串，可以使用<code>if(str != null &amp;&amp; str.length != 0)</code></p><p>4.String常用方法：</p><ul><li>char charAt(int index)：返回index位置的字符</li><li>int compareTo(String other)：按照字典顺序比较字符串</li><li>String concat(String str)：拼接字符串</li><li>contains(CharSequence s)：查看字符串是否包含</li><li>boolean startWith(String prefix)和boolean endsWith(String suffix)：以什么开始或结束</li><li>boolean equals(Object obj)：判断是否相等</li><li>indexOf、lastIndexOf</li><li>split</li><li>subString：截取子字符串</li><li>toCharArray()：将字符串转换为字符数组</li><li>toUpperCase()、toLowerCase()</li><li>trim()：去掉字符串头部和尾部的空格</li></ul><p><strong>5.大数值</strong></p><p>1.如果基本的整数和浮点数精度不能够满足需求，可以使用java.math包中的大数值类型：BigDecimal和BigInteger。这两个类可以处理任意长度数字序列的数值。</p><p>2.BigInteger实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。</p><p>3，大数值类型实现算术运算必须使用方法：add、subtract、multiply、divide分别表示加、减、乘、除。</p><p><strong>6.数组</strong></p><p>1.数组是一种数据结构，用来储存同一种类型的值的集合。可以通过下标访问数组中每个元素的值。</p><p>2.创建一个数字数组时，所有的元素都会初始化为0，boolean数组的元素会初始化为false，对象数组的元素会初始化为null。</p><p>3.有一个更简单的方法打印数组中的所有值：Arrays.toString()</p><p>4.数组拷贝的两种方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> data<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rose <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> rose<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.数组排序：Arrays.sort()，此方法采用的是快速排序实现。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——排序（三）</title>
      <link href="/2018/11/30/shu-ju-jie-gou-yu-suan-fa-pai-xu-san/"/>
      <url>/2018/11/30/shu-ju-jie-gou-yu-suan-fa-pai-xu-san/</url>
      
        <content type="html"><![CDATA[<h4 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1.回顾"></a>1.回顾</h4><p>前面说到了三种最基本的排序算法，分别是冒泡排序、选择排序、插入排序，他们的平均时间复杂度都是O(n<sup>2</sup>)，适用于小规模数据的排序，其中插入排序的效率稍高，工作中使用得更多，我也推荐使用插入排序。今天讲到的三种排序算法的时间复杂度都是O(nlogn)，分别是希尔排序、归并排序、快速排序，其中后两者的使用非常的普遍。</p><h4 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="2.希尔排序"></a>2.希尔排序</h4><p>首先来看看希尔排序，希尔排序其实本质上也是一种插入排序，只是做了一些优化，其思路是：将排序的数组按照一定的增量将数据分组，每个分组用插入排序算法排序，然后增量逐步减小，当增量减小为1的时候，算法便终止，所以希尔排序又叫做“缩小增量排序”。</p><p>我们常取的原始增量为数据的大小/2，例如数据大小为length，我们将其分为leng / 2个组，然后length = length / 2，继续分下去，直到length = 1。文字看起来比较抽象，我画了图来帮助你理解：</p><p><img src="https://roseduan.github.io/images/%E5%B8%8C%E5%B0%942.png" alt=""></p><p>下面是它的代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @ClassName ShellSort * @Description 希尔排序算法 * @Author roseduan * @Date 2018/11/30 22:30 * @Version 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShellSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义增量</span>        <span class="token keyword">int</span> step <span class="token operator">=</span> length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>step <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> step<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> value <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> step<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> step<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> step<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                data<span class="token punctuation">[</span>j <span class="token operator">+</span> step<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//增量缩小</span>            step <span class="token operator">=</span> step <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很遗憾，希尔排序虽然时间复杂度为O(nlogn)，但它是一种不稳定的算法，因为分组的时候可能会错开相同的元素，分组进行插入排序的时候，元素的位置交换之后，稳定性就被破坏了。比起归并排序，它是不稳定的，比起快速排序，它的执行效率稍慢，所以希尔排序并没有应用得很广泛。</p><h4 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h4><p>归并排序的思路是这样的：将排序的数据分为若干子数组，子数组排序之后，再进行合并，这样要排序的数组就能排好了。这种思想叫做分治，就是将一个大的问题分解成很多小问题，将小问题就解决了，大的问题也就解决了。用分治思想解决的问题，一般都可以用递归这种编程技巧来表示。</p><p><img src="https://roseduan.github.io/images/%E5%BD%92%E5%B9%B6.png" alt=""></p><p>结合上面的图可以看到，假如我们要排序data[p……r]这个数组，首先我们将数组分为data[p……q]和data[q+1……r]，然后再进行合并，用公式可以这样表示：</p><p><strong>merge_sort(data[p……r]) = merge(merge_sort(data[p……q]), merge_sort(data[q+1……r]));</strong></p><p>merge函数表示将两个子数组进行合并。那么merge函数该怎么表示呢？</p><p>思路是这样的：首先我们新建一个临时数组temp，大小和原始数组相同。然后使用两个指针i，j分别指向两个子数组的第一个元素，如果i所指元素 &lt; j所指元素，则将i所指元素插入temp，i向前移动；反之将j所指元素插入，j向前移动。以此类推，直到比较完成，然后将临时数组temp复制到原始数组中。</p><p>归并排序的代码是这样的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @ClassName MergeSort * @Description 归并排序算法 * @Author Rose_Duan * @Date 2018/12/1 15:41 * @Version 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">mergeInternally</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeInternally</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//计算p到r的中间值q</span>        <span class="token comment" spellcheck="true">// 此等式相当于int q = (p + r) / 2，只不过下面这样写效率更高</span>        <span class="token keyword">int</span> q <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">-</span> p<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//递归</span>        <span class="token comment" spellcheck="true">//data[p  r]分为data[p   q]和data[q+1   r]</span>        <span class="token function">mergeInternally</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mergeInternally</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//合并</span>        <span class="token function">merge</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//新建一个临时数组，大小与data[p……r]一样</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>r <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> q <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> temp<span class="token punctuation">[</span>k <span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>i <span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> temp<span class="token punctuation">[</span>k <span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j <span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//判断哪个子数组中有剩余的数据</span>        <span class="token comment" spellcheck="true">//首先假设data[p....q]中有剩余的数据</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> q<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果j小于等于r，则说明data[q+1...r]中有剩余的数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>            start <span class="token operator">=</span> j<span class="token punctuation">;</span>            end <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将剩余的元素拷贝到temp中</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>k <span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>start <span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//最后，将临时数组中的数据拷贝到data中</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r <span class="token operator">-</span> p<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            data<span class="token punctuation">[</span>p <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并排序并不是一种原地排序算法，因为很明显，我们申请了一个临时数组来保存数据，这个临时数组最大不会超过原始数组，所以空间复杂度为O(n)。归并排序的时间复杂度是O(nlogn)，并且是一种稳定的排序算法。</p><h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h4><p>快速排序简称“快排”，它的思路和归并排序很类似，都是利用的分治思想。首先选取任意一个数据作为分区点，比分区点小的数据放在其左边，大的放在右边。</p><p><img src="https://roseduan.github.io/images/%E5%BF%AB%E9%80%9F.png" alt=""></p><p>这样数组就分为了三个部分，一是分区点q，然后对p——q-1和q+1——r的数据分别再执行上图操作，这样整个数据就有序了。</p><p>归并排序当中有个merge合并函数，这里我们需要一个partition分区函数，主要的功能是实现上图的操作，将小于分区点的数据放在其左边，大于分区点的放在其右边，然后返回分区点。具体要怎么实现呢？这里用到的思路比较的巧妙：对于一个数组data[p….r]，我们选区最后一个元素data[r- 1]为分区点(也就是data[pivot])，然后用两个指针i，j指向第一个元素，如果data[j] &lt; data[pivot]，那么就互换i和j所指向的元素，然后i，j向前移动。如果data[j] &gt;= data[pivot]，那么不用交换位置，i不移动，j继续移动。</p><p>结合代码看一下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @ClassName QuickSort * @Description 快速排序算法 * @Author Rose_Duan * @Date 2018/11/14 13:44 * @Version 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">quickSortInternally</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSortInternally</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> p <span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取分区点</span>        <span class="token comment" spellcheck="true">//递归</span>        <span class="token function">quickSortInternally</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSortInternally</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> data<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> p<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                i <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>        data<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，在partition分区函数中，我们交换了元素的顺序，这样值相同的元素的前后顺序可能会被打乱，你可以结合我前面对partition函数的描述在看一下，所以快速排序是不稳定的。快速排序的平均时间复杂度是O(nlogn)，并且是一种原地排序算法，空间复杂度是O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——排序（二）</title>
      <link href="/2018/11/29/shu-ju-jie-gou-yu-suan-fa-pai-xu-er/"/>
      <url>/2018/11/29/shu-ju-jie-gou-yu-suan-fa-pai-xu-er/</url>
      
        <content type="html"><![CDATA[<h4 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1.回顾"></a>1.回顾</h4><p>前面说到了冒泡排序，这种算法的思路比较的简单，就是基于两个元素之间的比较，然后交换位置。冒泡排序的平均时间复杂度是O(n<sup>2</sup>)，空间复杂度是(1)，并且是稳定的排序算法。今天继续讲述另外两种排序算法：选择排序和插入排序。</p><h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h4><p>选择排序的思路是这样的：将要排序的数组分为未排序区间和已排序区间，遍历未排序区间，找到其最小值（或者最大值），将其插入到已排序区间的末尾。依次遍历，直到将未排序区间遍历完，整个排序操作就完成了。我画了一张图来帮助你理解其原理：</p><p><img src="https://roseduan.github.io/images/%E9%80%89%E6%8B%A9.png" alt=""></p><p>相信结合这个图你就不能理解选择排序了，下面是它的代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @ClassName SelectionSort * @Description 选择排序算法 * @Author roseduan * @Date 2018/11/11 21:01 * @Version 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectionSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//查找最小值</span>            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//交换位置</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            data<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综合代码分析，不难看出，选择排序的平均时间复杂度是O(n<sup>2</sup>)，是一种原地排序算法，空间复杂度是O(1)，那么它和冒泡排序一样，是稳定的排序吗？答案是否定的，选择排序是一种不稳定的排序算法。</p><p>因为选择排序每次都要在未排序区间找到最小值，并且和前面的元素交换位置，这样就破坏了稳定性。例如一个数组[3,3,1,7,2]，第一次排序的时候，找到最小值1和第一个3交换，这样两个3的位置就乱了，所以就不稳定了。</p><h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h4><p>插入排序的思路其实和选择排序类似，都是将排序数分为已排序区间和未排序区间，插入排序的具体做法是这样的：依次遍历未排序区间，将未排序区间的数和已排序区间的数组进行比较，将其插入到合适的位置上，保证已排序区间一直都是有序的，遍历完成排序则完成。</p><p>结合下面的图来理解一下：</p><p><img src="https://roseduan.github.io/images/%E6%8F%92%E5%85%A5.png" alt=""></p><p>是不是很简单呢？你可以思考一下它的代码实现，然后在参考我下面的代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @ClassName InsertionSort * @Description 插入排序算法 * @Author roseduan * @Date 2018/11/25 20:11 * @Version 1.0 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertionSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> value <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上分析，插入排序的平均时间复杂度是O(n<sup>2</sup>)，是一种原地排序算法，空间复杂度是O(1)，那么它是稳定的吗？我们来分析一下：结合上面的代码，只有当data[j] &gt; value的时候，才会交换两个元素的位置，所以这并不会破坏稳定性，例如一个数组[1,3,3,7,5]，5和7交换了位置之后，由于5&gt;3，所以并不会继续交换位置。所以我们可以得知：插入排序是稳定的排序算法。</p><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>好了，三种基本的排序算法都已经学完了，针对其是否稳定，时间复杂度等性质，我总结了一下：</p><p><img src="https://roseduan.github.io/images/%E6%80%BB%E7%BB%93.png" alt=""></p><p>其实这三种排序算法在实际的开发场景中用的并不多，因为时间复杂度较高，只适用于小规模的数据排序。但是你可以自己实现一下，锻炼一下自己的思维和编码能力。下一次讲讲述更常用的归并排序和快速排序。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我说看文档是最快捷有效的学习方式？</title>
      <link href="/2018/11/27/wei-shi-me-wo-shuo-kan-wen-dang-shi-zui-kuai-jie-you-xiao-de-xue-xi-fang-shi/"/>
      <url>/2018/11/27/wei-shi-me-wo-shuo-kan-wen-dang-shi-zui-kuai-jie-you-xiao-de-xue-xi-fang-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>以前我学习一门新技术的时候，总会有一个习惯的动作，那就是打开浏览器，百度搜索“xxx教程”，然后在众多列表里面寻找自己认为质量还不错的教程。</p><p>但是这样有一个很大的问题，那就是时间成本较高。我很难在短时间内快速的寻找到自己想要看到的内容，因为搜索出来的内容参差不齐，大部分是CSDN、博客园上面的博客，有的是简书、知乎等等乱七八糟的网站链接。在没有长时间的经验积累下，我就会一个一个挨着打开，然后浏览一遍内容，然后返回打开下一个……所以我说这样做的时间成本是很高的。</p><p>还有，在我刚入门的时候，比如学Java基础，总是喜欢看视频来学习，但是网上的视频资源太多了怎么办？那就需要花时间来寻找适合的教程，百度一搜，也是很多东西。现在看来，网上关于基础内容的一些教学视频大多讲得非常得啰嗦，经常性的聊一些无关的内容，我觉得这样太浪费时间了。</p><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>后来我发现，其实学习到的很多技术，比如Redis，Solr，SSM，Git等等，在其官方网站上面都会有详细的参考文档，这都是官方开发人员的总结教程，比较的权威，十分适合快速入门新的技术。还有一大优点是不用花时间去寻找，一般在官网的首页就能看到。但有一个很大的问题就是这些文档绝大部分都是英文的，并且我也不建议你直接鼠标右键然后翻译成简体中文，因为这种翻译的效果太差了。于是这样一道门槛把很多人都拦住了。</p><p>其实我也是这样的，看到长篇大论的英文，的确很头痛，索性放弃，去寻找其他的教程。但是后来我想，我非科班出身，起点本来就比别人低，要是还按照常规的套路，进步岂不是太慢了？所以我只能硬着头皮看官方英文文档了，刚开始肯定痛苦，但是经验积累多了，慢慢的就会好很多，顺便也能提高一下自己的英文水平，何乐而不为呢。</p><p>同理，对于学习一些较为系统的内容，比如编程语言Java、Python等，网上很难找到系统的文字教程。所以我推荐看书，虽然花点钱，但是效率高很多了，省去了寻找教学视频的时间和教学视频讲师瞎BB的时间。如果连一本书都没有耐心看下去的话，我也并不认为干其他的事情会有耐心。</p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>但是对于刚入门的人来说，书上的有些内容的确很难理解，必须要视频讲授帮助理解。这种情况，看视频还是可以的，但是记住一点，那就是免费的视频大多是垃圾。遇到问题，需要借助搜索解决，那么我不推荐百度，因为百度出来的内容大部分质量堪忧，倒不如花点钱买个VPN上Google。记住一点，如果一个问题能够花钱这种方式来解决，那么这种方式一定是最好的。</p>]]></content>
      
      
      <categories>
          
          <category> 无事杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无事杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——-排序（一）</title>
      <link href="/2018/11/25/shu-ju-jie-gou-yu-suan-fa-pai-xu-yi/"/>
      <url>/2018/11/25/shu-ju-jie-gou-yu-suan-fa-pai-xu-yi/</url>
      
        <content type="html"><![CDATA[<h4 id="1-导言"><a href="#1-导言" class="headerlink" title="1.导言"></a>1.导言</h4><p>因为这是排序算法系列的第一篇文章，所以多啰嗦几句。</p><p>排序是很常见的算法之一，现在很多编程语言都集成了一些排序算法，比如Java 的Arrays.sort()方法，这种方式让我们可以不在乎内部实现细节而直接调用，在实际的软件开发当中也会经常使用到。但是站在开发者的角度而言，知其然必须知其所以然。多练练排序算法，不仅能够让我们知道一些排序方法的底层实现细节，更能够锻炼我们的思维，提升编程能力。现在很多技术面试也会涉及到基本的排序算法，所以多练习是有好处的。</p><p>文中涉及到的代码都是Java实现的，但是不会涉及到太多的Java语言特性，并且我会加上详细的注释，帮助你理解代码并且转换成你熟悉的编程语言。</p><p>常见的排序算法有以下10种：</p><ul><li>冒泡排序、选择排序、插入排序，平均时间复杂度都是O(n<sup>2</sup>)</li><li>希尔排序、归并排序、快速排序、堆排序，平均时间复杂度都是O(nlogn)</li><li>计数排序、基数排序、桶排序，平均时间复杂度都是O(n + k)</li></ul><p>在开始具体的排序算法讲解之前，先得明白两个概念：</p><ol><li>原地排序：指的是在排序的过程当中不会占用额外的存储空间，空间复杂度为O(1)。</li><li>排序算法的稳定性：一个稳定的排序，指的是在排序之后，相同元素的前后顺序不会被改变，反之就称为不稳定。举个例子：一个数组[3，5，1，4，9，6，<u>6</u>，12]有两个6（为了区分，我把一个6加上了下划线），如果排序之后是这样的：[1，3，4，5，6，<u>6</u>，9，12]（加下划线的6仍然在前面），就说明这是一个稳定的排序算法。</li></ol><h4 id="2-言归正传"><a href="#2-言归正传" class="headerlink" title="2.言归正传"></a>2.言归正传</h4><p>冒泡排序的思路其实很简单，一个数据跟它相邻的数据进行大小的比较，如果满足大小关系，就将这两个数据交换位置。一直重复这个操作，就能将数据排序。 </p><p>举个例子，假如有数组a[3,5,1,4,9,6]，第一次冒泡的操作如下图所示：</p><p><img src="https://roseduan.github.io/images/%E5%86%92%E6%B3%A1.png" alt=""></p><p>重复进行这个操作，6次冒泡之后，数据排序完成。</p><p>根据这个思路，你很容易能够写出下面的代码实现冒泡排序：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//data表示整型数组，n表示数组大小</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//数组大小小于等于1，无须排序，返回空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果data[j] > data[j + 1]，交换两个数据的位置</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这个排序算法还可以进行优化，当冒泡操作已经没有数据交换的时候，说明排序已经完成，就不用在进行冒泡操作了。例如上面的例子，第一次冒泡之后，数据为[3,1,4,5,6,9]，再进行一次冒泡，数据变为[1,3,4,5,6,9]，此时已经完成了排序，就可以结束循环了。</p><p>所以针对这个数组的排序，上面的代码需要6次冒泡才能完成，其中有4次都是不需要的。所以可以对代码进行优化：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//优化后的冒泡排序</span>    <span class="token comment" spellcheck="true">//data表示整型数组，n表示数组大小</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//数组大小小于等于1，无须排序，返回空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断是否有数据交换</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果data[j] > data[j + 1]，交换两个数据的位置</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表示有数据交换</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果没有数据交换，则直接退出循环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，冒泡排序的基本思路和代码都已经实现，最后总结一下：</p><ol><li>冒泡排序是基于数据比较的</li><li>最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n<sup>2</sup>)，平均时间复杂度是O(n<sup>2</sup>)</li><li>冒泡排序是原地排序算法，并且是稳定的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>报到贴</title>
      <link href="/2018/11/19/bao-dao-tie/"/>
      <url>/2018/11/19/bao-dao-tie/</url>
      
        <content type="html"><![CDATA[<h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>说来惭愧，在去年的这个时候，我就已经想要搭建自己的博客了，并且折腾了一天，基本上完成了初步的搭建。但是我并没有使用起来，这个博客也就荒废在这里了。大概一年之后，可能是外部因素的刺激，也可能是自身的觉悟使然，让我又重新搭建起自己的博客。浪费了一年时间之后，有一种悔不当初的复杂心情，也有重新来过的轻快愉悦，在这里，我写下roseduan的个人博客的第一篇文章。</p><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>前段时间，我看到了公众号【码农翻身】里面的一篇文章，里面有说到写作对于一个程序员有多么的重要。具体的内容不必赘述，只想阐述其中的一点：</p><blockquote><p> 一个知识点学没学透彻，一个很有效的判断的方法就是你能不能够向别人讲述清楚这个知识点。很多时候，我们在学习的时候，知识在内心有个大致的概念，感觉自己弄懂了，但是要你自己表述出来，我们常常感到很困难，这就说明我们其实并没有彻底弄懂这个知识。那该怎么办，我们总不能老是拿别人来做自己的知识练习对象，‘哎哎，我今天学了数据库，我给你讲讲吧！’，刚开始别人可能还有兴趣听一听，但是长此以往没有人受得了。</p><p>所以，写作的优势就能够体现出来了。写作逼着你去思考，去总结，去想怎么把这个问题说明白。其实这就直接锻炼了我们的文字组织能力和语言表达能力。</p></blockquote><p>以上，是近期直接导致我想要重新开始写博客的原因，因为这个观点戳中了我内心最真实的想法。长期以来，我接触到的这方面的东西实在不少，总是建议我们应该写作，应该坚持下去。但是碍于自己的写作意识不够和不能够更好坚持下去的缘由，我迟迟未能在这一片天地开拓出自己的空间，但现在，是时候了。</p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>互联网时代的好处之一便是将一些远在天边的人和自己以某种方式相联系，让我能够从中学习到别人身上的优点，看到别人的光环，并知道别人是怎么做到这一切的。我很幸运的能够接触到一些行业内的比较厉害的人，跟我类似的也大有人在：非科班出身，自学编程，成为行业大牛，互联网大V。我从这些人身上看到了很多共同的优点，其中之一便是长期坚持写作。虽说我跟他们的差距非常的大，但这并不妨碍我在心中播下梦想的种子，因为有期待就有前进的动力。</p><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><p>我的写作经验大都是在我的公众号【roseduan】上面积累的，但是更新连续性并不是很好，经常出现较长时间的停更。而且这上面都是非技术性的文章，所以只要脑子没有打开，没有新的思考的话，就比较难长时间的更新。但是我不会放弃的，公众号与博客，将是我长期写作的地方。困难将可以预见，那就是我能不能长时间的坚持下去，还有就是初期的写作不会博得太多的关注，还有以后的时间安排问题。这些困难基本上是每个人都会遇到的，有的人中途放弃了，有的人挺下来了，这也是考验一个人最直接的方式吧。</p><h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><p>我大四了，在学校已经没有课程了，仅剩的任务便是毕业论文，可以说我的大学生活基本上结束了。在不久的以后面临的便是社会的考验和职场的洗礼。对于技术人来说，初入职场需要注意些什么，需要培养哪些软技能，我已经听说了不少，无非是写作、英语、演讲、投资理财等等，却没有机会实际的感触一下。但是在大学期间从写作开始，我觉得很不错了。</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 无事杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无事杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
