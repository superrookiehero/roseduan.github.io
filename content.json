{"meta":{"title":"roseduan的个人博客","subtitle":"roseduan`s blog","description":null,"author":"roseduan","url":"http://roseduan.github.io"},"pages":[{"title":"关于我","date":"2018-11-25T13:39:37.000Z","updated":"2018-11-25T14:30:59.546Z","comments":true,"path":"about/index.html","permalink":"http://roseduan.github.io/about/index.html","excerpt":"","text":"关于我 Java开发者一名，非科班出身，自学编程。喜欢Java、Python语言，热爱数据结构与算法，喜欢捣鼓新的技术，时常关注圈内热点信息。 相信可以通过自身的努力让自己变得更好，更希望在互联网行业走得更深更远。 关于学习 计算机基础是我很重视的内容，计算机系统、数据结构与算法、计算机网络等，都是我长期需要学习的内容。以后的方向：转行大数据。 兴趣爱好 阅读是第一爱好，爱看文学类相关书籍，目前喜欢毛姆的书籍多一些。喜欢写作分享，技术类和感悟类都涉及，博客和公众号是目前主要的写作阵地。爱运动，喜欢足球，C罗忠粉，平时喜欢打网球。 关于城市 在成都上大学，待了四年。最向往的中国城市是上海，想要在上海扎根！ 座右铭 Only the strong survive. 联系我 你可以通过以下方式找到我： Github： https://github.com/roseduan QQ：1952479124 微信公众号："}],"posts":[{"title":"秋招以4个offer结束","slug":"秋招以4个offer结束","date":"2018-12-07T12:03:16.000Z","updated":"2018-12-07T13:02:59.157Z","comments":true,"path":"2018/12/07/秋招以4个offer结束/","link":"","permalink":"http://roseduan.github.io/2018/12/07/秋招以4个offer结束/","excerpt":"","text":"1.我的秋招终于结束了，从十月份开始，到现在差不多两个月的时间，收获算不上多么的丰富，成果算不上多么骄傲，但是自己已经尽了力了，问心无愧。 2.其实可以以11月为一个节点 ，11月之前，学校还在上课，参加招聘心态比较的放松，因为那时候总感觉自己离社会人还远呢，离工作也还远，没什么紧迫感。运气还算好，跌跌撞撞拿到了一个上海公司的offer，这是第一个。到了十一月初，大家都走了，室友都去了永辉超市实习，搞得我也想去。因为那时候我还没找到实习，但是学院又在催，交什么实习材料，让我很紧张。所以我打算去永辉超市磨练一下自己，一来应付学院，二来还可以赚点钱，感觉还是不错的。 理想很丰满，但是，在永辉超市干了两天，我就待不下去了。因为实在是很无聊，干的事情不多，整天就站在那里，也不能玩手机，让我感觉度日如年。如果有很多事情做，我可能是不会走的，但是在当时那种情况下，我甚至都没考虑，直接给店长说我不干了。 3.出来之后，开始专心的找工作了，而且是能够实习的那种。现在看来，我想从那个时候开始才是对我真正的考验吧，因为我感受到实实在在的压力了。刚开始，非常的艰难，去面试了很多家公司，基本上都失败了。坐公交地铁去面试，不知道去了多少次，一来一回基本上就是一整天。有的时候会回来等待面试的结果，这个等待过程是最难熬的，有的时候很想直接打电话过去问，但是又害怕得到一个让自己失望的结果。 在11月之后的大半个月里，颗粒无收，心里没想过放弃那肯定是假的。有时候的确会想，这么折腾干嘛啊，自己回来好好学习，明年再找工作不行吗。但是我没有，傻傻的坚持下去了，并且把握住了最后的机会。到现在为止，拿到4个offer，两个上海的，一个外企，一个成都的，质量算不上多好，差强人意。 4.很庆幸的是自己没有放弃，更重要的是没有停止学习，没有停止提升自己的技术能力。这在无形之中帮助了我，我记得很清楚的一点就是，在一家公司没有答上来的问题，我会回来单独看一下，尽量把它做出来。后来在面试另一家的时候，他问到了类似的问题，这样我就游刃有余了。所以现在我学到一个新的知识点的时候，都会想，要是早点学到这个知识点的话，说不定我那次面试就过了啊！同时这也在潜意识里提醒我不能停止学习，特别是干软件开发这一行，就更加要有危机意识了。 奔波的这两个月里，也遇到了一些很厉害的人，其中不乏刚毕业年薪就几十万的那种。我想这种人的存在，对自己是一种激励，因为永远有人比你更强，永远不能停止前进的脚步。 5.有句话说毕业之后，才能真正的看到人与人之间的差距了。我想是这样的，无论是从事哪个行业，只要自己感兴趣，就算在毕业的时候从零开始，工作之后能够付出常人所不能达到的努力程度，也照样有机会实现逆袭。所以有能力的，没能力的，毕业之前是怎么样的，那都不重要了。社会的大门已经慢慢的向我敞开，真正的挑战和磨练也才刚刚开始，希望自己能够以低调的姿态进入职场，并且虚心的学习，永远保持初学者的姿态，提升自己的能力；能够接触更优秀的人，学习别人的长处，开拓自己的见识。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"数据结构与算法——栈","slug":"数据结构与算法——栈","date":"2018-12-07T06:31:11.000Z","updated":"2018-12-07T11:34:17.363Z","comments":true,"path":"2018/12/07/数据结构与算法——栈/","link":"","permalink":"http://roseduan.github.io/2018/12/07/数据结构与算法——栈/","excerpt":"","text":"1.栈前面说到了链表，其实常见的，简单的数据结构还有栈和队列，今天就来看看这两种数据结构。 栈其实很好理解，举个例子：办公桌上的一堆文件，后放上去的、位于最上方的，总是最先拿到的；而先放进去的，反而会被压在最后，所以总是最后才能拿到。这种满足了先进后出、后进先出的特点的数据结构，就叫做栈。 很明显，栈是一种操作受限的数据结构，插入和删除都只能在一端进行，插入操作叫做入栈，删除叫做出栈。那么怎么实现一个栈呢？有两种方式，一是利用数组来实现，这种叫做顺序栈，二是利用链表来实现，叫做链式栈。这里来看看怎么用数组来实现一个顺序栈。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @ClassName ArrayStack * @Description 用数组实现顺序栈 * @Author Rose_Duan * @Date 2018/11/4 16:43 * @Version 1.0 **/public class ArrayStack &#123; private String[] items; private int count;//栈中元素的个数 private int n;//栈容量 //不带参的构造器，默认栈容量大小是10 public ArrayStack() &#123; this(10); &#125; public ArrayStack(int capacity) &#123; this.items = new String[capacity]; this.count = 0; this.n = capacity; &#125; //入栈操作 public boolean push(String item)&#123; //数组容量已满，则无法插入 if (this.count == n) return false; items[count] = item; ++ this.count; return true; &#125; //出栈操作 public String pop()&#123; //栈为空 if (this.count == 0) return null; String result = items[this.count - 1]; -- count; return result; &#125;&#125; 接下来看看时间复杂度：结合代码不难想到，不管是入栈还是出栈，都是在栈一端进行的惭怍，所以插入和删除的时间复杂度都是O(1)。链式栈的定义也比较的简单了，我这里给出了链式栈的简单的两个方法：入栈和出栈： 123456789101112131415161718192021222324252627282930313233343536373839public class LinkedListStack&#123; private int size; private Node top;//栈顶结点 //入栈 public void push(int value)&#123; Node newNode = new Node(value, this.top); this.top = newNode; ++ this.size; &#125; //出栈 public int pop()&#123; Node popNode = this.top; if (popNode == null) return null;//栈为空 this.top = popNode.next; if (this.size &gt; 0) -- this.size; return popNode.getData(); &#125; //栈中的结点定义 class Node&#123; private int data; private Node next; public Node(int data, Node next)&#123; this.data = data; this.next = next; &#125; public int getData()&#123; return this.data; &#125; &#125;&#125; 2.队列接下来再看看和栈很相似的另一种数据结构：队列。 队列跟我们常说的排队很类似，比如我们在食堂排队打饭，排在前面的人先打到饭，排在后面的人后打到饭，这种具有先进先出特点的数据结构就叫做队列。跟栈类似，队列的操作也是受限的，插入元素即入队列只能在队列尾部进行，取出元素即出队列只能在队列头部进行。 跟栈一样，队列也有两种实现方式，用数组实现的叫做顺序队列，用链表实现的叫做链式队列。 12345678910111213141516171819202122232425262728293031323334353637383940public class ArrayQueue &#123; private String[] data; private int size;//队列容量 //队列头尾指针 private int head = 0; private int tail = 0; public ArrayQueue(int capacity) &#123; this.data = new String[capacity]; this.size = capacity; &#125; //入队列 public boolean enquque(String value) &#123; //尾指针和容量大小相同，说明队列尾部没有空间了 if (tail == size) &#123; if(head == 0) return false;//如果head == 0 &amp;&amp; tail == size，表示队列已满 //数据搬移 for(int i = head; i &lt; tail; i ++) &#123; data[i - head] = data[i]; &#125; //更新head和tail的值 head = 0; tail = tail - head; &#125; data[tail] = value; ++ tail; return true; &#125; //出队列 public String dequeue() &#123; if(head == tail) return null;//如果head等于tail，表示队列为空 String result = data[head]; ++ head; return result; &#125;&#125; 上面是顺序队列的数组实现，可以看到，出队列的时间复杂度一直为O(1)。但是入队列的情况就有点不一样了，当队尾还有空间的时候，可直接入队列，时间复杂度还是O(1)，当队尾没有空间并且队头还有空间的时候，需要将数据搬移至队头，这时候的时间复杂度就为O(n)了。 3.循环队列普通的队列比较的简单，现在来看看队列的另一种形式：循环队列。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"栈与队列","slug":"栈与队列","permalink":"http://roseduan.github.io/tags/栈与队列/"}]},{"title":"Java学习笔记2——类与继承","slug":"Java学习笔记2——对象与类","date":"2018-12-02T12:36:57.000Z","updated":"2018-12-06T13:49:56.137Z","comments":true,"path":"2018/12/02/Java学习笔记2——对象与类/","link":"","permalink":"http://roseduan.github.io/2018/12/02/Java学习笔记2——对象与类/","excerpt":"","text":"1.面向对象 1.类：类是构造对象的蓝图或模板，由类构造对象的过程称为创建类的实例。 2.对象的三个特性： 对象的行为 对象的状态 对象标识 3.类之间有常见的三种关系： 依赖（uses-a）：一个类的方法操纵另一个类的对象 聚合（has-a）：一个类的对象包含另一个类的对象 继承（is-a）：一个类继承另一个类 4.一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。 2.自定义类 1.在一个源文件当中，只能有一个公共类，可以有任意数目的非共有类。 2.构造器总是伴随着new操作符的执行被调用，不能用一个对象来调用构造器。 3.被定义为final的实例域，必须在构造器中对其进行初始化，在后续的操作中，不能修改。 4.静态变量和静态方法都属于类，不能对对象进行操作。静态方法可以访问自身类中的静态域。 5.有下面两种情况使用静态方法： 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供。例如Math.pow() 一个方法只需要访问类的静态域。 3.方法参数 1.按值调用表示方法接收的是调用者提供的值，按引用调用表示方法接收的是调用者提供的变量地址。 2.Java总是采用按值调用，方法不能修改传递给它的任何参数变量的内容。 3.一个方法不能修改一个基本数据类型的参数；一个方法可以改变一个对象参数的状态；一个方法不能让对象参数引用新的对象。 4.对象构造 1.如果多个方法有相同的名称、返回值类型，不同的参数，便产生了重载。 2.执行顺序：静态初始化块 &gt; 初始化块 &gt; 构造器 3.访问修饰符： public：可以被任意的类使用 private：只能被定义他们的类使用 default：同一个包中任意类可访问 protected：同一个包中和所属子类可访问 4.关键字this有两个用途：一是引用隐式参数，二是调用该类的其他构造器。 5.在Java中，只有基本类型不是对象。其余的类型，包括数组，无论是对象数组还是基本类型数组，都扩展于Object类。 5.类设计技巧 1.一定要保证数据私有性 2.一定要对数据初始化 3.不要在类中使用过多的基本类型，也就是说，可以用其他的类代替多个相关的基本类型的使用。 4.不是所有的实例域都需要setter和getter方法，视情况而定。 5.将职责过多的类进行分解。 6.类名和方法名要体现它们的意义和职责。 6.继承 1.使用super调用构造器的语句必须是子类构造器的第一条语句。 2.super关键字有两个用途：一是调用父类的方法，二是调用父类的构造器。 3.一个对象变量能够指示多种实际类型的现象称为多态，在运行期间能够自动地选择调用哪个方法的现象称为动态绑定。 4.在覆盖一个方法的时候，子类方法不能低于父类方法的可见性。 5.阻止继承：使用final修饰符。如果将一个类声明为final，只有其中的方法自动的成为final，而不包括实例域。 7.抽象类 1.为了程序的清晰性，包含一个或多个抽象方法的类本身必须被声明为抽象的。 2.除了抽象方法外，抽象类还可以包括具体数据和具体方法。 3.如果将一个类声明为抽象的，就不能创建这个类的对象。但是可以定义一个抽象类的对象变量，引用一个不是抽象的子类的对象。 4.equals方法：用于检测一个对象是否等于另外一个对象，即判断两个对象是否具有相同的引用。","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://roseduan.github.io/categories/Java基础知识/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://roseduan.github.io/tags/Java基础/"}]},{"title":"数据结构与算法——链表","slug":"数据结构与算法——链表","date":"2018-12-02T07:13:41.000Z","updated":"2018-12-07T06:30:46.962Z","comments":true,"path":"2018/12/02/数据结构与算法——链表/","link":"","permalink":"http://roseduan.github.io/2018/12/02/数据结构与算法——链表/","excerpt":"","text":"1.概述链表可以说是最基础的数据结构之一了，使用也十分的广泛，今天就来说说链表这个数据结构。链表通常分为单链表、双向链表、循环链表，其中双链表是最常用的。 2.单链表首先来看看单链表，与数组相比，链表不需要连续的内存空间，它使用指针将不连续的内存块连接起来。其中的内存块我们称为链表的结点，为了将结点串联起来，每个结点还需要一个next指针，指向下一个结点的地址。下面是单链表的示意图： 可以从图中看到，链表的每个结点保存了数据data和指向下一个结点的指针next，其中有两个指针比较特殊，一个是头节点（第一个结点）的指针，它指向了头结点的地址，使用它我们可以遍历整个链表；另一个是尾结点（最后一个结点）的指针，它指向null，表示链表的结束。 单链表其实与我们常用的数组类似，都支持元素的插入、删除、查找，只不过单链表与数组的最大区别就是内存空间不连续，所以不用担心容量不足的问题。我们知道，数组的插入和删除操作十分的耗时，因为为了保证内存的连续性，必须进行大量的数据搬移工作。 但是链表却能够很高效的插入和删除元素，只需要改变指针的指向即可。 结合上面的图就不难理解了，单链表可以在O(1)时间复杂度内添加和删除元素，这比数组就更加有优势了。 但是有一个问题，要是我们查找一个元素呢？非常不幸，只能从链表的头结点开始遍历，然后找到元素，这样时间复杂度就为O(n)了。 这里我给出了单链表的查找和删除结点的代码，你可以结合代码来理解一下，然后动手写写其他的单链表操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SingleLinkedList &#123; private Node head = null;//定义头结点 //1.根据值查找结点 public Node getNodeByValue(int value) &#123; Node p = head; while (p != null &amp;&amp; p.getData() != value) &#123; p = p.next; &#125; return p; &#125; //2.删除值等于给定值的结点 public void deleteByValue(int value) &#123; if (head == null) return; Node p = head; Node pBefore = null;//用pBefore表示p前面一个结点 while (p != null &amp;&amp; p.getData() != value) &#123; pBefore = p; p = p.next; &#125; if (p == null) return;//说明没有找到结点 if(pBefore == null) head = head.next;//说明删除的结点是头结点 else pBefore.next = pBefore.next.next;//否则将pBefore的指针指向p的后一个结点，即删除p &#125; //定义链表结点 class Node&#123; private int data; private Node next; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; public int getData() &#123; return data; &#125; &#125;&#125; 3.循环链表循环链表其实与单链表的唯一区别就是，循环链表的尾结点指针指向了头结点，这样就形成了一个循环的结构，用来解决某些具有环形特点的问题。 4.双向链表我们重点来看一下双向链表，其实根据名字就能够猜个大概了，双向链表和单链表的区别就是：一个结点有两个指针，一个指针指向前面的结点，一个指针指向后面的结点。 不难想到，双向链表肯定会更加的占用内存空间，因为每个节点储存了两个指针，但是为什么空间消耗更大的双向链表的应用还要更多呢？其实很简单，运用前后两个指针，主要是为了查找和删除的效率更高！在单链表中，我们知道，插入和删除结点的时间复杂度都是O(1)，但是要删除一个值等于给定值的结点，结合上面单链表的delete方法，我们首先需要找到这个结点的前驱结点，然后再改变前驱结点的指针进行删除，删除的操作是O(1)，但是这个查找的过程就很耗时了，时间复杂度为O(n)。 但是在双向链表中就没有这个查找过程，因为每个节点自身保存了指向前驱结点的指针，这样就很方便的找到了前驱结点，然后在进行删除操作，整个时间复杂度是O(1)。 这里体现出来的思想，即利用更多的空间来换取时间上的更快的执行效率，就称为以空间换时间，反之就是以时间换空间。 这里我给出了双向链表的简单的插入和删除的方法，你可以参考，然后是实现其他的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * @ClassName DoubleLinkedList * @Description 双向链表的实现 * @Author Rose_Duan * @Date 2018/12/5 16:04 * @Version 1.0 **/public class DoubleLinkedList &#123; private Node head = null;//链表的头结点 //查找含有某值的结点 public Node getNodeByValue(int value)&#123; Node p = head; while (p != null &amp;&amp; p.getData() != value) p = p.next; return p; &#125; //1.在链表末尾插入结点，常规插入 public void insert(int value)&#123; Node node = new Node(value); if (head == null)&#123; head = node; return; &#125; Node p = head; while (p.next != null) p = p.next; p.next = node; node.prev = p; &#125; //2.在结点之前插入含有某值的结点 public void insertBefore(Node p, int value)&#123; if (head == null || p == null) return; Node node = new Node(value); if (p.prev == null)&#123;//说明是在头结点的前面插入 node.next = head; head.prev = node; head = node; &#125; else &#123; Node pBefore = p.prev; pBefore.next = node; node.prev = pBefore; node.next = p; p.prev = node; &#125; &#125; //3.删除某结点之前的结点 public void deleteBefore(Node p)&#123; if (head == null || p == null) return; Node delete = p.prev; Node deleteBefore = delete.prev; if (deleteBefore == null)&#123;//删除的是头结点 head = p; head.prev = null; delete.next = null; &#125; else &#123; deleteBefore.next = delete.next; p.prev = delete.prev; &#125; &#125; //打印链表中的所有数据 public void printAll()&#123; if (head == null) System.out.println(\"链表为空\"); else &#123; Node p = head; while (p != null)&#123; System.out.print(p.getData() + \" \"); p = p.next; &#125; &#125; &#125; //链表结点定义 class Node&#123; private int data; private Node prev;//前驱指针 private Node next;//后继指针 public Node(int data) &#123; this.data = data; this.prev = null; this.next = null; &#125; public int getData() &#123; return data; &#125; &#125; public static void main(String[] args) &#123; DoubleLinkedList linkedList = new DoubleLinkedList(); linkedList.insert(10); linkedList.insert(12); linkedList.insert(13); linkedList.insert(20); Node node = linkedList.getNodeByValue(12); linkedList.deleteBefore(node); Node head = linkedList.head; System.out.println(head.prev); System.out.println(head.getData()); linkedList.printAll(); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://roseduan.github.io/tags/链表/"}]},{"title":"Java学习笔记1——基本程序设计结构","slug":"Java学习笔记1——基本程序设计结构","date":"2018-12-01T13:13:36.000Z","updated":"2018-12-02T12:43:16.642Z","comments":true,"path":"2018/12/01/Java学习笔记1——基本程序设计结构/","link":"","permalink":"http://roseduan.github.io/2018/12/01/Java学习笔记1——基本程序设计结构/","excerpt":"","text":"1.Java程序示例 12345678910/* 多行注释 多行注释*/public class HelloWorld &#123; //单行注释 public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125; 1.Java对大小写敏感 2.Java类的命名规范：首字母大写的名词，如果由多个单词组成，则每个单词的首字母都应该大写，称为驼峰式命名。 3.源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。 4.//表示单行注释，/**/表示多行注释 2.数据类型 1.Java共有8种基本数据类型： 整型：byte（1字节）、short（2字节）、int（4字节）、long（8字节） 浮点型：float（4字节）、double（8字节） 字符型：char（1字节） 布尔型：boolean Java的数据类型范围都是固定的，没有无符号类型的数据。 2.数字加上前缀：0b表示二进制，0表示八进制，0x表示十六进制 3.绝大部分的程序都采用double类型，float的数值后一个后缀F，没有后缀F的浮点数值则默认为double类型。 4.boolean类型有2个值：true和false，用来判断逻辑条件。整型值和布尔值之间不能相互转换。 5.数值类型之间的转换： 如果两个操作数中有一个是double，另一个就转换为double 否则，如果如果其中一个数是float，另一个数就转换为float 否则，如果其中一个数是long，另一个数转换为long 否则，两个操作数都转换为int 3.变量 1.变量名必须是一个以字母开头的由字母或数字组成的序列。 2.可以在一行中声明多个变量，例如int i, j;，但是不建议这样做，逐个声明变量有利于提高程序的可读性。 3.利用关键字final定义常量，习惯上，常量名全大写。 4.字符串 1.String类没有提供用于修改字符串的方法，所以String类型字符串是不可变的。 2.可以使用equals方法检测两个字符串是否相等。 3.要检测一个字符串既不为null也不是空串，可以使用if(str != null &amp;&amp; str.length != 0) 4.String常用方法： char charAt(int index)：返回index位置的字符 int compareTo(String other)：按照字典顺序比较字符串 String concat(String str)：拼接字符串 contains(CharSequence s)：查看字符串是否包含 boolean startWith(String prefix)和boolean endsWith(String suffix)：以什么开始或结束 boolean equals(Object obj)：判断是否相等 indexOf、lastIndexOf split subString：截取子字符串 toCharArray()：将字符串转换为字符数组 toUpperCase()、toLowerCase() trim()：去掉字符串头部和尾部的空格 5.大数值 1.如果基本的整数和浮点数精度不能够满足需求，可以使用java.math包中的大数值类型：BigDecimal和BigInteger。这两个类可以处理任意长度数字序列的数值。 2.BigInteger实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。 3，大数值类型实现算术运算必须使用方法：add、subtract、multiply、divide分别表示加、减、乘、除。 6.数组 1.数组是一种数据结构，用来储存同一种类型的值的集合。可以通过下标访问数组中每个元素的值。 2.创建一个数字数组时，所有的元素都会初始化为0，boolean数组的元素会初始化为false，对象数组的元素会初始化为null。 3.有一个更简单的方法打印数组中的所有值：Arrays.toString() 4.数组拷贝的两种方法： 12345int[] data = &#123;1,2,3,4,5&#125;;int[] num = Arrays.copyOf(data, data.length * 2);int[] rose = new int[10];System.arraycopy(data, 0, rose, 0, data.length); 5.数组排序：Arrays.sort()，此方法采用的是快速排序实现。","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://roseduan.github.io/categories/Java基础知识/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://roseduan.github.io/tags/Java基础/"}]},{"title":"数据结构与算法——排序（三）","slug":"数据结构与算法——排序（三）","date":"2018-11-30T07:06:54.000Z","updated":"2018-12-01T09:54:19.926Z","comments":true,"path":"2018/11/30/数据结构与算法——排序（三）/","link":"","permalink":"http://roseduan.github.io/2018/11/30/数据结构与算法——排序（三）/","excerpt":"","text":"1.回顾前面说到了三种最基本的排序算法，分别是冒泡排序、选择排序、插入排序，他们的平均时间复杂度都是O(n2)，适用于小规模数据的排序，其中插入排序的效率稍高，工作中使用得更多，我也推荐使用插入排序。今天讲到的三种排序算法的时间复杂度都是O(nlogn)，分别是希尔排序、归并排序、快速排序，其中后两者的使用非常的普遍。 2.希尔排序首先来看看希尔排序，希尔排序其实本质上也是一种插入排序，只是做了一些优化，其思路是：将排序的数组按照一定的增量将数据分组，每个分组用插入排序算法排序，然后增量逐步减小，当增量减小为1的时候，算法便终止，所以希尔排序又叫做“缩小增量排序”。 我们常取的原始增量为数据的大小/2，例如数据大小为length，我们将其分为leng / 2个组，然后length = length / 2，继续分下去，直到length = 1。文字看起来比较抽象，我画了图来帮助你理解： 下面是它的代码实现： 123456789101112131415161718192021222324252627282930313233/** * @ClassName ShellSort * @Description 希尔排序算法 * @Author roseduan * @Date 2018/11/30 22:30 * @Version 1.0 **/public class ShellSort &#123; public static void shellSort(int[] data) &#123; int length = data.length; if(length &lt;= 1) return ; //定义增量 int step = length / 2; while(step &gt;= 1) &#123; for(int i = step; i &lt; length; i ++) &#123; int value = data[i]; int j = i - step; for(; j &gt;=0; j -= step) &#123; if(value &lt; data[j]) data[j + step] = data[j]; else break; &#125; data[j + step] = value; &#125; //增量缩小 step = step / 2; &#125; &#125;&#125; 很遗憾，希尔排序虽然时间复杂度为O(nlogn)，但它是一种不稳定的算法，因为分组的时候可能会错开相同的元素，分组进行插入排序的时候，元素的位置交换之后，稳定性就被破坏了。比起归并排序，它是不稳定的，比起快速排序，它的执行效率稍慢，所以希尔排序并没有应用得很广泛。 3.归并排序归并排序的思路是这样的：将排序的数据分为若干子数组，子数组排序之后，再进行合并，这样要排序的数组就能排好了。这种思想叫做分治，就是将一个大的问题分解成很多小问题，将小问题就解决了，大的问题也就解决了。用分治思想解决的问题，一般都可以用递归这种编程技巧来表示。 结合上面的图可以看到，假如我们要排序data[p……r]这个数组，首先我们将数组分为data[p……q]和data[q+1……r]，然后再进行合并，用公式可以这样表示： merge_sort(data[p……r]) = merge(merge_sort(data[p……q]), merge_sort(data[q+1……r])); merge函数表示将两个子数组进行合并。那么merge函数该怎么表示呢？ 思路是这样的：首先我们新建一个临时数组temp，大小和原始数组相同。然后使用两个指针i，j分别指向两个子数组的第一个元素，如果i所指元素 &lt; j所指元素，则将i所指元素插入temp，i向前移动；反之将j所指元素插入，j向前移动。以此类推，直到比较完成，然后将临时数组temp复制到原始数组中。 归并排序的代码是这样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @ClassName MergeSort * @Description 归并排序算法 * @Author Rose_Duan * @Date 2018/12/1 15:41 * @Version 1.0 **/public class MergeSort &#123; public static void mergeSort(int[] data, int n)&#123; mergeInternally(data, 0, n - 1); &#125; private static void mergeInternally(int[] data, int p, int r)&#123; if (p &gt;= r) return; //计算p到r的中间值q // 此等式相当于int q = (p + r) / 2，只不过下面这样写效率更高 int q = p + ((r - p) &gt;&gt; 1); //递归 //data[p r]分为data[p q]和data[q+1 r] mergeInternally(data, p, q); mergeInternally(data, q + 1, r); //合并 merge(data, p, q, r); &#125; private static void merge(int[] data, int p, int q, int r)&#123; int i = p; int j = q + 1; int k = 0; //新建一个临时数组，大小与data[p……r]一样 int[] temp = new int[r - p + 1]; while (i &lt;= q &amp;&amp; j &lt;= r)&#123; if (data[i] &lt;= data[j]) temp[k ++] = data[i ++]; else temp[k ++] = data[j ++]; &#125; //判断哪个子数组中有剩余的数据 //首先假设data[p....q]中有剩余的数据 int start = i; int end = q; //如果j小于等于r，则说明data[q+1...r]中有剩余的数据 if (j &lt;= r)&#123; start = j; end = r; &#125; //将剩余的元素拷贝到temp中 while (start &lt;= end)&#123; temp[k ++] = data[start ++]; &#125; //最后，将临时数组中的数据拷贝到data中 for(i = 0; i &lt;= r - p; i ++)&#123; data[p + i] = temp[i]; &#125; &#125;&#125; 归并排序并不是一种原地排序算法，因为很明显，我们申请了一个临时数组来保存数据，这个临时数组最大不会超过原始数组，所以空间复杂度为O(n)。归并排序的时间复杂度是O(nlogn)，并且是一种稳定的排序算法。 4.快速排序快速排序简称“快排”，它的思路和归并排序很类似，都是利用的分治思想。首先选取任意一个数据作为分区点，比分区点小的数据放在其左边，大的放在右边。 这样数组就分为了三个部分，一是分区点q，然后对p——q-1和q+1——r的数据分别再执行上图操作，这样整个数据就有序了。 归并排序当中有个merge合并函数，这里我们需要一个partition分区函数，主要的功能是实现上图的操作，将小于分区点的数据放在其左边，大于分区点的放在其右边，然后返回分区点。具体要怎么实现呢？这里用到的思路比较的巧妙：对于一个数组data[p….r]，我们选区最后一个元素data[r- 1]为分区点(也就是data[pivot])，然后用两个指针i，j指向第一个元素，如果data[j] &lt; data[pivot]，那么就互换i和j所指向的元素，然后i，j向前移动。如果data[j] &gt;= data[pivot]，那么不用交换位置，i不移动，j继续移动。 结合代码看一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @ClassName QuickSort * @Description 快速排序算法 * @Author Rose_Duan * @Date 2018/11/14 13:44 * @Version 1.0 **/public class QuickSort &#123; public static void quickSort(int[] data, int n)&#123; quickSortInternally(data, 0, n - 1); &#125; private static void quickSortInternally(int[] data, int p , int r)&#123; if (p &gt;= r) return; int q = partition(data, p, r);//获取分区点 //递归 quickSortInternally(data, p, q - 1); quickSortInternally(data, q + 1, r); &#125; private static int partition(int[] data, int p, int r)&#123; int pivot = data[r]; int i = p; for (int j = p; j &lt; r; j++) &#123; if (data[j] &lt; pivot)&#123; int temp = data[i]; data[i] = data[j]; data[j] = temp; i ++; &#125; &#125; int temp = data[i]; data[i] = data[r]; data[r] = temp; return i; &#125;&#125; 很明显，在partition分区函数中，我们交换了元素的顺序，这样值相同的元素的前后顺序可能会被打乱，你可以结合我前面对partition函数的描述在看一下，所以快速排序是不稳定的。快速排序的平均时间复杂度是O(nlogn)，并且是一种原地排序算法，空间复杂度是O(1)。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://roseduan.github.io/tags/排序算法/"}]},{"title":"中国的大学都是这样应对评估的吗？","slug":"难道中国的大学都是这样应对评估的吗？","date":"2018-11-29T13:45:38.000Z","updated":"2018-12-04T15:02:09.448Z","comments":true,"path":"2018/11/29/难道中国的大学都是这样应对评估的吗？/","link":"","permalink":"http://roseduan.github.io/2018/11/29/难道中国的大学都是这样应对评估的吗？/","excerpt":"","text":"1.还记得以前上初中还是高中的时候（有点记不清了），时不时的会有教育局的某某领导前来视察，首先学校的领导会肯定会提前广播通知：xxx领导将于xx天到我校来视察，请各班进行大扫除，注意卫生，规范个人行为………… 那个时候并没有想太多，全班人一起大扫除感觉也挺有乐趣的，擦窗户，扫地，拖地板，大伙都忙得不亦乐乎。有时候坐在座位上都有点胆战心惊，生怕自己的某些小动作被领导抓个正着，所以只能万事小心了。当时并不太懂，老师叫大家做什么就做什么，也没觉得有什么不妥。但后来我发现绝大多数学校都是这样来招呼前来的领导的时候，我甚至都有点鄙视当初毫无反抗之意的自己。 2.在大学待了几年，活得自由自在，就算有领导来视察，那也跟自己没有多大的关系了，所以不用像以前那样听老师的安排做些什么事情。上学期，我有好几次到学生处办公室那里办点事情，就发现楼梯那里贴了“离教学评估还有xx天”的一个倒计时板，看到它的第一眼，我倒是想起来高中教室里的高考倒计时。我心想还是不错的嘛，学校挺重视这个评估工作的嘛，只是当时并没有发现学校有什么变化，可能是领导们还在做准备吧。 3.到近些时候，走在校园里面，到处都能看见变化，地上的地板在翻新了，好多楼也在重新粉刷了，路口多了很多指路的牌子，一些工人整天忙个不停，那个帕子擦擦这，擦擦那。学校体育馆的操场几年没见动静，今年倒是花了血本，修了很长时间，整出了新模样。图书馆也新增了很多桌椅和其他的设施，这些都是在今年暑假开始弄的，现在我才想起来这样做是为了什么。 4.前几天我去学校图书馆，一进去就被惊呆了，借书的人排起了很长的队伍，而且每个人手中都拿了好几本书。我就很纳闷了，在学校呆了三年多，对图书馆非常的熟悉，大一还在图书馆兼职负责借还书，没来没有见过有这么多人借书的情形。后来打听明白了，原来是每个班都强制要求大家来借书，整体提高图书馆的书籍借阅情况，当然目的还是一个，让领导高兴嘛。“今年我校学生平均借阅书籍xx本，较去年提高了xx，表明我校学生…………”，皆大欢喜的结果。 我还偶然看到了一个同学的发言，虽然不知道他是否是在遵守图书馆座位规定的情况下说出这样的话，如果是的话，那他说的话就值得思考了，并且我也很欣慰，至少内心有反抗思想的人还是有的。 5.类似的情况比比皆是，比如让同学们背诵评估手册，方便领导抽查。评估口号好像是这样的：以评促建，以评促改，以评促管，评建结合，重在建设。这口号是真的好，真是辛苦学校的官员些根据学校的实际情况，构思出这么有正能量，麻痹自己，麻痹同学们的口号。以评促建，不知道你早干嘛去了，非要等到评估来的时候你才建设，其中我想重点说说学校的某个学院，学院办公室外面的装饰真是太漂亮了，我敢说全中国的大学很少能找到把办公室装饰得这么浮夸的。比较讽刺的是，学院logo下面还写着学校的校训“严谨、朴实、勤奋、创新”，不知道这个学院是对朴实有了新的理解，还是在坚持的走创新之路。 6.其实我一直在想，整个学校全体动员，是否向每一位学生传递了这样的价值观：既然学校可以为了评估而临时抱佛脚，那么学生可以为了期末考试而临时抱佛脚，评估可能过了，考试也可能过了，得到一个皆大欢喜的结果，但是学校和我们真的变得更好了吗？ 我在这个学校待了三年，从来没有抱怨过，环境也好，身边的人也好。因为它至少给了我一个平台，哺育我大学四年，我心中还是怀有感恩之情的，想写点东西，并不是针对，因为这也改变不了什么，只是心里过不去。 其实也不知道教育部评估组的某些傻逼怎么想的，干嘛一定要把到校评估的时间确定呢，然后学校像备战高考一样忙得不亦乐乎。你可以提前一点，来个突袭啊，这不是更能看到真实的情况吗？ 7.不管怎么样，学校总归是在建设的，从另一个方面来说，对每一位同学还是有好处的。对于那些已经离校的人，以后回到学校，看到这样的变化，可能会觉得欣喜，感到自豪，因为自己的母校变得更好了。但是对于一些知道情况的人，知道学校是在这样的节骨眼上进行的改变，心中可能会……额，可能会像钱钟书在《围城》里面描述的那样：心中又惊喜，又佩服，又鄙夷，种种复杂情绪化作一口浓痰吐了出去。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"与stormzhang的一次线上面基","slug":"与stormzhang的一次线上面基","date":"2018-11-29T09:38:02.000Z","updated":"2018-11-29T13:01:11.808Z","comments":true,"path":"2018/11/29/与stormzhang的一次线上面基/","link":"","permalink":"http://roseduan.github.io/2018/11/29/与stormzhang的一次线上面基/","excerpt":"","text":"1.现在不用隐瞒了，上次我说的加入了某个星球，其实就是stormzhang的星球。为什么要这样做呢，上次这篇文章已经说到了，对于投资自己，我是不会含糊的。 上周stormzhang在斗鱼上面开了直播，这是他第一次面向球友开直播，我也没有错过这次机会，三个小时的直播，收获还是挺大的。其实我一直都挺怀疑的，因为加入星球能得到什么呢？星主会不会拿钱跑路了？但是基于自己的判断，我还是做出了自认为正确的决定。我一直认为我看人是比较准的，当我看到他的时候，我就知道我的决定应该没错，后面三个小时的交流也证实了这一点。 2.有人问他为什么戾气这么重，是因为赚了很多钱之后很骄傲了吗？他回答说不是的，现在的网络环境很复杂，网民素质参差不齐，戾气重，主要是为了规避一些喷子、杠精等等，因为价值观跟别人不同，没必要去和别人浪费时间。现在很多人在网上表现出来的样子可能和真实生活的样子完全不一样，网上要是看谁不爽了，可以骂他一句傻逼，但是在真实生活中，就算很不喜欢一个人，你也不会当着面骂别人傻逼。 其实我很能理解，当一个人有自己的规划、有自己独立的思想的时候，不会总是花时间去和一些和自己没有必要的联系的人瞎扯，比如一个人老是对你指指点点，在你公众号后台留言骂你，你能怎么办，自己的事情还多呢，哪有功夫闲扯，只能骂他一句傻逼了事。 3.后来又说了很多，大多是关于未来的趋势，其中询问区块链的人最多。他也说到了这个，主要是对区块链持悲观态度，因为区块链对社会生产、人们的生活并没有什么实质性的改变，至少现在尚未体现出来。现在区块链的火热，其实与媒体和企业的炒作有关，当然这也是一种个人预测，因为没有人能够很准确的看到未来。还有说到关于怎么样去坚持做好一些值得做的事情，比如写作、阅读等，当然这都是老生常谈了，给我留下较为深刻印象的却是另外的两点。 4.有人问到这样一个问题：他是搞嵌入式开发的，除去自身努力，怎么样才能得到更好的发展呢？stormzhang 的回答让我印象深刻，他说嵌入式、网络，这些偏硬件层次的，不会直接和用户打交道，都是在底层忙活。要想获得好的发展，就必须进入顶级大公司，得到这些公司强大的资源和平台支持，才可能有一些机会，否则是是很艰难的。而开发、产品、运营这方面的工作，或多或少都会跟用户打交道，了解用户需求，这也是现在软件开发、产品类岗位比较火爆的原因，因为产品最终总是会面向用户的。 5.还有一个问题就更加具有代表性了，有人问到，现在在学Android开发，不知道是否来得及，以及Android开发的前景怎么样。回答是这样的：现在的Android，Java其实已经趋于饱和，机会已经不大，从头开始学的确有点晚了。但是趋于饱和并不代表没有市场，只是学的人很多，有的人已经在这个行业摸爬打滚了几年，积累了经验，企业的选择多了，那么它肯定会钟情于更加有技术能力和经验的人。 的确是这样，我们常说，有时候选择比努力更重要，因为正确的选择会让你少走很多弯路，甚至让你实现弯道超车。认准一个更加有发展趋势的行业、技术领域，早做准备，当机会来临的时候，就比别人更加有优势了。 但是怎么样去看到一些可能的趋势呢？一个方法便是多关注顶级互联网科技公司的一些发展战略，因为巨头总是喜欢投资未来，抢占市场。现在的一些公司，其实对未来趋势的嗅觉更加灵敏了，因为已经经历过一波又一波的互联网浪潮，谁也不想丧失掉在未来的发展机遇。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"数据结构与算法——排序（二）","slug":"数据结构与算法——排序（二）","date":"2018-11-29T07:52:06.000Z","updated":"2018-11-29T13:47:10.414Z","comments":true,"path":"2018/11/29/数据结构与算法——排序（二）/","link":"","permalink":"http://roseduan.github.io/2018/11/29/数据结构与算法——排序（二）/","excerpt":"","text":"1.回顾前面说到了冒泡排序，这种算法的思路比较的简单，就是基于两个元素之间的比较，然后交换位置。冒泡排序的平均时间复杂度是O(n2)，空间复杂度是(1)，并且是稳定的排序算法。今天继续讲述另外两种排序算法：选择排序和插入排序。 2.选择排序选择排序的思路是这样的：将要排序的数组分为未排序区间和已排序区间，遍历未排序区间，找到其最小值（或者最大值），将其插入到已排序区间的末尾。依次遍历，直到将未排序区间遍历完，整个排序操作就完成了。我画了一张图来帮助你理解其原理： 相信结合这个图你就不能理解选择排序了，下面是它的代码实现： 1234567891011121314151617181920212223242526/** * @ClassName SelectionSort * @Description 选择排序算法 * @Author roseduan * @Date 2018/11/11 21:01 * @Version 1.0 **/public class SelectionSort &#123; public static void selectionSort(int[] data) &#123; int length = data.length; if (length &lt;= 1) return; for(int i = 0; i &lt; length - 1; i ++) &#123; //查找最小值 int minIndex = i; for(int j = i + 1; j &lt; length; j ++) &#123; if (data[j] &lt; data[minIndex]) minIndex = j; &#125; //交换位置 int temp = data[i]; data[i] = data[minIndex]; data[minIndex] = temp; &#125; &#125;&#125; 综合代码分析，不难看出，选择排序的平均时间复杂度是O(n2)，是一种原地排序算法，空间复杂度是O(1)，那么它和冒泡排序一样，是稳定的排序吗？答案是否定的，选择排序是一种不稳定的排序算法。 因为选择排序每次都要在未排序区间找到最小值，并且和前面的元素交换位置，这样就破坏了稳定性。例如一个数组[3,3,1,7,2]，第一次排序的时候，找到最小值1和第一个3交换，这样两个3的位置就乱了，所以就不稳定了。 3.插入排序插入排序的思路其实和选择排序类似，都是将排序数分为已排序区间和未排序区间，插入排序的具体做法是这样的：依次遍历未排序区间，将未排序区间的数和已排序区间的数组进行比较，将其插入到合适的位置上，保证已排序区间一直都是有序的，遍历完成排序则完成。 结合下面的图来理解一下： 是不是很简单呢？你可以思考一下它的代码实现，然后在参考我下面的代码实现： 12345678910111213141516171819202122232425/** * @ClassName InsertionSort * @Description 插入排序算法 * @Author roseduan * @Date 2018/11/25 20:11 * @Version 1.0 **/public class InsertionSort &#123; public static void insertionSort(int[] data) &#123; int length = data.length; if (length &lt;= 1) return; for(int i = 1; i &lt; length; i ++) &#123; int value = data[i]; int j = i - 1; for(; j &gt;= 0; j --) &#123; if(data[j] &gt; value) data[j + 1] = data[j]; else break; &#125; data[j + 1] = value; &#125; &#125;&#125; 综上分析，插入排序的平均时间复杂度是O(n2)，是一种原地排序算法，空间复杂度是O(1)，那么它是稳定的吗？我们来分析一下：结合上面的代码，只有当data[j] &gt; value的时候，才会交换两个元素的位置，所以这并不会破坏稳定性，例如一个数组[1,3,3,7,5]，5和7交换了位置之后，由于5&gt;3，所以并不会继续交换位置。所以我们可以得知：插入排序是稳定的排序算法。 4.总结好了，三种基本的排序算法都已经学完了，针对其是否稳定，时间复杂度等性质，我总结了一下： 其实这三种排序算法在实际的开发场景中用的并不多，因为时间复杂度较高，只适用于小规模的数据排序。但是你可以自己实现一下，锻炼一下自己的思维和编码能力。下一次讲讲述更常用的归并排序和快速排序。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://roseduan.github.io/tags/排序算法/"}]},{"title":"为什么我说看文档是最快捷有效的学习方式？","slug":"为什么我说看文档是最快捷有效的学习方式","date":"2018-11-27T08:32:56.000Z","updated":"2018-11-29T07:51:05.637Z","comments":true,"path":"2018/11/27/为什么我说看文档是最快捷有效的学习方式/","link":"","permalink":"http://roseduan.github.io/2018/11/27/为什么我说看文档是最快捷有效的学习方式/","excerpt":"","text":"1.以前我学习一门新技术的时候，总会有一个习惯的动作，那就是打开浏览器，百度搜索“xxx教程”，然后在众多列表里面寻找自己认为质量还不错的教程。 但是这样有一个很大的问题，那就是时间成本较高。我很难在短时间内快速的寻找到自己想要看到的内容，因为搜索出来的内容参差不齐，大部分是CSDN、博客园上面的博客，有的是简书、知乎等等乱七八糟的网站链接。在没有长时间的经验积累下，我就会一个一个挨着打开，然后浏览一遍内容，然后返回打开下一个……所以我说这样做的时间成本是很高的。 还有，在我刚入门的时候，比如学Java基础，总是喜欢看视频来学习，但是网上的视频资源太多了怎么办？那就需要花时间来寻找适合的教程，百度一搜，也是很多东西。现在看来，网上关于基础内容的一些教学视频大多讲得非常得啰嗦，经常性的聊一些无关的内容，我觉得这样太浪费时间了。 2.后来我发现，其实学习到的很多技术，比如Redis，Solr，SSM，Git等等，在其官方网站上面都会有详细的参考文档，这都是官方开发人员的总结教程，比较的权威，十分适合快速入门新的技术。还有一大优点是不用花时间去寻找，一般在官网的首页就能看到。但有一个很大的问题就是这些文档绝大部分都是英文的，并且我也不建议你直接鼠标右键然后翻译成简体中文，因为这种翻译的效果太差了。于是这样一道门槛把很多人都拦住了。 其实我也是这样的，看到长篇大论的英文，的确很头痛，索性放弃，去寻找其他的教程。但是后来我想，我非科班出身，起点本来就比别人低，要是还按照常规的套路，进步岂不是太慢了？所以我只能硬着头皮看官方英文文档了，刚开始肯定痛苦，但是经验积累多了，慢慢的就会好很多，顺便也能提高一下自己的英文水平，何乐而不为呢。 同理，对于学习一些较为系统的内容，比如编程语言Java、Python等，网上很难找到系统的文字教程。所以我推荐看书，虽然花点钱，但是效率高很多了，省去了寻找教学视频的时间和教学视频讲师瞎BB的时间。如果连一本书都没有耐心看下去的话，我也并不认为干其他的事情会有耐心。 3.但是对于刚入门的人来说，书上的有些内容的确很难理解，必须要视频讲授帮助理解。这种情况，看视频还是可以的，但是记住一点，那就是免费的视频大多是垃圾。遇到问题，需要借助搜索解决，那么我不推荐百度，因为百度出来的内容大部分质量堪忧，倒不如花点钱买个VPN上Google。记住一点，如果一个问题能够花钱这种方式来解决，那么这种方式一定是最好的。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"数据结构与算法——-排序（一）","slug":"数据结构与算法——排序（一）","date":"2018-11-25T14:20:39.000Z","updated":"2018-11-27T09:38:25.461Z","comments":true,"path":"2018/11/25/数据结构与算法——排序（一）/","link":"","permalink":"http://roseduan.github.io/2018/11/25/数据结构与算法——排序（一）/","excerpt":"","text":"1.导言因为这是排序算法系列的第一篇文章，所以多啰嗦几句。 排序是很常见的算法之一，现在很多编程语言都集成了一些排序算法，比如Java 的Arrays.sort()方法，这种方式让我们可以不在乎内部实现细节而直接调用，在实际的软件开发当中也会经常使用到。但是站在开发者的角度而言，知其然必须知其所以然。多练练排序算法，不仅能够让我们知道一些排序方法的底层实现细节，更能够锻炼我们的思维，提升编程能力。现在很多技术面试也会涉及到基本的排序算法，所以多练习是有好处的。 文中涉及到的代码都是Java实现的，但是不会涉及到太多的Java语言特性，并且我会加上详细的注释，帮助你理解代码并且转换成你熟悉的编程语言。 常见的排序算法有以下10种： 冒泡排序、选择排序、插入排序，平均时间复杂度都是O(n2) 希尔排序、归并排序、快速排序、堆排序，平均时间复杂度都是O(nlogn) 计数排序、基数排序、桶排序，平均时间复杂度都是O(n + k) 在开始具体的排序算法讲解之前，先得明白两个概念： 原地排序：指的是在排序的过程当中不会占用额外的存储空间，空间复杂度为O(1)。 排序算法的稳定性：一个稳定的排序，指的是在排序之后，相同元素的前后顺序不会被改变，反之就称为不稳定。举个例子：一个数组[3，5，1，4，9，6，6，12]有两个6（为了区分，我把一个6加上了下划线），如果排序之后是这样的：[1，3，4，5，6，6，9，12]（加下划线的6仍然在前面），就说明这是一个稳定的排序算法。 2.言归正传冒泡排序的思路其实很简单，一个数据跟它相邻的数据进行大小的比较，如果满足大小关系，就将这两个数据交换位置。一直重复这个操作，就能将数据排序。 举个例子，假如有数组a[3,5,1,4,9,6]，第一次冒泡的操作如下图所示： 重复进行这个操作，6次冒泡之后，数据排序完成。 根据这个思路，你很容易能够写出下面的代码实现冒泡排序： 12345678910111213141516171819public class BubbleSort &#123; //data表示整型数组，n表示数组大小 public static void bubbleSort(int[] data, int n)&#123; //数组大小小于等于1，无须排序，返回空 if (n &lt;= 1) return; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; //如果data[j] &gt; data[j + 1]，交换两个数据的位置 if (data[j] &gt; data[j + 1])&#123; int temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 但是这个排序算法还可以进行优化，当冒泡操作已经没有数据交换的时候，说明排序已经完成，就不用在进行冒泡操作了。例如上面的例子，第一次冒泡之后，数据为[3,1,4,5,6,9]，再进行一次冒泡，数据变为[1,3,4,5,6,9]，此时已经完成了排序，就可以结束循环了。 所以针对这个数组的排序，上面的代码需要6次冒泡才能完成，其中有4次都是不需要的。所以可以对代码进行优化： 12345678910111213141516171819202122232425public class BubbleSort &#123; //优化后的冒泡排序 //data表示整型数组，n表示数组大小 public static void bubbleSort(int[] data, int n)&#123; //数组大小小于等于1，无须排序，返回空 if (n &lt;= 1) return; for (int i = 0; i &lt; n; i++) &#123; boolean flag = false;//判断是否有数据交换 for (int j = 0; j &lt; n - i - 1; j++) &#123; //如果data[j] &gt; data[j + 1]，交换两个数据的位置 if (data[j] &gt; data[j + 1])&#123; int temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; flag = true;//表示有数据交换 &#125; &#125; //如果没有数据交换，则直接退出循环 if (!flag) break; &#125; &#125;&#125; 好了，冒泡排序的基本思路和代码都已经实现，最后总结一下： 冒泡排序是基于数据比较的 最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n2)，平均时间复杂度是O(n2) 冒泡排序是原地排序算法，并且是稳定的。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://roseduan.github.io/tags/排序算法/"}]},{"title":"培训机构的小姐姐是如何说服你的","slug":"培训机构的小姐姐是如何说服你的","date":"2018-11-21T08:48:27.000Z","updated":"2018-11-24T09:28:39.463Z","comments":true,"path":"2018/11/21/培训机构的小姐姐是如何说服你的/","link":"","permalink":"http://roseduan.github.io/2018/11/21/培训机构的小姐姐是如何说服你的/","excerpt":"","text":"1.秋招已经接近尾声，我在成都也已经找了好多家公司面试了，但都不是很顺利。归根结底，还是自己的技术能力不够吧，在有了生存的压迫之下，自己的学习才能够有紧迫性，希望抓紧时间。但是今天我主要想说的确实另外的一件事。 2.前天到一家公司面试，说起奇怪，这家公司的地址给我的感觉跟其他的不一样，我以前面试的公司一般都是在某个写字楼，但是这家公司在一个较为低矮的房子里。我一走进去，就能看见每一层楼梯都写着“……教育，专注于培养专业技术人才……”，那一刻我就明白了，原来这公司是培训机构！ 那天还早，我又没有其他的地方可去，所以我索性就直接进去看看了。果不其然，里面有很多教室，有很多人正在上课。我跟其他的几个人在一起听了他们对公司的介绍，然后一个自称技术经理的人说要带着我们花三天时间做一个小的项目，算是对我们的一个技术检验。如果通过，就可以直接推荐去公司。 但是我下午还有其他的面试，我不打算在那里多待，就给负责人说了我下午要走。负责人说既然这样的话，那我就直接给你安排技术面试吧。我心想还不错啊，技术面试要是过了的话，就可以直接去公司了。结果，她所说的技术面试就是安排一个人给你洗脑，让你去他们的培训。 3.我很无语啊，我就这样不明所以的和她聊了一个多小时，大多数时候都是她在说。后来我总结了一下，她的套路基本上是这样的： 首先她知道，我最近在找工作，而且还不太顺利，然后她就拿出了他们的培训课程体系让我看看，我说大部分我都是学过的，但都不是很精通，有些还没学过呢。她就介绍他们的课程怎么怎么好，老师多么专业，而且他们现在还在做十二周年活动，这个月报名的话，费用会比平时少很多。但是这种套路我很熟悉了，别说这个月了，就算明年你再去报名，费用还是可以商量的。 然后她会给你说他们这里的学生的就业情况，拿到的工资基本上都是8K，9K，10K以上的，而且大部分都是非计算机专业，零基础前来培训的。她就会说，你是计算机专业的，有这方面的基础，在这里培训几个月，把自己的技术弄扎实，毕业的时候在找个好工作，完全是没问题的。 然后她会拿出他们学员跟她的微信聊天记录，基本都是就业工资的问题，让你明确她说的是没错的。她还会举几个特里来刺激你，比如某个非计算机专业的女生，学Java开发，零基础，就业工资18K，听起来实在是很诱人。她说人家一个女生都能取得这样的成就，那么一个男生就更加没有理由犹豫了。 还有的特例，比如说有个学员已经找到了工作，但是主动辞职前来培训，主要是想把自己的技术在巩固一下。所以她就给你说，就算你现在运气好，找到了一个实习的工作，但是你的压力会特别的大，这样工作下去，你的技术等各方面的能力是很难有长进的。 现在的培训机构很聪明了，都是打着招聘的幌子把你忽悠过去，然后就指出你的技术方面的问题，然后就给你洗脑。其实我心里并没有很讨厌给我稀里糊涂讲了一大堆的那位工作人员，毕竟这也是别人的工作，我得尊重一个努力对待自己工作的人，但是很可惜，她找错目标对象了。 其实我心里对培训机构并不排斥，因为这也是一条出路，不然就不会有那么多的培训机构产生了。 4.我在那里还遇到一个人，他是前来了解IT这行业的。跟他简单聊了几句，才知道他是12年毕业的，这几年没怎么工作，又没有什么一技之长，所以对未来十分的迷茫。他想从事开发方面的工作，但是又碍于各种因素而畏手畏脚，比如年纪比较大了，学习的难度可能比较高等等。在他的眼里，我看到了迷茫、不知所措和对未来的恐惧。的确，在这个竞争日益激烈的社会，自身硬实力是生存下去的根本，还有认准行业很重要，俗话说，站在趋势的风口下，猪都会飞！","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"报到贴","slug":"报到贴","date":"2018-11-19T13:40:09.000Z","updated":"2018-11-22T15:04:24.393Z","comments":true,"path":"2018/11/19/报到贴/","link":"","permalink":"http://roseduan.github.io/2018/11/19/报到贴/","excerpt":"","text":"1.说来惭愧，在去年的这个时候，我就已经想要搭建自己的博客了，并且折腾了一天，基本上完成了初步的搭建。但是我并没有使用起来，这个博客也就荒废在这里了。大概一年之后，可能是外部因素的刺激，也可能是自身的觉悟使然，让我又重新搭建起自己的博客。浪费了一年时间之后，有一种悔不当初的复杂心情，也有重新来过的轻快愉悦，在这里，我写下roseduan的个人博客的第一篇文章。 2.前段时间，我看到了公众号【码农翻身】里面的一篇文章，里面有说到写作对于一个程序员有多么的重要。具体的内容不必赘述，只想阐述其中的一点： 一个知识点学没学透彻，一个很有效的判断的方法就是你能不能够向别人讲述清楚这个知识点。很多时候，我们在学习的时候，知识在内心有个大致的概念，感觉自己弄懂了，但是要你自己表述出来，我们常常感到很困难，这就说明我们其实并没有彻底弄懂这个知识。那该怎么办，我们总不能老是拿别人来做自己的知识练习对象，‘哎哎，我今天学了数据库，我给你讲讲吧！’，刚开始别人可能还有兴趣听一听，但是长此以往没有人受得了。 所以，写作的优势就能够体现出来了。写作逼着你去思考，去总结，去想怎么把这个问题说明白。其实这就直接锻炼了我们的文字组织能力和语言表达能力。 以上，是近期直接导致我想要重新开始写博客的原因，因为这个观点戳中了我内心最真实的想法。长期以来，我接触到的这方面的东西实在不少，总是建议我们应该写作，应该坚持下去。但是碍于自己的写作意识不够和不能够更好坚持下去的缘由，我迟迟未能在这一片天地开拓出自己的空间，但现在，是时候了。 3.互联网时代的好处之一便是将一些远在天边的人和自己以某种方式相联系，让我能够从中学习到别人身上的优点，看到别人的光环，并知道别人是怎么做到这一切的。我很幸运的能够接触到一些行业内的比较厉害的人，跟我类似的也大有人在：非科班出身，自学编程，成为行业大牛，互联网大V。我从这些人身上看到了很多共同的优点，其中之一便是长期坚持写作。虽说我跟他们的差距非常的大，但这并不妨碍我在心中播下梦想的种子，因为有期待就有前进的动力。 4.我的写作经验大都是在我的公众号【roseduan】上面积累的，但是更新连续性并不是很好，经常出现较长时间的停更。而且这上面都是非技术性的文章，所以只要脑子没有打开，没有新的思考的话，就比较难长时间的更新。但是我不会放弃的，公众号与博客，将是我长期写作的地方。困难将可以预见，那就是我能不能长时间的坚持下去，还有就是初期的写作不会博得太多的关注，还有以后的时间安排问题。这些困难基本上是每个人都会遇到的，有的人中途放弃了，有的人挺下来了，这也是考验一个人最直接的方式吧。 5.我大四了，在学校已经没有课程了，仅剩的任务便是毕业论文，可以说我的大学生活基本上结束了。在不久的以后面临的便是社会的考验和职场的洗礼。对于技术人来说，初入职场需要注意些什么，需要培养哪些软技能，我已经听说了不少，无非是写作、英语、演讲、投资理财等等，却没有机会实际的感触一下。但是在大学期间从写作开始，我觉得很不错了。 ​","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]}]}