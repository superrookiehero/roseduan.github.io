{"meta":{"title":"roseduan的个人博客","subtitle":"博客正在重建中…………","description":"Stay hungry, stay foolish.","author":"roseduan","url":"http://roseduan.github.io"},"pages":[{"title":"关于我","date":"2018-11-25T13:39:37.000Z","updated":"2018-11-25T14:30:59.546Z","comments":true,"path":"about/index.html","permalink":"http://roseduan.github.io/about/index.html","excerpt":"","text":"关于我 Java开发者一名，非科班出身，自学编程。喜欢Java、Python语言，热爱数据结构与算法，喜欢捣鼓新的技术，时常关注圈内热点信息。 相信可以通过自身的努力让自己变得更好，更希望在互联网行业走得更深更远。 关于学习 计算机基础是我很重视的内容，计算机系统、数据结构与算法、计算机网络等，都是我长期需要学习的内容。以后的方向：转行大数据。 兴趣爱好 阅读是第一爱好，爱看文学类相关书籍，目前喜欢毛姆的书籍多一些。喜欢写作分享，技术类和感悟类都涉及，博客和公众号是目前主要的写作阵地。爱运动，喜欢足球，C罗忠粉，平时喜欢打网球。 关于城市 在成都上大学，待了四年。最向往的中国城市是上海，想要在上海扎根！ 座右铭 Only the strong survive. 联系我 你可以通过以下方式找到我： Github： https://github.com/roseduan QQ：1952479124 微信公众号："},{"title":"categories","date":"2019-05-05T13:23:33.000Z","updated":"2019-05-05T13:24:19.578Z","comments":true,"path":"categories/index.html","permalink":"http://roseduan.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-05-05T13:11:43.000Z","updated":"2019-05-05T13:12:57.369Z","comments":true,"path":"friends/index.html","permalink":"http://roseduan.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-05T13:23:44.000Z","updated":"2019-05-05T13:24:43.601Z","comments":true,"path":"tags/index.html","permalink":"http://roseduan.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-05T13:30:16.546Z","updated":"2019-05-05T13:30:16.546Z","comments":true,"path":"categories/Java基础知识/index.html","permalink":"http://roseduan.github.io/categories/Java基础知识/index.html","excerpt":"","text":"分类: Java基础知识 | roseduan的个人博客 roseduan的个人博客 首页 标签 分类 归档 关于 友情链接 roseduan的个人博客 Stay hungry, stay foolish. 首页 标签 分类 归档 关于 友情链接 Fork Me .nav-transparent .github-corner { display: none !important; } .github-corner { position: absolute; z-index: 10; top: 0; right: 0; border: 0; transform: scale(1.1); } .github-corner svg { color: #0f9d58; fill: #fff; height: 64px; width: 64px; } .github-corner:hover .octo-arm { animation: a 0.56s ease-in-out; } .github-corner .octo-arm { animation: none; } @keyframes a { 0%, to { transform: rotate(0); } 20%, 60% { transform: rotate(-25deg); } 40%, 80% { transform: rotate(10deg); } } 博客正在重建中………… Stay hungry, stay foolish. // Dynamically switch banner pictures every day. $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &nbsp;&nbsp;文章分类 Java基础知识 4 无事杂谈 15 数据结构与算法 8 Java学习笔记4——集合 1.对于标准集合中的任何集合，都可以使用foreach循环，遍历整个集合。 1.队列 1.双端队列：在队列的头部和尾部都可以添加、删除元素， 2018-12-11 Java基础知识 Java基础 Java学习笔记3——异常和泛型 一、异常 1.异常分类 所有的异常都是由Throwable继承而来的，分为Error和Exception。 error表示Java运行时系统 2018-12-09 Java基础知识 Java基础 Java学习笔记2——类、继承、接口 1.面向对象 1.类：类是构造对象的蓝图或模板，由类构造对象的过程称为创建类的实例。 2.对象的三个特性： 对象的行为 对象的状态 对象标 2018-12-02 Java基础知识 Java基础 Java学习笔记1——基本程序设计结构 1.Java程序示例 /* 多行注释 多行注释 */ public class HelloWorld { //单行注释 2018-12-01 Java基础知识 Java基础 本站由&copy;Blinkfox基于 Hexo 的 hexo-theme-matery主题搭建. 本站总访问量 次,&nbsp;访客数 人. &nbsp;&nbsp;搜索 searchFunc(\"/\" + \"search.xml\", 'searchInput', 'searchResult');"},{"title":"","date":"2019-05-05T13:30:16.546Z","updated":"2019-05-05T13:30:16.546Z","comments":true,"path":"categories/数据结构与算法/index.html","permalink":"http://roseduan.github.io/categories/数据结构与算法/index.html","excerpt":"","text":"分类: 数据结构与算法 | roseduan的个人博客 roseduan的个人博客 首页 标签 分类 归档 关于 友情链接 roseduan的个人博客 Stay hungry, stay foolish. 首页 标签 分类 归档 关于 友情链接 Fork Me .nav-transparent .github-corner { display: none !important; } .github-corner { position: absolute; z-index: 10; top: 0; right: 0; border: 0; transform: scale(1.1); } .github-corner svg { color: #0f9d58; fill: #fff; height: 64px; width: 64px; } .github-corner:hover .octo-arm { animation: a 0.56s ease-in-out; } .github-corner .octo-arm { animation: none; } @keyframes a { 0%, to { transform: rotate(0); } 20%, 60% { transform: rotate(-25deg); } 40%, 80% { transform: rotate(10deg); } } 博客正在重建中………… Stay hungry, stay foolish. // Dynamically switch banner pictures every day. $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &nbsp;&nbsp;文章分类 Java基础知识 4 无事杂谈 15 数据结构与算法 8 数据结构与算法——堆和堆排序 1.什么是堆 堆（Heap），其实是一种特殊的二叉树，主要满足了二叉树的两个条件：1. 堆是一种完全二叉树，还记得完全二叉树的定义吗？叶节点 2018-12-23 数据结构与算法 堆和堆排序 数据结构与算法——二分查找 1.二分查找的实现二分查找的思路其实比较的简单，在生活当中的应用也十分的广泛：在一个有序的数据集合中，我们要查找一个数据，就直接取数据集中间 2018-12-11 数据结构与算法 二分查找 数据结构与算法——排序（四） 1.回顾前面已经说了几种基于元素比较的排序，其中归并和快速排序的应用稍多，今天就来讨论几种线性排序，这几种排序对数据的要求比较的高，但是如果 2018-12-09 数据结构与算法 排序 数据结构与算法——栈与队列 1.栈前面说到了链表，其实常见的、简单的数据结构还有栈和队列，今天就来看看这两种数据结构。 栈其实很好理解，举个例子：办公桌上的一堆文件，后 2018-12-07 数据结构与算法 栈与队列 数据结构与算法——链表 1.概述链表可以说是最基础的数据结构之一了，使用也十分的广泛，今天就来说说链表这个数据结构。链表通常分为单链表、双向链表、循环链表，其中双链 2018-12-02 数据结构与算法 链表 数据结构与算法——排序（三） 1.回顾前面说到了三种最基本的排序算法，分别是冒泡排序、选择排序、插入排序，他们的平均时间复杂度都是O(n2)，适用于小规模数据的排序，其中 2018-11-30 数据结构与算法 排序算法 数据结构与算法——排序（二） 1.回顾前面说到了冒泡排序，这种算法的思路比较的简单，就是基于两个元素之间的比较，然后交换位置。冒泡排序的平均时间复杂度是O(n2)，空间复 2018-11-29 数据结构与算法 排序算法 数据结构与算法——-排序（一） 1.导言因为这是排序算法系列的第一篇文章，所以多啰嗦几句。 排序是很常见的算法之一，现在很多编程语言都集成了一些排序算法，比如Java 的A 2018-11-25 数据结构与算法 排序算法 本站由&copy;Blinkfox基于 Hexo 的 hexo-theme-matery主题搭建. 本站总访问量 次,&nbsp;访客数 人. &nbsp;&nbsp;搜索 searchFunc(\"/\" + \"search.xml\", 'searchInput', 'searchResult');"},{"title":"","date":"2019-05-05T13:30:16.591Z","updated":"2019-05-05T13:30:16.591Z","comments":true,"path":"categories/无事杂谈/page/2/index.html","permalink":"http://roseduan.github.io/categories/无事杂谈/page/2/index.html","excerpt":"","text":"分类: 无事杂谈 | roseduan的个人博客 roseduan的个人博客 首页 标签 分类 归档 关于 友情链接 roseduan的个人博客 Stay hungry, stay foolish. 首页 标签 分类 归档 关于 友情链接 Fork Me .nav-transparent .github-corner { display: none !important; } .github-corner { position: absolute; z-index: 10; top: 0; right: 0; border: 0; transform: scale(1.1); } .github-corner svg { color: #0f9d58; fill: #fff; height: 64px; width: 64px; } .github-corner:hover .octo-arm { animation: a 0.56s ease-in-out; } .github-corner .octo-arm { animation: none; } @keyframes a { 0%, to { transform: rotate(0); } 20%, 60% { transform: rotate(-25deg); } 40%, 80% { transform: rotate(10deg); } } 博客正在重建中………… Stay hungry, stay foolish. // Dynamically switch banner pictures every day. $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &nbsp;&nbsp;文章分类 Java基础知识 4 无事杂谈 15 数据结构与算法 8 为什么我说看文档是最快捷有效的学习方式？ 1.以前我学习一门新技术的时候，总会有一个习惯的动作，那就是打开浏览器，百度搜索“xxx教程”，然后在众多列表里面寻找自己认为质量还不错的教 2018-11-27 无事杂谈 无事杂谈 培训机构的小姐姐是如何说服你的 1.秋招已经接近尾声，我在成都也已经找了好多家公司面试了，但都不是很顺利。归根结底，还是自己的技术能力不够吧，在有了生存的压迫之下，自己的学 2018-11-21 无事杂谈 无事杂谈 报到贴 1.说来惭愧，在去年的这个时候，我就已经想要搭建自己的博客了，并且折腾了一天，基本上完成了初步的搭建。但是我并没有使用起来，这个博客也就荒废 2018-11-19 无事杂谈 无事杂谈 2 / 2 本站由&copy;Blinkfox基于 Hexo 的 hexo-theme-matery主题搭建. 本站总访问量 次,&nbsp;访客数 人. &nbsp;&nbsp;搜索 searchFunc(\"/\" + \"search.xml\", 'searchInput', 'searchResult');"},{"title":"","date":"2019-05-05T13:30:16.556Z","updated":"2019-05-05T13:30:16.556Z","comments":true,"path":"categories/无事杂谈/index.html","permalink":"http://roseduan.github.io/categories/无事杂谈/index.html","excerpt":"","text":"分类: 无事杂谈 | roseduan的个人博客 roseduan的个人博客 首页 标签 分类 归档 关于 友情链接 roseduan的个人博客 Stay hungry, stay foolish. 首页 标签 分类 归档 关于 友情链接 Fork Me .nav-transparent .github-corner { display: none !important; } .github-corner { position: absolute; z-index: 10; top: 0; right: 0; border: 0; transform: scale(1.1); } .github-corner svg { color: #0f9d58; fill: #fff; height: 64px; width: 64px; } .github-corner:hover .octo-arm { animation: a 0.56s ease-in-out; } .github-corner .octo-arm { animation: none; } @keyframes a { 0%, to { transform: rotate(0); } 20%, 60% { transform: rotate(-25deg); } 40%, 80% { transform: rotate(10deg); } } 博客正在重建中………… Stay hungry, stay foolish. // Dynamically switch banner pictures every day. $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &nbsp;&nbsp;文章分类 Java基础知识 4 无事杂谈 15 数据结构与算法 8 职场中，能说会写是巨大的优势 1. 入职一个多月，观察到了一个很普遍的现象：一个团队的 leader 每天都花费了很多的时间在沟通上面。 从早上的团队小会议开始，说说昨 2019-01-22 无事杂谈 无事杂谈 追女孩子好难。。。 1. 一室友，周末的时候，给一个女生发微信，想要约出来看电影。结果很惨，人家一天都没回复他，到了晚上的时候才说：对不起啊，才看到消息。。。 2019-01-16 无事杂谈 无事杂谈 放寒假了，听说你又要去兼职 1. 不管是放什么假，学生朋友们都喜欢去做点兼职，暑假最频繁，寒假也不少，有的甚至平时在校期间的周末都会去做兼职，做的什么呢？大抵是送外卖 2019-01-13 无事杂谈 无事杂谈 该学点什么计算机基础好呢 1. 昨晚在知乎上面看到了一个问题：现在的程序员应该学些什么计算机基础知识，以及有哪些推荐的书呢？我想了一会，打算写一些自己知道的东西。说 2019-01-10 无事杂谈 无事杂谈 坚持零碎的输出其实也挺重要的 1. 写作这件事，说来还真挺不简单，一是需要长期坚持写下去，能够有持续性的输出，最忌讳的是三天打鱼两天晒网，这样效果很不好，我深有体会，因 2019-01-07 无事杂谈 无事杂谈 我们是怎样被大学上了的？ 1. 还记得三年前的那个金秋九月，你刚走进大学校园的时候，就被周围的热闹景象吸引了，热情的学长学姐接过你的行李箱，带你走进宿舍楼。你为一路 2019-01-04 无事杂谈 无事杂谈 说说2018年的这些事 1. 先说说大环境吧。 2018 年，注定是不平凡的一年，有太多的事情一次又一次出现在我们的视野之中，金立进入了破产清算；锤子科技遭遇生存危 2019-01-01 无事杂谈 无事杂谈 和女朋友的一周年 1. 话说，今天，2019年1月1日，我和女朋友在一起刚好一年了。去年这个时候，我花了三天时间将她追到手，从约出来见面到吃个饭聊个天到确定关 2019-01-01 无事杂谈 无事杂谈 地铁上的乞讨者 1. 一件小事，却引发了我一些思考。 前不久，我在地铁上的时候，正在玩自己的手机。突然迎面走来一个女生，年龄不大，20岁左右，穿着一件红色的 2019-01-01 无事杂谈 无事杂谈 秋招以4个offer结束 1.我的秋招终于结束了，从十月份开始，到现在差不多两个月的时间，收获算不上多么的丰富，成果算不上多么骄傲，但是自己已经尽了力了，问心无愧。 2018-12-07 无事杂谈 无事杂谈 中国的大学都是这样应对评估的吗？ 1.还记得以前上初中还是高中的时候（有点记不清了），时不时的会有教育局的某某领导前来视察，首先学校的领导会肯定会提前广播通知：xxx领导将于 2018-11-29 无事杂谈 无事杂谈 与stormzhang的一次线上面基 1.现在不用隐瞒了，上次我说的加入了某个星球，其实就是stormzhang的星球。为什么要这样做呢，上次这篇文章已经说到了，对于投资自己，我 2018-11-29 无事杂谈 无事杂谈 1 / 2 本站由&copy;Blinkfox基于 Hexo 的 hexo-theme-matery主题搭建. 本站总访问量 次,&nbsp;访客数 人. &nbsp;&nbsp;搜索 searchFunc(\"/\" + \"search.xml\", 'searchInput', 'searchResult');"}],"posts":[{"title":"职场中，能说会写是巨大的优势","slug":"职场中，能说会写是巨大的优势","date":"2019-01-22T15:22:29.000Z","updated":"2019-01-23T15:06:15.689Z","comments":true,"path":"2019/01/22/zhi-chang-zhong-neng-shuo-hui-xie-shi-ju-da-de-you-shi/","link":"","permalink":"http://roseduan.github.io/2019/01/22/zhi-chang-zhong-neng-shuo-hui-xie-shi-ju-da-de-you-shi/","excerpt":"","text":"1. 入职一个多月，观察到了一个很普遍的现象：一个团队的 leader 每天都花费了很多的时间在沟通上面。 从早上的团队小会议开始，说说昨天做的一些事情，然后解决团队成员的实际问题，并且布置新的任务下去；遇到了问题，打电话向上级反映，说出自己的想法，商量寻求解决方案；或是直接和客户沟通，倾听意见，对需求进行更改或是提出新的需求。 我想，不只是一个小团队的 leader，甚至是更高级的领导，每天工作时和各种人沟通交流的时间，都是非常多的。相反，越是职位偏低的员工，每天大部分时间都是在做本职业务，比如写代码或是修 bug。沟通交流非常有限，顶多是向 leader 反映问题，汇报情况，或是同事之间商量遇到的问题之类的。 想要单纯的成为技术很厉害的人，跟很多因素相关，例如接触到的环境，受到的教育，自己的学习能力、执行力，以及坚持的毅力等等，所以这类人很少。那么，对于大部分人来说，要想弥补在技术方面的缺陷，或是增强自己的综合能力，沟通就显得很重要了。况且，再举一个稍微极端的例子，像 Linus 这么牛逼的技术人，不也到处给别人说道 Linux 系统么。 沟通交流，是一个信息互换的过程，你表述清楚自己的观点，整理成别人能够接受的语言，说出去；别人表述他的观点，你倾听，然后整理成自己理解的信息。真正的沟通，是很有效率的，但很多时候我们遇到这种情况：别人说什么我们听起来很费劲，或者反之，所以能说，并不代表会沟通，沟通是一项能力，得刻意去练。 2. 会写，也是一项很重要、需要刻意练习的能力。往小了说，领导叫写一个什么总结、展望之类的报告，或是写一些技术文档，或是写一个关于某个技术的 PPT 教程，这都涉及到写的能力。我们有时候总会感觉自己心里明明能理解，但就是写不出来，要么就是写出来跟自己心里想的大相径庭，这都是写作能力不强的体现。 往大了说，写作能够锻炼我们的语言组织能力，因为写作的本质就是把自己所理解的东西，转化为清晰、有效的语言，然后描述下来。 再者，写作能够扩大自己的影响力，一个不太爱语言表达的人，可以换一种方式，让别人知道自己的观点、思想，然后去影响更多的人。如今，技术厉害的人其实很多，却只有很少一部分人，把自己的技术写成别人能够看懂的文章，让别人从中收益，然后借助于文章的传播性，让自己积累一定的声誉，而这种声誉，就可以慢慢转化为自己的流量。 3. 一直以来，无论是我自己，还是别人，都将我定义为一个比较内向的人，不太爱表达。的确是这样，在这方面我很了解自己，这有两个好处，一是可以避短，二是可以针对性的加强。前面我说了，能说不代表会沟通，同样，内向也并不代表不会沟通，沟通是一项能力，就像骑自行车，不论是什么样的人，都得先学会了才能一直骑着走。所以，我并不强迫自己在任何场合都得和别人侃侃而谈，一来有时候倾听也可以观察到一些很有趣的现象，二来我比较注重高效的沟通，就是不废话，直入正题，这也正是职场中的交流所要求的。 说到写，我也刚入门，现在也才算是慢慢的养成习惯，能够感受到的一个好处就是：自己的任何一个观点，都能够较为完整的呈现出来，就像这篇文章一样，不会抓耳挠腮，半天写不出一句话。虽说文章质量、技巧、论点论据等方面尚需提高，但这也有很多时间去完善，首先得坚持写下去，才看得到收获与提高。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"追女孩子好难。。。","slug":"追女孩子好难好难。。。","date":"2019-01-16T12:59:28.000Z","updated":"2019-01-19T16:07:18.070Z","comments":true,"path":"2019/01/16/zhui-nu-hai-zi-hao-nan-hao-nan/","link":"","permalink":"http://roseduan.github.io/2019/01/16/zhui-nu-hai-zi-hao-nan-hao-nan/","excerpt":"","text":"1. 一室友，周末的时候，给一个女生发微信，想要约出来看电影。结果很惨，人家一天都没回复他，到了晚上的时候才说：对不起啊，才看到消息。。。当然，室友很生气，觉得自己被套路了，然后忍不住感慨：我终于知道为什么现在男追女越来越少了，遂打开电脑玩游戏。 2. 没错，现在的男生追女生总是感觉越来越难了，自己努力半天，嘘寒问暖，笑脸相迎，对面女孩子内心却毫无波澜。于是男生受挫，大多选择放弃，还时不时的吐槽一两句：现在的女人真是特么势利，只喜欢有钱有势有颜的男人！ 仔细分析一下，为什么现在追女孩子越来越难了呢？有钱有势又有颜的男人毕竟是少数，大多还是普通人。但同时不可否认的是，有的女孩子，还就是愿意跟着一个没钱的男人呢，这又怎么解释呢。一些看似普通但是又能够吸引到女生的男人，大多存在一些鲜明的特点，比如长相帅气啊，爱干净啊，有内涵啊，做饭好吃啊之类的，而这些特点总结到一起，可以用一个词来形容，那就是“信息差”。 什么叫信息差？简单的说，就是你能够让别人感受到不一样，可以是时间上自己和自己的不一样，也可以是空间上自己和别人的不一样。 你以前总是很邋遢，头发很油，衣服长时间不洗，鞋子很脏。但是突然，在追女孩子的时候，你突然变得爱好打扮了，整个人看起来不一样了，这让女生感到了一种新奇，于是她心里就会有变化。 毫无疑问，现在随着互联网的发展，微博、微信、QQ 等平台的普及，人与人之间的信息差变得越来越小了。以前，男生只要多看点书，多关注一些新闻，就可以大肆发挥，给女孩子说好半天，女孩听到自己从没听说过的东西，自然觉得高兴，并且认为这男生还是个挺有趣的人，好感顿时就有了。但是现在呢，新闻一出，各大平台在短时间内都能看到了，看书的人越来越少，会思考总结的更少，所以能够和女生分享的东西就屈指可数了。 3. 所以，可以看出，现在追女孩子的基本套路，也是较为有效的策略，便是增大自己和对方的信息差。 从外，可以多打理打理自己的外表形象，发型，穿着之类的，这还是比较重要的。因为处于这个现实的社会，别去相信有了内在美就可以不用在乎外表了，没有后者，可能连表现内在的机会都很少。毕竟现在女生的选择很多，三条腿的蛤蟆不好找，两条腿的男人遍地都是。 当然，外在的改变，由此带来的信息差是很微妙的，它能达到的效果也很有限：比如对方只会觉得你是一个还不错的人，至少懂得整理自己，大概率不会讨厌你，但要是更进一步，就需要更深层次的信息差。 深层次的信息差，内在的修养占很大一部分。像上面说到的，既然现在新闻热点已经没有什么值得说道的了，那就可以另辟蹊径，可以把一个知识点弄得很深入，也可以广泛涉猎，拓宽自己的知识面。这样一来，你就能够在和女生的交谈中占得优势，要是你的谈话内容全都是一些关于吃喝拉撒、生活琐碎，那么别人很容易感到厌倦。 还有，能够有一些大多数人都没有的技能，由此带来的信息差也是较大的。比如你文章写得好，英语说得很溜，篮球打得棒，吉他弹得好，唱歌很好听……这些都行。 我们以前看电影，发现总是那些学习成绩不好的、类似混混的学生更能追到女生，为什么？因为他们更能够带来新鲜的东西，带着女生逃课啊，逛逛酒吧啊，制造惊喜，浪漫表白，这些东西满足了女生内心深处的幻想，所制造的信息差是巨大的。 还有一个原则，就是要尽量扬长避短，比如自己明明不擅长打篮球，却指着别人说那些人打得太菜了；自己不会弹吉他，却偏要说弹吉他太简单了，我两三天就能学会；这都是不可取的做法。聪明的人，应该尽量把自己擅长的东西展现在对方面前，让别人感受到你的不一样，这样信息差就制造出来了。 4. 站在女生的角度，该如何面对追自己的男生？首先，需要认清现实，就像男生都喜欢胸大臀翘的美女一样，女生肯定也钟情于温柔体贴，长相帅气，有钱，吹拉弹唱样样精通，电脑玩得飞起，打篮球惹得妹子尖叫的男生，但是这种人，大概率只会出现在电视机里面。每个人都会有自己不擅长的东西，每个人都会有缺点，而面对追求自己的男生，女孩子能否和他无压力的相处，能否接受他最大的缺点，是能不能在一起的基本判断标准。 还有，对于强行制造信息差的男生，也需要谨慎，有些事情，的确会让女生在短期内感觉非常的愉快，像摆脱了笼子的鸟一样，但是这种男人，大多是短期迎合，短期占有。 更重要的判断因素，就是看一个男人是否有上进心，是否能够专注的做自己的事情，是否愿意为了女生拼尽全力。车子房子固然重要，但是，现在的大部分年轻人，都是没房车没钱的，找一个愿意和自己拼搏的人，也未尝不可。所以，女孩子得注意，像上进心这种精神层面的信息差，就很重要了。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"放寒假了，听说你又要去兼职","slug":"放寒假了，听说你又要去兼职","date":"2019-01-13T08:38:58.000Z","updated":"2019-01-13T13:02:46.064Z","comments":true,"path":"2019/01/13/fang-han-jia-liao-ting-shuo-ni-you-yao-qu-jian-zhi/","link":"","permalink":"http://roseduan.github.io/2019/01/13/fang-han-jia-liao-ting-shuo-ni-you-yao-qu-jian-zhi/","excerpt":"","text":"1. 不管是放什么假，学生朋友们都喜欢去做点兼职，暑假最频繁，寒假也不少，有的甚至平时在校期间的周末都会去做兼职，做的什么呢？大抵是送外卖、服务员、发传单、影院检票、工厂打零工之类的。说来很奇怪，就我所了解到的，似乎很多人，都比较热衷于做兼职，原因无非是两种，一，是缺钱，吃不起饭了，二，是可能每个人心中都有财务自由的渴望吧。第一种情况是极少数，暂且不谈。 对于我们这种学生群体，现阶段对金钱的满足程度其实是很低的，比如只要我们兼职赚了几千块钱，或是上个月的生活费剩了好几百，都会高兴好久。因为可以花钱买点自己需要的东西，其次，这满足了让我们自由支配金钱的欲望，并以为自己能够独立的面对生活了，那一瞬间的成就感的确让人振奋。 2. 兼职有问题吗？没问题，兼职能够赚到钱，而采取正当的方式赚钱永远不会错。那么，对于学生来说，在闲暇放假时期花时间做兼职，有问题吗？这就不好说了。 在我看来，有意义的兼职分为两种，一是所做的兼职跟自己以后的职业方向存在关联，比如我打算在毕业之后做销售，那么我去一家公司当销售员；我打算做程序员，那么我就接点私活，做项目，提升技术能力；我打算当作家，那么我就多看点书，多写点文章给别人投稿，赚取稿费。 二是做的兼职工作，可替代性不能太高，比如做发传单这种兼职，大学生能做，高中生能做，甚至初中生都能做，是没有什么技术含量的，被替代的风险就会比较的高。一些替代性较低的工作，除了需要经验积累的专业性工作之外，还有就是一些普通大众也能够培养的技能，比如写作，英语，摄影、投资等等。这一类工作或是技能，有一个很大的特点就是，在短期看不出什么效果，需要长期坚持积累经验才能产生质变。 但是，在大学期间就能够知道自己以后想做什么的人多吗？肯定是极少数的，就算有，能够找到相关兼职工作的更是少之又少，所以，上面说到的第一种类型的兼职，就基本上很少有人能够涉足了。再者，像上面说到的第二种，需要长期积累经验的技能，坦诚的说，在尚处于安逸的大学生活中的人，也很少有人能够有毅力去坚持。所以，这就不难解释，为什么现在我们学生做的兼职总是一些可替代性高的简单重复劳动。 3. 所以，花太多的时间在可替代性太高的兼职上面，是不太明智的，道理很简单，你打算毕业之后去做服务员、发传单这类的工作吗？大多数人是不会这样选择的。 大学的时间很充裕，可以说是人生中最充裕的时候，浪费了就白白浪费了，以后出身社会之后不可能再有了。在这段时间内，你可以多去了解自己学的这个专业以后出来到底能干嘛，需要对自己有什么要求，然后在问自己是否喜欢。中国的大学教育，存在一个很大的问题，就是没有能够及时的让学生认识清楚自己专业所处的行业，以及这个行业的发展是怎样的，需要从事这个行业的人具备哪些素质。所以导致了很多人，尽管大学期间学习很不错，但是仍然很难适应行业的要求。 其次，花时间在一些可积累性的技能上面，也是值得的。多看点书，不是为了装逼，装有文化，而是培养自己的气质，让自己学会思考；如果不喜欢专业，那就去学习点自己感兴趣的东西，为以后的职业发展多考虑。不要一天盯着个抖音，看些搞笑视频，嘿嘿笑个不停，那只会让你的大脑越来越懒得思考。 以前看着别人做兼职，在各处跑个不停，还口口声声说自己正在上班呢，一副神态，很有优越感。现在想想，只要我们家里没矿，大多数人都是要出去工作的，工作几十年，可能会工作到想吐，想哭。所以，何必急于一时呢。聪明的人，都会多想想，怎么让自己以后的工作更轻松和更有价值。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"该学点什么计算机基础好呢","slug":"该学点什么计算机基础好呢","date":"2019-01-10T14:08:59.000Z","updated":"2019-01-10T15:23:16.041Z","comments":true,"path":"2019/01/10/gai-xue-dian-shi-me-ji-suan-ji-ji-chu-hao-ni/","link":"","permalink":"http://roseduan.github.io/2019/01/10/gai-xue-dian-shi-me-ji-suan-ji-ji-chu-hao-ni/","excerpt":"","text":"1. 昨晚在知乎上面看到了一个问题：现在的程序员应该学些什么计算机基础知识，以及有哪些推荐的书呢？我想了一会，打算写一些自己知道的东西。说来很滑稽，一个非科班出身，技术很渣，对计算机基础更是尚未入门的人，却要来谈谈计算机基础知识，也不知道是谁给我的勇气。相信读者中有比较厉害的人，要是我说的不对或是不全面，欢迎指正和补充。 2. 看到过一句话，说是在面试的时候，面试官对你基础知识的重视程度，跟公司的质量成正比。要是面试官完全不在乎你的基础，那么很有可能，你是被招去当码农使唤的。很明显，现在好多人对于计算机基础是不太重视的，可能唯一的用处就是找工作面试的时候吧，所以我看到很多人在面试前临时抱佛脚，补充基础的，当然也包括我。在面试当中，大多数情况下，越优秀的公司对计算机基础越重视，比如很多一线互联网大厂如腾讯、阿里、华为等等，在面试的时候就喜欢考算法，看面试者的逻辑思维能力和编程能力。 很多人，比如现在的我，在遇到内存，多线程，并发，TCP/IP，编译，位图，动态规划等等概念的时候，就一脸懵逼，这就是对计算机基础不了解。计算机基础，就像一栋楼的根基，想要把楼盖的高，根基必须要稳定，否则我们的技术体系框架很容易一碰就倒。 3. 前面的我提到的几个概念，分别属于不同领域的基础知识。一是计算机系统，什么内存管理、进程线程、同步异步等等都属于这方面。相应的书籍有很经典的《深入理解计算机系统》，这本书搞懂了，就基本上没问题。我买了这本书，但是，有点难，阅读起来很困难。二是计算机网络，常见的知识比如 OSI 分层，TCP/UDP 区别，DNS 解析，HTTP。这块的知识我只看过《图解TCP/IP》，理解起来还是有点困难，好像还有一本相同风格的《图解HTTP》，这两本书都不错，适合入门。其他的进阶书籍，可以选择《计算机网络：自顶向下方法》。三是数据结构与算法，这一方面在面试中很常见，什么链表、队列、栈、散列表、树、排序，对程序员都挺重要的。相应的书籍有适合入门的《大话数据结构》、《算法图解》，语言相关的可以选择经典的《数据结构与算法分析：C/C++/Java/Python 语言描述》，进阶的书籍有《算法导论》。其他的还有，比如计算机组成原理，编译原理，数据库系统，Linux，甚至数学，都算是比较基础的东西。但是人的精力有限，不可能面面俱到，可以结合自己的技术方向有选择性的学习一些。比如前端、Java、Python，可以选择学习数据结构与算法，HTTP，数据库。像 C 语言这种偏低层的，对基础的要求就会更高。 4. 学习基础知识能够对我们有什么改变？就目前我所能感知的，就是，对一些底层的东西有了了解，比如学了数据结构与算法，我知道了 Java 的集合框架，比如 Map、List、Set 底层都是用的什么数据结构来支撑，Collections.sort() 原来是用了归并排序等等，现在学习到新东西，总是会想它的底层是用什么实现的，为什么会这样做。这是对我们思维上的改变，让我们不仅仅是重复的堆砌业务代码，而是真正学会思考，提升自己的技术能力。 5. 所以，多学点总是有好处的，特别是还在学校学习的人，时间很充裕。别看到现在什么人工智能、大数据、网络爬虫、云计算多么火，然后就取跟随潮流，其实揭开它们的面纱，也就那么回事。相反，那些底层的东西，基础的知识，很少有人去看，很少有人去坚持学习的东西，才是最宝贵的。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"坚持零碎的输出其实也挺重要的","slug":"坚持零碎的输出其实也挺重要的","date":"2019-01-07T15:12:40.000Z","updated":"2019-01-08T13:10:39.679Z","comments":true,"path":"2019/01/07/jian-chi-ling-sui-de-shu-chu-qi-shi-ye-ting-chong-yao-de/","link":"","permalink":"http://roseduan.github.io/2019/01/07/jian-chi-ling-sui-de-shu-chu-qi-shi-ye-ting-chong-yao-de/","excerpt":"","text":"1. 写作这件事，说来还真挺不简单，一是需要长期坚持写下去，能够有持续性的输出，最忌讳的是三天打鱼两天晒网，这样效果很不好，我深有体会，因为这样的状态我经历过。二是需要有输入才行，无论是碎片化的阅读还是系统化的学习，都要求我们不能够中断，并且需要独立思考，把学习到的东西转换为自己的知识，由此可见，写作好像就是一种由内向外的活动罢了。 有时候，我经常会看到，一些在网上很活跃的大V总是很勤奋的输出内容，无论是什么领域，大多能够侃侃而谈，主动输出自己的价值观，尚且不评好坏，单论这种态度其实就挺令人佩服的。能够做到这样，一方面肯定离不开平时的学习积累，另一方面，零碎的输出其实也挺重要。 2. 先说说我自己，有时候在写文章的时候会遇到一个最大的问题就是，不知道该写什么，或者是脑子里有一些零星的想法，却难以用文字系统性的表达出来，这常常是最困扰我的一大因素。看着别的人整天写作灵感源源不断，文章推送频繁，其实我心里挺着急的。只不过光着急也没用，得分析原因啊！以前看到一个比较厉害的人，总是喜欢在自己常浏览的地方发送一些观点，对时事的看法等等，并且几乎每天都在坚持，很少有间断。他说的一句话令我印象深刻：“输出也是一种学习，而学习是不能够间断的”。于是，我也开始分析自己的一些问题了。 3. 我比较喜欢逛知乎，简书，微信公众号，鉴于职业原因，Github，CSDN也没少看。最近我发现其实在这些平台上面我很少发言或是自己写文章，大多是浏览别人的内容，觉得的好的会点个赞收藏一下。而评论一下，或是自己写比较系统的观点表述，几乎没有。我记得我注册知乎和简书已经很长一段时间了，应该超过一年了吧，但是在这上面的输出却几乎为零，实在惭愧。有人觉得，我在上面获取到自己想要的知识就好了，能够对自己有帮助就好了，哪里管的上去做别的呀。嗯，这当然没错，但是如果你想让自己成为一个有一定影响力的人，而不仅仅是看客的话，输出就肯定是必不可少的了。 但是在早期，很容易会觉得自己是一个比较菜的人，看着别人分享的东西，感觉很牛逼，根本比不上。从而总是沦为旁观者，然后时间一直推移，自己也没有什么输出，当然也谈不上提高了，由此陷入到了一种恶性循环中。以前我也是这样觉得的，羞于发言，或是发言之后石沉大海，这都很打击一个人的自信心。但是回想起来，每一个很厉害的人不都是这样过来的么，刚开始总是很弱小，慢慢的坚持输出，然后有一点影响力，后来像滚雪球一般越来越大。其中最重要的是什么？坚持输出啊！虽然有点心灵鸡汤，但想来也确实是这个理，很多的人，连一点小事情都坚持不下去，这样摧毁的不仅是自己的行动力，更可怕的是，我们会慢慢变得麻木。 4. 我在知乎等平台上面看到的一些内容，有的的确是自己无法对其表述观点的，但是没关系，能够学习到一点也不错。但是，有的东西其实我自己还是稍微有那么一点发言权的，只是懒得做罢了。其实每个人都有自己比较擅长或是感兴趣的领域，而在这些领域，只要我们稍微用点心，多学学多思考，总结出一些自己的观点看法还是挺容易的。 还有，较为碎片化的学习，例如我在浏览一些文章的时候，很多时候总是一目十行的带过，很少能够自己思考文中的内容，然后对其发表看法，相信大多数人都是这样的。其实相应的零碎的输出方式很多，比如发表朋友圈，评论某篇文章，写写日记，等等。说这么多，并不是因为我做得有多么好，恰恰相反，就是因为做得太差了，所以想提醒一下自己。 5. 其实写文章，就是一种思考或是总结活动，你针对某件事情或是某个人发表自己的看法，突然想到某个观点然后加以佐证，随之整理成文章，这是一种思考活动；你搜集各种资源，然后整理归纳，这算是一种总结活动。而输出，不管是零碎的，还是系统成文的，最大的好处就是：逼着我们去思考，比如文中这个观点我是否赞同，文中说到的这件事情我是持信服态度还是怀疑态度，文中的想法是否对我有帮助……所以，长期来看，坚持输出给我们带来的帮助并不仅仅是扩大影响力、学习到知识或是写出好文章，更重要的是，它在锻炼我们的独立思考能力。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"我们是怎样被大学上了的？","slug":"我们是怎样被大学上了的","date":"2019-01-04T11:22:55.000Z","updated":"2019-01-04T12:37:25.751Z","comments":true,"path":"2019/01/04/wo-men-shi-zen-yang-bei-da-xue-shang-liao-de/","link":"","permalink":"http://roseduan.github.io/2019/01/04/wo-men-shi-zen-yang-bei-da-xue-shang-liao-de/","excerpt":"","text":"1. 还记得三年前的那个金秋九月，你刚走进大学校园的时候，就被周围的热闹景象吸引了，热情的学长学姐接过你的行李箱，带你走进宿舍楼。你为一路上的校园美景所陶醉，蓝天白云，时不时滑过脸庞的微风，高耸的图书馆，肃然的教学楼，至今仍历历在目。 2. 大学第一年，你接触到了很多新的课程，其中有的你很喜欢，有的你不喜欢。周围是全新的环境，新的老师，新的同学，新的教室，于是，每一堂课，你都不会缺席。但是你学习成绩又一般，说不上太好，也谈不上太差，几乎没有挂科，所以没啥心气把成绩再往上提一提。你家境并不殷实，父母都在外打工，你总是跟奖学金无缘，所以只能申请助学金聊以自慰。 你几乎不去图书馆，一下课就会回到寝室，呆坐在椅子上或躺在床上，刷刷手机上的新闻，QQ空间动态，微信朋友圈。然后看看一些搞笑的视频，或者是一些新出的电影电视剧。周末的时候，你一般会睡到中午才醒来，然后吃个饭，下午一恍惚很快就过去了。 你根据自己的兴趣参与了一些社团学生会，跟其他人在一起，你总是很沉默，一直都是听别人讲。偶尔你会去看看学校举办的篮球赛，歌唱比赛，但你总是旁观者，为别人喝彩的同时，心里却有一些失落。你会幻想自己也是一个篮球高手，或是唱歌很好听，然后赢得很多人的青睐。 3. 大学第二年，第三年。周围的一切你都已经很熟悉了，每天的生活好像都差不多，起床，上课，吃饭，玩手机电脑，睡觉。有时候你会看到某些厉害的人，心里很震惊，同时也暗下决心要努力一把，那一刻，你觉得自己很厉害，很励志，斗志昂然。可是，事情没坚持几天，你就有点撑不住了，注意力分散，然后想想，还是算了吧。于是，每一天，你好像都在重复昨天的生活。 你偶尔会想到自己毕业之后该做什么呢，自己好像没啥特长，也没有什么特别喜欢的事情，究竟该考研还是直接工作，你心里没什么打算。你心存侥幸，万一毕业的时候能找到一个好工作呢，万一我考研时运气不错，成绩很好呢。总之，离毕业还远 ，你总是想，到时候再说吧。 放暑假的时候，你会很无聊，没事喜欢逛逛qq空间，微信朋友圈。偶尔会看到一个同学晒出自己在某个地方旅行的照片，阳光明媚，风景秀丽，惹得你很羡慕。同时也在幻想着自己周游世界的美妙，也暗下决心想要存钱，以后也来一次旅行。可是，新学期到来的时候，一切幻想又烟消云散了，你又重复着那些索然无味的日子。 4. 大学第四年，你发现身边的同学都好像变得很忙碌了。他们有的成天待在图书馆，早出晚归，为了考研而努力。有的在到处搜集招聘信息，参加招聘会和面试，为了找到心仪的工作而疲于奔命。而你，却不知道自己该干嘛，学校的课程也基本上结束了，随之而来的是外出实习。 你懒得做简历，因为发现自己没什么可以写上去的经历，所以你选择了一家很一般的公司，面试很水，去了就能过。你又没有其他的选择，所以只能收拾行囊开始自己的第一次工作经历。 工作很无趣，并且很累，你打心底里不喜欢，却也没有心气尝试去找另一份工作，想想还是将就一下算了。工作之余，你偶尔会在心里抱怨，为什么自己的专业只能做这样的工作呢，真是个垃圾学校，垃圾专业。你很不甘心，但无奈自己也没有什么能力找到更好的工作，于是，你不得不重复那苟延残喘的生活。 实习结束了，你回到学校，课程已经所剩无几，最重要的事情便是毕业论文了，日子还是和以前那样不紧不慢的过着。偶尔导师会在群里催促你完成毕业论文，这时候你才想起这事，然后在网上寻找一些现成的东西，东拼西凑，总算过了导师这关。到了大学最后一个学期，完成了毕业答辩，办好了离校手续的时候，你突然发现，自己的大学生活就要结束了。纵然心中有万般不舍，你还是要收拾自己的行李，最后再去吃一顿食堂的饭菜，喝一杯最喜欢的奶茶，逛一下最熟悉的校园，在最熟悉的床上睡最后一晚。 5. 你不知道自己的下一站在哪里，没有什么想要做的工作，父母打电话问你的打算，你总是支支吾吾，他们叫你回去，你又丢不下这面子，婉言拒绝。你不得不找一份工作，但是自己又没有什么突出的能力，所以工作很一般，工资远远不如自己所想象的那样，面对毕业之后的生存压力，你总是感慨，却又无可奈何。身边的同学，他们有的你和你一样迷茫不知所措；有的考上了理想的大学，去读研究生；有的找到了心仪的工作，激动的向人生的下一站出发；有的虽然大学打了四年的游戏，但是家里有钱，父母早就安排好了工作。 终于，你还是拖着行李箱走出待了四年的大学校园，走到门口，你总是忍不住停下脚步。回头望去，蓝天白云还在，微风还有，图书馆，教学楼，它们还是在那里矗立着；同学们总是脚步匆匆，有的脸上挂着笑容，有的神情严肃，这一切都还在，熟悉又陌生。只是你，却不得不和自己的大学和青春说再见。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"说说2018年的这些事","slug":"说说2018年的这些事","date":"2019-01-01T08:21:08.000Z","updated":"2019-01-01T11:12:12.450Z","comments":true,"path":"2019/01/01/shuo-shuo-2018-nian-de-zhe-xie-shi/","link":"","permalink":"http://roseduan.github.io/2019/01/01/shuo-shuo-2018-nian-de-zhe-xie-shi/","excerpt":"","text":"1. 先说说大环境吧。 2018 年，注定是不平凡的一年，有太多的事情一次又一次出现在我们的视野之中，金立进入了破产清算；锤子科技遭遇生存危机，老罗卸任；ofo举步维艰，退押金风波一时兴起；摩拜被美团收购；百度外卖被饿了么收购；公司裁员潮兴起；小米等公司扎堆上市；拼多多崛起；抖音短视频火遍大江南北。 有人说，2018 年，是过去十年最坏的一年，也是未来 10 年最好的一年。 还有，让我印象深刻的，电影《我不是药神》堪称年度最佳，让我感觉到大环境应该变好了，某些敏感的题材能够真实的呈现在大众面前，却还是有暴走漫画被全网封杀的无奈。 2. 说回到自己， 2018 年，对我是一个节点。我基本算是告别了校园时代，走入了职场，过去一段时间的学习算是有了个结果，有很多不足的地方，导致和一些机遇擦肩而过。但是我没有太多的时间来感伤， 现在处于我的职业生涯初期，应该更加努力学习技术，弥补过去的缺陷。未来的几年，对技术人的要求会越来越高，职场的竞争会越来越大，唯有时刻秉持学习的心态，才能在新时代立足。至于以后的路怎么走，我还没有想清楚，反正技术会先做几年，积累一定的工作经验和人脉，对行业有了清楚的认识之后，再去考虑自己的职业应该怎么发展。 3. 这一年，我看了一些书，但是数量相较于前两面少了很多，主要还是参加招聘花费了太多的时间和精力吧。数了一下，刚好 10 本，只不过每本书都是好书。其中特别推荐《围城》、《刀锋》和《挪威的森林》。 也买了很多书，其中技术方面的居多，同时，我也对知识付费有了新的认识，明白学习并不一定要靠书本，于是我花了一些钱买了付费专栏，认识了很多厉害的人，这也激励我不断继续学习下去。估计这一年，对于投资自己的力度，会更大的。 4. 这一年，全程看完了世界杯，本想看着偶像 C罗 能够走得更远，却失望的看着葡萄牙被淘汰出局。也是在这个夏天，我留起了长发，想彻底改变一下自己的造型，以前喜欢模仿 C罗 的发型，现在想尝试一下贝克汉姆的骚气长发。 5. 这一年，也有一些遗憾，那就是英语的学习基本没顾得上了，自从大二下学期考完了英语六级之后，就没有系统的学习过英语了。以后估计时间很少，基本上都是在上班了，但是英语也不能落下，争取把一些零碎的时间利用起来。 6. 这一年，在公众号写了大概 30 篇原创文章，更新周期并不稳定，文章质量也尚待提高。但是写作这件事情真不能一蹴而就，需要长时间的积累，以后会更加频繁的输出内容。也很感谢现在公众号 200 位种子用户的陪伴。挑选了一些我认为还不错的文章： 7. 对于新的一年，不想立太多的 flag，2018 到 2019，仅仅是日历上的年份变了，很多人对新鲜事物总是抱有期待感，但是日子还是得一天一天，一分一秒的过，改变也需要慢慢来。假如定了很多不切实际的目标，到年末没有完成的话，只能徒生伤感。还不如把每一天过好，到年末再来回顾，发现自己已经做了这么多事情了。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"和女朋友的一周年","slug":"和女朋友的一周年","date":"2019-01-01T05:02:32.000Z","updated":"2019-01-01T08:43:17.779Z","comments":true,"path":"2019/01/01/he-nu-peng-you-de-yi-zhou-nian/","link":"","permalink":"http://roseduan.github.io/2019/01/01/he-nu-peng-you-de-yi-zhou-nian/","excerpt":"","text":"1. 话说，今天，2019年1月1日，我和女朋友在一起刚好一年了。去年这个时候，我花了三天时间将她追到手，从约出来见面到吃个饭聊个天到确定关系，整个过程毫不拖泥带水，一气呵成，鉴于我的主动，这个追求过程带着点死皮赖脸加坑蒙拐骗，但最后还是达到了目的，不甚欣慰。但是现在想想，那个时候自己实在是太冲动了，甚至有点蠢，三天就能完全的了解一个人么？显然是很困难的。假如在一起之后发现完全不适合，那岂不是对自己不负责，也对别人不负责了，唉，年轻人还是很难抑制住内心的感情冲动啊，这点需要反思。只不过很幸运，在一起之后我们还算风平浪静，爱情的小船没有翻，并且坚持到了现在，这是唯一让我不责怪自己的理由了。 话说回来，想起某些个经典比如说，泰坦尼克号上，Jack 和 Rose 从相识到相爱也没见过几次；《罗马假日》中，赫本饰演的公主和那位记者只在一起短短 24 小时，也造就了一段经典的爱情，想到这，我突然觉得自己的泡妞技术还是很菜的。要是我当时没有那么的冲动和坚持，那我们肯定是成不了男女朋友的，因为她当时并不喜欢我，甚至有点讨厌我，这点我很清楚。但是我这个人很执着，只要是我喜欢的，我就要想尽办法弄到手，不管采取什么手段，把这样的想法用在感情上，利弊参半，稍不小心就会对别人造成伤害，但刚好，我遇到的是她，所以一切就好像很自然了。 2. 简单描述一下女朋友，属于娇小可爱，撒娇卖萌型。记得很清楚是有一次，我给她讲 C 语言， 我问：scanf(“%d”, &amp;a) 中的 &amp; 是什么意思？ 答：嗯………不知道，老师叫我们加上的。 我问：如果不加行不行呢？ 答：不行。 我问：如果我不加也行的话，怎么办呢？ 答：怎么可能，你不加的话，你……你……你就是坏蛋。 从她口中冒出的词，细细想来总是觉得很有趣，譬如”我要吃面面“，”我们去打球球嘛“，”我熊熊不臭，你才臭“…… 挺会照顾人，对于我来说是福音吧，因为男生总是不太喜欢照顾自己，有些事情很随便。但是她总会在乎一些生活小细节，时不时的给我涂点宝宝霜，防止冬天手太难看；我口腔长泡的时候，她会买点药水；我一个人几乎不吃水果，但是她非要逼我买水果；还会时不时的给我买什么毛衣啊，围巾啊之类的，要知道我平时几乎不买穿的，因为我觉得这些不是太重要，除非衣服裤子穿得不能穿了了，鞋子烂了，袜子破洞了，也不知道仅仅我是这样还是大多数男生都这样。仔细想想，她所关注的细节，恰好是我所缺少的。 在一起这么久，终于发现，女人是很神奇的，因为她们总是缺少一件好看的衣服，一支漂亮的口红，甚至一个喜欢的包包，怎么买也不嫌多。 架没少吵，冷战也时不时会有，甚至也曾走到过分手的边缘，但总是有一方会妥协，慢慢的又和好，继续走下去。 我会时不时的吐槽她看的一些电视剧，太无脑太傻逼，她总是会跟我抬杠，说我是傻逼。后来我给她推荐了一些电视剧和书，她还是会看的。她也总是吐槽我，成绩不好挂科啊，没收拾啊，不爱干净啊，办事情拖沓啊…………现在想想，假如我很完美，把任何事情都做得很好，让她没有吐槽的余地，好像也不是太好吧，所谓合适，好像也就是这么回事。 一年的时间，其实不算短，经历了这么多，给我最大的感觉就是我能够很成熟的对待感情了，让我更加有血有肉，更加具有温情的一面，开心的时候会笑，不开心的时候会忍不住哭，这在以前，是不可能的。 3. 很不幸的是，我即将毕业离校，她还要在学校待两年，以后见面的时间会很少，异地恋不可避免。我觉得这很正常，一段感情总是会经历很多，包括时间和距离的考验，而这，是对两个人和一份感情的洗礼，挺过去了，会更好，挺不过去，只能吞下分离的苦果。 从我个人的角度来说，我并不完美，毛病很多，比如说有的时候很花心，会想着别的女人，但是我足够坦诚，什么想法都会很容易的和她说出来。对她，我只说心里的大实话，骗人的假话是爱情的致命毒药。我不喜欢立一些海誓山盟，什么生生世世我只爱你一个人之类的，估计好多男生说出来自己也不信吧，但是女生好像就挺喜欢听这样的话。真心，往往需要通过行动来表示。 我觉得我是理性的，头脑发热的时期已经过去了，我知道什么该做什么不该做，面对爱我的人和我爱的人，唯有努力不负其期望，让自己变得更好，才能更好的去爱别人。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"地铁上的乞讨者","slug":"地铁上的乞讨者","date":"2019-01-01T04:24:23.000Z","updated":"2019-01-01T04:28:44.012Z","comments":true,"path":"2019/01/01/di-tie-shang-de-qi-tao-zhe/","link":"","permalink":"http://roseduan.github.io/2019/01/01/di-tie-shang-de-qi-tao-zhe/","excerpt":"","text":"1. 一件小事，却引发了我一些思考。 前不久，我在地铁上的时候，正在玩自己的手机。突然迎面走来一个女生，年龄不大，20岁左右，穿着一件红色的外套，手里拿着一个小本本给我看，上面写了很多名字，还有金额数量，大部分都是20，估计这是她一天的成果吧。她还向我打着手势，原来她是一个聋哑人，我明白她站在我面前是为什么了。我没有犹豫，从兜里拿出钱包掏出20块钱递给她，她还让我在小本本上写上我的名字，我示意算了不写了，她还向我伸出了大拇指。然后她走了，挨个向其他地铁乘客做同样的请求。 当时我还挺开心，觉得自己做了一件好事，也得到了别人的认可。 2. 谁知，没过两天，又是在地铁上，我又遇到了一个向我行同样乞求的人，让我惊讶的是，这次这个人，和上次遇到的那个女生穿着几乎一样，同样是那件红色的外套，还有同样的小本本。这一次，我犹豫了，也不知道为什么，就是不知道该不该给他钱。在我犹豫的几秒钟内，他离去了，转向其他人。 当时我就觉得很惊讶，难道地铁上面的这些人都是组队乞讨么，在我经常坐的两趟地铁有这样的人，那么其他地铁线肯定也有，加之地铁人流量大，每个人平均大概捐款 20，只要一天有一二十个人捐款，那一天的收入就是三四百的样子，那月入岂不是过万了？ 3. 故事还没完，碰巧的是，今天乘坐地铁的时候，我又再次遇上了一个乞讨的人。是个年轻的男生，拿着个残疾证，估计是个聋哑人，穿着便装，手上的小本本和以前的那些人是一样的，只不过装备稍有“升级”，微信和支付宝的二维码也拿上了。然后在我的手边蹭，这次我的态度很坚决，不给！原因其实很简单，假如他真的是聋哑人的话，对于这种遭遇，我只能哀其不幸，但是根据我的观察，他身体还不错，其他方面没问题，随便找个工作养活自己完全能行，再说他是一个男人，年轻的小伙子，如果仅仅因为某些身体障碍，就靠博取别人的同情来赚钱的话，我只能怒其不争。 当然那只是当时一时的想法，现在想来，其实我也不知道该怎么做，心理也比较的沉重。给钱的话，一方面我也没啥钱，要是我很有钱的话，随随便便给点当然没什么。不给钱的话，感觉自己背负了很大的心理负担，总觉得自己做了什么亏心事一样。面对这种的情况，诸位也可以想想，自己应该怎么做呢。 4. 类似乞讨者这样的社会弱势群体，应该分为两类。一是假装的，伪造各种残疾证、悲惨经历之类的，博取别人的同情心，对于这种人我是比较鄙视的。一方面，自己明明有能力靠正当的工作来养活自己，却偏偏要采取这种对自己不负责的方式，将生计维系在别人的同情心之上。另一方面，面对这种情况，像我这样的普通大众，其实很难分辨对方究竟是不是真的弱势群体，于是，无论是给钱还是不给钱，心里总会觉得不太舒服。 第二类，不可否认的是，我们的社会当中肯定存在真正的弱势群体。于是乎，像我们普通大众，肯定只能先把自己的生活过好了，让自己至少有一点经济基础，然后再力所能及的帮助一些人，努力让自己成为一个对社会有用的人，穷则独善其身，达则兼济天下。 但是，个体的力量始终是弱小的，杯水车薪。大多数的社会弱势群体，其实还是需要我们的国家出力来帮助照料。一个国家是否强大，真的不是看这个国家GDP增速多少，GDP排名多高，修了多少高铁动车，互联网发展多快，奥运会拿了多少金牌，因为这些，跟穷苦的社会弱势群体没有太大的关系。一个国家是否真的强大，就看它的社会弱势群体是怎样被对待的。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"数据结构与算法——堆和堆排序","slug":"数据结构与算法——堆和堆排序","date":"2018-12-23T12:57:48.000Z","updated":"2018-12-24T13:50:55.807Z","comments":true,"path":"2018/12/23/shu-ju-jie-gou-yu-suan-fa-dui-he-dui-pai-xu/","link":"","permalink":"http://roseduan.github.io/2018/12/23/shu-ju-jie-gou-yu-suan-fa-dui-he-dui-pai-xu/","excerpt":"","text":"1.什么是堆 堆（Heap），其实是一种特殊的二叉树，主要满足了二叉树的两个条件：1. 堆是一种完全二叉树，还记得完全二叉树的定义吗？叶节点都在最底下两层，最后一层的节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种树叫做完全二叉树。2. 堆中的每个节点的值都必须大于等于（或者小于等于）其左右子节点的值。 对于堆中的每个节点都大于等于其左右子节点的值，叫做大顶堆，反之，则叫做小顶堆。看看下面的图就能懂了。 图片1 其中，1 是大顶堆，2 是小顶堆，3 不是堆。 2.堆是如何存储的 其实，堆可以按照完全二叉树的存储方式来储存，因为完全二叉树是比较省空间的，所以我们可以直接用数组来存储，然后按照数组下标来取出堆中数据。参照下图，来看看堆的存储： 图片2 其中位置为 i 的左子节点是 2 i + 1，右子节点是 2 i + 2，父节点是 (i - 1) / 2。 3.堆的几种操作 明白了堆是怎样储存的，我们在来看看堆最常见的两个操作：往堆中插入元素和删除堆顶元素。 首先，如果要往堆中插入一个元素，我们先将其插入到数组中最后一个位置，然后与其父节点的值进行比较，如果大于父节点，则交换位置，继续比较。看看下面的图你就明白了： 图片3 交换操作的代码，我也放到这里： 接下来看看第二种操作：删除堆顶元素。根据堆的定义，堆顶元素其实就是堆的最大或最小元素。删除堆顶元素，我们只需要移除数组中的第 0 个元素，然后再进行堆化，让堆继续保持顺序。那该怎么进行堆化呢？首先我们直接将堆中的最后一个元素移到堆顶，然后与其左右子节点的值进行比较，找到较大的那么子节点，交换位置，然后继续比较，你可以结合代码来理解一下： 4.堆排序 现在来看看里用堆这种数据结构是怎么实现排序功能的。堆排序的时间复杂度非常的稳定，是O(nlogn)，并且是原地排序算法，具体是怎么实现的呢？我们一般把堆排序分为两个步骤：建堆和排序。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"堆和堆排序","slug":"堆和堆排序","permalink":"http://roseduan.github.io/tags/堆和堆排序/"}]},{"title":"Java学习笔记4——集合","slug":"Java学习笔记4——集合","date":"2018-12-11T10:46:26.000Z","updated":"2018-12-16T12:39:59.295Z","comments":true,"path":"2018/12/11/java-xue-xi-bi-ji-4-ji-he/","link":"","permalink":"http://roseduan.github.io/2018/12/11/java-xue-xi-bi-ji-4-ji-he/","excerpt":"","text":"1.对于标准集合中的任何集合，都可以使用foreach循环，遍历整个集合。 1.队列 1.双端队列：在队列的头部和尾部都可以添加、删除元素，但是不能在队列中间添加元素。 2.循环数组队列：ArrayDeque；链表队列：LinkedList；它们都实现了Queue接口，并且都实现了双端队列。 3.优先级队列;PriorityQueue，可以按任意位置插入元素，却总是按照排序的顺序进行检索。并不是遍历的时候进行排序，而是删除的时候，总会删除最小的元素。 4.优先级队列使用了一种优雅且高效的数据结构，称为堆。堆是一种可以自我调整的二叉树。 2.链表 1.在Java中，所有的链表实际上都是双向链表。 2.LinkedList类的listIterator方法返回了一个实现了ListIterator接口的迭代器对象。 ListIterator&lt;String&gt; lter = staff.listIterator(); 这个iterator不仅有指向下一个元素的next，还有指向前面的元素的previous；nextIndex方法返回下一次调用next方法时返回元素的整数索引，previousIndex方法返回下一次调用previous方法时返回的整数索引。 3.所以可以使用ListIterator从前后两个方向遍历链表中的元素，并且可以添加、删除元素。 3.散列集 1.在Java中，散列表使用链表数组实现的，每个列表称为桶，要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。 2.HashSet的实现基于散列表的集，元素是无序不重复的。 3.TreeSet与HashSet类似，唯一的不同在于，TreeSet是一个有序的集，可以以任意顺序插入元素，在对集合进行遍历时，元素自动的按照顺序呈现。底层使用的排序算法是使用红黑树实现的。 4.将元素添加到树中要比添加到散列表中慢，但是与将元素添加到数组或链表的正确位置相比还是更快，并且树集能够自动的将元素排序。 5.TreeSet将如何进行元素之间的比较：1.要求比较的对象必须实现Comparable接口，覆盖compareTo方法；2.写一个比较器，实现Comparator接口。覆盖compareTo方法。 4.映射表 1.映射表用来储存键值对，如果提供了键，就可以找到对应的值。Java为映射表提供了两个通用的实现：HashMap和TreeMap，HashMap对键进行散列，TreeMap用键的整体顺序对元素进行排序。 2.Map的键必须是唯一的，不能对同一个键存放两个值，如果对同一个键两次调用put方法，第二个值就会取代第一个值。 3.Map有三个视图：键集keySet、值集合values、键值对entrySet。 5.专用集与映射表类 Java1.4新增了两个类，LinkedHashMap和LinkedHashSet，可以记住插入元素的顺序。当元素插入到散列表中时，就会并入到双向链表中，保证数据是有序的。 6.工具类方法 1.数组转换为集合：Arrays的静态方法asList将返回一个包装了普通 Java 数组的 List 包装器。 集合转换为数组：例如一个 String 数组，转换成List，不能简单的使用 toArray() 方法，因为这样会出现类型转换的错误，可以使用集合的 toArray(new String[size]) 这种形式，指定转换之后的类型。 2.从 Java5.0 开始，asList方法将声明为一个具有可变数量参数的方法。List&lt;String&gt; list = Arrays.asList(&quot;Amy&quot;,&quot;Bon&quot;,&quot;Cral&quot;); 3.Collections 的 nCopies 方法将创建一个包含 n 个的 List：List&lt;String&gt; list = Collections.nCopies(100, &quot;default&quot;); 4.subList 方法可以获得列表的子范围：List&lt;String&gt; sub = strs.subList(10,20);，这表示从中取出10-19个元素，包含第一个下标，不包含第二个下标。跟 String 类的 subString 方法一样。 5.Collections 类中的 sort 方法可以对实现了 List 接口的集合进行排序。 如果想按照降序对列表进行排序，可以使用 Collections.reverseOrder() ，这个方法将返回一个比较器。例如：Collections.sort(list, Collections.reverseOrder());。 这种排序使用的是归并排序算法 6.Collections.shuffle() 的功能与排序相反，即随机的混排列表中的元素。 7.Collections 的 binarySearch 实现了二分查找算法，集合必须是有序的。只有采用随机访问（例如数组），二分查找才有意义。如果必须使用迭代方式一次次的遍历链表的一半元素来找到中间位置的元素，二分查找就失去了优势。因此，如果为二分查找提供一个链表，它将自动的变为线性查找。 8.Collections 类的一些其他的方法：min、max、copy、reverse。 7.遗留的集合 Hashtable、Vector、Stack（Vector 的子类）。","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://roseduan.github.io/categories/Java基础知识/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://roseduan.github.io/tags/Java基础/"}]},{"title":"数据结构与算法——二分查找","slug":"数据结构与算法——二分查找","date":"2018-12-11T07:28:31.000Z","updated":"2018-12-12T08:55:24.131Z","comments":true,"path":"2018/12/11/shu-ju-jie-gou-yu-suan-fa-er-fen-cha-zhao/","link":"","permalink":"http://roseduan.github.io/2018/12/11/shu-ju-jie-gou-yu-suan-fa-er-fen-cha-zhao/","excerpt":"","text":"1.二分查找的实现二分查找的思路其实比较的简单，在生活当中的应用也十分的广泛：在一个有序的数据集合中，我们要查找一个数据，就直接取数据集中间位置的数据，将它和我们要查找的数据进行对比，如果大于目标值，则在较小的那个区间继续查找，如果小于目标值，则在较大的那个区间继续查找。 例如我们要在一个有序的集合里[1，3，5，6，7，8，10]，查找5这个值，那么二分查找的过程就如下图所示，经过三次查找操作就能够找到。 二分查找的时间复杂度是O(logn)，是一种非常高效的查找算法，即便是要查找的数据范围非常的大，例如232（大约等于42亿），也能够在很短的时间内找到，最多只需要32次就能找到。 二分查找的思路类似于分治思想，所以代码可以通过递归来完成，也可以用循环来实现。 public class BinarySearch { //找到指定的数据的话，返回其下标，未找到则返回-1 //======================1.使用循环实现========================= public static int binarySearchByCycle(int[] data, int value) { int low = 0; int high = data.length - 1; while (low &lt;= high) { int mid = low + ((high - low) >> 1);//相当于mid = (low + high) / 2 if (data[mid] == value) return mid; else if (data[mid] &lt; value) low = mid + 1; else high = mid - 1; } return -1; } //========================2.使用递归实现========================= public static int binarySearchByRecursion(int[] data, int value) { return searchInternally(data, 0, data.length - 1, value); } private static int searchInternally(int[] data, int low, int high, int value) { if(low > high) return -1; int mid = low + ((high - low) >> 1); if(data[mid] == value) return mid; else if(data[mid] &lt; value) return searchInternally(data, mid + 1, high, value); else return searchInternally(data, low, mid - 1, value); } } 2.二分查找的局限性二分查找实际上是存在很大的局限性的，首先，它必须要求数据存储在顺序表这种结构之上，就像数组，可以支持按下标访问元素。如果是链表这种结构的话，不支持随机访问元素，只能遍历查找，这样应用二分查找的话时间复杂度就会很高了。 其次，数据必须是有序的，假如数据是无序的话，我们就要对其进行排序，前面说到，一般采用的排序算法时间复杂度至少是O(nlogn)。所以，如果对频繁进行插入和删除的数据进行查找的话，维护有序的成本就会比较高。 最后，二分查找不适用于数据规模太小的情况，例如只有10个、20个数据等，直接使用遍历查找即可。数据量较大时才能体现出二分查找的优势。 3.变形的二分查找问题上面实现的二分查找算法是不是不难？其实那是针对的最简单的一种二分查找，数据是有序、并且无重复的，但是，如果是针对一些变形的二分查找，实现起来就没那么简单了。接下来看看几种常见的二分查找的变形问题。 1.查找第一个值等于给定值 假如有一个数组data[1,3,5,5,5,7,8,10,12]，现在我们要找第一个等于5的值，该怎么实现呢？假如用上面实现的普通二分查找，取中间值data[4]=5，刚好等于要查找的值5，所以程序就返回下标4。但是很明显不正确，因为我们要找的是第一个5，下标为2，那应该怎么实现呢？先来看看代码吧： 可以看到，当data[mid]大于或者小于value的时候，和普通的二分查找不变，更新high或者low的值。但是，当data[mid] == value的时候，我们需要进行判断，第一种情况：如果mid等于0，表示这是数组的第一个元素，那肯定是我们要找的了，所以返回mid；第二种情况：如果data[mid]前面一个元素不等于value，那么data[mid]肯定就是第一个等于value的值了，所以返回mid。 2.查找最后一个值等于给定值 这个问题和上面的问题其实很相似，我这里直接给出代码，你结合看看就能够理解了： //查找最后一个值等于给定值 public static int findLastTarget(int[] data, int value) { int length = data.length; int low = 0; int high = length - 1; while(low &lt;= high) { int mid = low + ((high - low) >> 1); if(data[mid] > value) high = mid - 1; else if(data[mid] &lt; value) low = mid + 1; else { if(mid == length - 1 || data[mid + 1] != value) return mid; else low = mid + 1; } } return -1; } 重点就在于data[mid] == value的时候的判断，假如mid是数组的最后一个元素，或者mid前面那个元素不等于valaue，那么mid就是我们要查找的值下标。 3.查找第一个大于等于给定值 例如一个数组data[1,3,5,5,5,8,8,8,10,12]，我们要查找第一个大于等于7的值，就是下标为5的值8，应该怎么做呢？实际上实现的思路和上面的两种问题类似，代码其实还更简洁： 当data[mid]小于value的时候，正常更新low的值；当data[mid]大于等于value的时候，需要进行判断，如果mid是数组的第一个值，那么肯定就是要找的了，如果mid前面的那个值小于value，说明mid这个值就是第一个大于等于value的值，所以直接返回。否则的话，就更新high的值。 4.查找最后一个小于等于给定值 有了上面三种变形问题，其实这就很简单了，我直接给出代码，你可以结合理解一下： //查找最后一个小于等于给定值 public static int findLastSmallerThanTarget(int[] data, int value) { int length = data.length; int low = 0; int high = length - 1; while(low &lt;= high) { int mid = low + ((high - low) >> 1); if(data[mid] > value) high = mid - 1; else { if(mid == length - 1 || data[mid + 1] > value) return mid; else low = mid + 1; } } return -1; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://roseduan.github.io/tags/二分查找/"}]},{"title":"Java学习笔记3——异常和泛型","slug":"Java学习笔记3——异常和泛型","date":"2018-12-09T10:59:57.000Z","updated":"2018-12-11T10:49:35.191Z","comments":true,"path":"2018/12/09/java-xue-xi-bi-ji-3-yi-chang-he-fan-xing/","link":"","permalink":"http://roseduan.github.io/2018/12/09/java-xue-xi-bi-ji-3-yi-chang-he-fan-xing/","excerpt":"","text":"一、异常 1.异常分类 所有的异常都是由Throwable继承而来的，分为Error和Exception。 error表示Java运行时系统的内部错误和资源耗尽的错误，不能抛出这种类型的对象。 exception分为RuntimeException和其他异常：由程序错误导致的异常属于RuntimeException；而程序本身没有问题，但由于像I/O这样的问题导致的异常属于其他异常。 如果出现RuntimeException，那么就一定是你的问题，这是一条很有道理的规则。 2.声明异常 1.Java语言规范将派生于Error类和RuntimeException类的所有异常叫做“未检查异常”，所有的其他异常叫做“已检查异常” 2.在方法首部声明可能抛出的异常（throws Exception），抛出的必须是已检查异常。 3.如果在子类中覆盖了父类的一个方法，子类方法中声明的已检查异常不能比父类方法中声明的异常更通用。也就是说，子类中的方法可以抛出一个更特定的异常，或者不抛出异常。 4.如何抛出一个异常？ 找到一个合适的异常类 创建这个类的对象 将对象抛出，throw new Exception(); 5.自定义异常：应该继承Exception或其子类。 3.捕获异常 1.遇到错误，会跳过try中的剩余内容，执行catch中的内容。 2.假设利用return语句从try语句中退出，在方法返回前，finally子句的内容将执行。如果finally子句中也有一个return语句，这个返回值将会覆盖原始的返回值。 3.使用异常机制的技巧： 异常处理不能代替简单的测试 不要过分的细化异常 利用异常层次结构。例如不要只抛出RuntimeExcption，而应该寻找更合适的子类，或者自己创建异常类。 二、泛型 1.为什么要使用泛型 1.泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。 2.在泛型出现之前，Java使用的继承来解决这个问题，但是会遇到类型转换的问题。泛型提供了一种类型参数的方案，可以让程序的可读性更好。 3.泛型程序设计的三个级别：1.仅仅使用泛型，不关心它们的工作方式和原因。2.系统的学习Java泛型。3.实现自己的泛型类与泛型方法。 2.定义泛型 class Pair&lt;T>{ private T first; private T second; public Pair() { this.first = null; this.second = null; } public Pair(T first, T second) { this.first = first; this.second = second; } public T getFirst() { return first; } public void setFirst(T first) { this.first = first; } public T getSecond() { return second; } public void setSecond(T second) { this.second = second; } } 2.定义泛型方法：public static&lt;T&gt; T getMax(){}，表示这是一个泛型方法，T表示返回值类型。 3.类型变量的限定：public static&lt;T extends Comparable&gt; T getMax(){}，这里表示只能接收实现了Comparable接口的类。 一个类型变量可以有多个限定，例如：T extends Comparable &amp; Serializable。 3.泛型约束 1.不能使用基本类型实例化参数类型，例如不能这样使用：Pair&lt;double&gt;，而应该使用包装类：Pair&lt;Double&gt;。原因：类型擦除之后，Pair中只包含Object，而Object不能存储double值。 2.不能创建参数化类型的数组，例如Pair&lt;String&gt;[] table = new Pair&lt;&gt;[10];//error 3.不能使用像new T[], new T(), T.class这样的表达式。 4.如果泛型方法返回一个T[]数组，可以使用反射来构建T[]数组：T[] mm = (T[]) Array.newInstance(a.getClass.getComponentType(), 2);，例如下面这个方法： public static&lt;T extends Comparable> T[] minmax(T[] arr) { if (arr == null || arr.length == 0) return null; T min = arr[0]; T max = arr[0]; for (int i = 0; i &lt; arr.length; i++) { if (min.compareTo(arr[i]) > 0) min = arr[i]; if (max.compareTo(arr[i]) &lt; 0) max = arr[i]; } T[] result = (T[])Array.newInstance(arr.getClass().getComponentType(), 2); result[0] = min; result[1] = max; return result; } 5.不能在静态域或方法中引用类型变量。private static T id; //error 4.通配符类型 1.通配符类型Pair&lt;? extends Employee&gt;，表示任何泛型Pair，它的参数类型必须是Employee的子类，例如：Pair&lt;Manager&gt;，而不能是 Pair&lt;String&gt;。实际上，Pair和Pair都是Pair&lt;? extendx Employee&gt;的子类型。 带有这种类型的泛型，可以对其子类型对象进行get，但不能set，例如： Manager m1 = new Manager(23,\"Jack\",3400); Manager m2 = new Manager(25,\"Oak\",3600); Pair&lt;Manager> managerPair = new Pair&lt;>(m1,m2); Pair&lt;? extends Employee> employeePair = managerPair; employeePair.setFirst(new Manager(232,\"Rose\",4300)); //error Employee first = employeePair.getFirst(); //ok 2.Pair&lt;? super Manager&gt;表示参数类型是Manager的超类。 带有这种类型的泛型，可以对其类型对象进行set，但不能get（会返回一个Object对象，但不能强制转换成其父类）。","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://roseduan.github.io/categories/Java基础知识/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://roseduan.github.io/tags/Java基础/"}]},{"title":"数据结构与算法——排序（四）","slug":"数据结构与算法——排序（四）","date":"2018-12-09T06:38:29.000Z","updated":"2018-12-12T08:55:50.608Z","comments":true,"path":"2018/12/09/shu-ju-jie-gou-yu-suan-fa-pai-xu-si/","link":"","permalink":"http://roseduan.github.io/2018/12/09/shu-ju-jie-gou-yu-suan-fa-pai-xu-si/","excerpt":"","text":"1.回顾前面已经说了几种基于元素比较的排序，其中归并和快速排序的应用稍多，今天就来讨论几种线性排序，这几种排序对数据的要求比较的高，但是如果能够应用起来的话，将会非常的高效，时间复杂度都能达到O(n)的程度。 2.桶排序桶排序的思路很简单，将一定范围的数据按照其大小，分别放在有序的桶内，然后桶内分别排序，然后再取出来，数据就全部有序了。例如我们要排序一组大小在1-50的订单金额，可以像下图这样做： 桶排序的时间复杂度可以达到O(n)，但是它对数据的要求十分的苛刻，首先数据在每个子范围必须是差不多的，不能出现有些桶的数据非常的多，而有些桶的数据又十分的少的情况。在极端情况下，假如全部的数据都在一个桶内的话，时间复杂度会退化为O(nlogn)了。 这里我模仿了一个桶排序，要排序的数据的范围在0-999之间，然后用链表初始化10个桶，每个桶存储的数据范围为：[0-99]、[100-199]、[200-299]、……、[900-999]。代码如下： public class BucketSort { //模拟一个桶排序，data中的数据在0-1000之间 public static void bucketSort(int[] data) { int index = 0; //使用链表模拟桶，新建10个桶 ArrayList&lt;LinkedList&lt;Integer>> buckets = new ArrayList&lt;>(); //初始化桶 for(int i = 0; i &lt; 10; i ++) { buckets.add(new LinkedList&lt;>()); } //扫描数据，将其放入桶内 for(int i = 0; i &lt; data.length; i ++) { int bucketNum = data[i] / 100; buckets.get(bucketNum).add(data[i]); } //将桶内的数据进行排序 for(int i = 0; i &lt; 10; i ++) { //使用Collections.sort()方法将桶内数据排序 Collections.sort(buckets.get(i)); //排序之后，将数据拷贝到data中 for(int j = 0; j &lt; buckets.get(i).size(); j ++) { data[index ++] = buckets.get(i).get(j); } } } public static void main(String[] args) { // TODO Auto-generated method stub Random random = new Random(); int[] data = new int[1000]; for(int i = 0; i &lt; 1000; i ++) { data[i] = random.nextInt(1000); } System.out.println(\"排序之前：\" + Arrays.toString(data)); BucketSort.bucketSort(data); System.out.println(\"排序之后：\" + Arrays.toString(data)); } } 3.计数排序计数排序其实是桶排序的一种特殊情况，假如要排序的数据的范围并不大，最大值是n，那么我们可以初始化n个桶，每个桶内存放数值相同的数据，这样就省去了桶内排序这一步骤。然后按照桶的大小依次取出数据，数据就是有序的了。 例如，需要给10万人按照年龄排序，应该怎么做呢？使用计数排序就能够很有效的解决，我们可以假设，10万人中，年龄最小的是1，年龄最大的是120，那么我们可以初始化120个桶，将年龄相同的放如到一个桶中，这样数据整体就有序了。 这里我模拟了一个计数排序：假如要给班上的100个人按照成绩进行排序，成绩最大值是10，最小值是0，那么可以用11个桶，每个桶的下标表示成绩即0-10。 public class CountingSort { //假设有100个考生，分数在0-10之间 public static void countingSort(int[] data) { int index = 0; //新建11个桶，每个桶内保存相同的分数 //使用链表模拟桶，新建11个桶 ArrayList&lt;LinkedList&lt;Integer>> buckets = new ArrayList&lt;>(); //初始化桶 for(int i = 0; i &lt; 11; i ++) { buckets.add(new LinkedList&lt;>()); } //将数据放入到桶中 for(int i = 0; i &lt; data.length; i ++) { buckets.get(data[i]).add(data[i]); } //将数据取出来 for(int i = 0; i &lt; 11; i ++) { for(int j = 0; j &lt; buckets.get(i).size(); j ++) { data[index ++] = buckets.get(i).get(j); } } } public static void main(String[] args) { // TODO Auto-generated method stub //100个考生，分数在0-10之间 int[] data = new int[100]; for (int i = 0; i &lt; data.length; i++) { data[i] = (int) (Math.random() * 11); } System.out.println(Arrays.toString(data)); CountingSort.countingSort(data); System.out.println(Arrays.toString(data)); } } 其实可以发现，计数排序和桶排序在代码上的区别就是：计数排序没有桶内排序这一环节。其他都是类似的。 4.基数排序首先思考一个问题，假如要对10万个手机号码进行排序，应该怎么做呢？手机号码有11位，显然不太适合上面的两种桶排序和计数排序，还记得前面说到的稳定排序吗？我们可以借助稳定的排序，从手机号码的最后一位开始比较，最后按照第一位排序，因为是稳定的，后面位数的号码不会被打乱，排完之后，整个手机号码就有序了。 我是用几个简单的数组来实现这个排序的过程：","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://roseduan.github.io/tags/排序/"}]},{"title":"秋招以4个offer结束","slug":"秋招以4个offer结束","date":"2018-12-07T12:03:16.000Z","updated":"2018-12-07T13:02:59.157Z","comments":true,"path":"2018/12/07/qiu-zhao-yi-4-ge-offer-jie-shu/","link":"","permalink":"http://roseduan.github.io/2018/12/07/qiu-zhao-yi-4-ge-offer-jie-shu/","excerpt":"","text":"1.我的秋招终于结束了，从十月份开始，到现在差不多两个月的时间，收获算不上多么的丰富，成果算不上多么骄傲，但是自己已经尽了力了，问心无愧。 2.其实可以以11月为一个节点 ，11月之前，学校还在上课，参加招聘心态比较的放松，因为那时候总感觉自己离社会人还远呢，离工作也还远，没什么紧迫感。运气还算好，跌跌撞撞拿到了一个上海公司的offer，这是第一个。到了十一月初，大家都走了，室友都去了永辉超市实习，搞得我也想去。因为那时候我还没找到实习，但是学院又在催，交什么实习材料，让我很紧张。所以我打算去永辉超市磨练一下自己，一来应付学院，二来还可以赚点钱，感觉还是不错的。 理想很丰满，但是，在永辉超市干了两天，我就待不下去了。因为实在是很无聊，干的事情不多，整天就站在那里，也不能玩手机，让我感觉度日如年。如果有很多事情做，我可能是不会走的，但是在当时那种情况下，我甚至都没考虑，直接给店长说我不干了。 3.出来之后，开始专心的找工作了，而且是能够实习的那种。现在看来，我想从那个时候开始才是对我真正的考验吧，因为我感受到实实在在的压力了。刚开始，非常的艰难，去面试了很多家公司，基本上都失败了。坐公交地铁去面试，不知道去了多少次，一来一回基本上就是一整天。有的时候会回来等待面试的结果，这个等待过程是最难熬的，有的时候很想直接打电话过去问，但是又害怕得到一个让自己失望的结果。 在11月之后的大半个月里，颗粒无收，心里没想过放弃那肯定是假的。有时候的确会想，这么折腾干嘛啊，自己回来好好学习，明年再找工作不行吗。但是我没有，傻傻的坚持下去了，并且把握住了最后的机会。到现在为止，拿到4个offer，两个上海的，一个外企，一个成都的，质量算不上多好，差强人意。 4.很庆幸的是自己没有放弃，更重要的是没有停止学习，没有停止提升自己的技术能力。这在无形之中帮助了我，我记得很清楚的一点就是，在一家公司没有答上来的问题，我会回来单独看一下，尽量把它做出来。后来在面试另一家的时候，他问到了类似的问题，这样我就游刃有余了。所以现在我学到一个新的知识点的时候，都会想，要是早点学到这个知识点的话，说不定我那次面试就过了啊！同时这也在潜意识里提醒我不能停止学习，特别是干软件开发这一行，就更加要有危机意识了。 奔波的这两个月里，也遇到了一些很厉害的人，其中不乏刚毕业年薪就几十万的那种。我想这种人的存在，对自己是一种激励，因为永远有人比你更强，永远不能停止前进的脚步。 5.有句话说毕业之后，才能真正的看到人与人之间的差距了。我想是这样的，无论是从事哪个行业，只要自己感兴趣，就算在毕业的时候从零开始，工作之后能够付出常人所不能达到的努力程度，也照样有机会实现逆袭。所以有能力的，没能力的，毕业之前是怎么样的，那都不重要了。社会的大门已经慢慢的向我敞开，真正的挑战和磨练也才刚刚开始，希望自己能够以低调的姿态进入职场，并且虚心的学习，永远保持初学者的姿态，提升自己的能力；能够接触更优秀的人，学习别人的长处，开拓自己的见识。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"数据结构与算法——栈与队列","slug":"数据结构与算法——栈与队列","date":"2018-12-07T06:31:11.000Z","updated":"2018-12-08T07:57:16.080Z","comments":true,"path":"2018/12/07/shu-ju-jie-gou-yu-suan-fa-zhan-yu-dui-lie/","link":"","permalink":"http://roseduan.github.io/2018/12/07/shu-ju-jie-gou-yu-suan-fa-zhan-yu-dui-lie/","excerpt":"","text":"1.栈前面说到了链表，其实常见的、简单的数据结构还有栈和队列，今天就来看看这两种数据结构。 栈其实很好理解，举个例子：办公桌上的一堆文件，后放上去的、位于最上方的，总是最先拿到的；而先放进去的，反而会被压在最后，所以总是最后才能拿到。这种满足了先进后出、后进先出的特点的数据结构，就叫做栈。 很明显，栈是一种操作受限的数据结构，插入和删除都只能在一端进行，插入操作叫做入栈，删除叫做出栈。那么怎么实现一个栈呢？有两种方式，一是利用数组来实现，这种叫做顺序栈，二是利用链表来实现，叫做链式栈。这里来看看怎么用数组来实现一个顺序栈。 /** * @ClassName ArrayStack * @Description 用数组实现顺序栈 * @Author Rose_Duan * @Date 2018/11/4 16:43 * @Version 1.0 **/ public class ArrayStack { private String[] items; private int count;//栈中元素的个数 private int n;//栈容量 //不带参的构造器，默认栈容量大小是10 public ArrayStack() { this(10); } public ArrayStack(int capacity) { this.items = new String[capacity]; this.count = 0; this.n = capacity; } //入栈操作 public boolean push(String item){ //数组容量已满，则无法插入 if (this.count == n) return false; items[count] = item; ++ this.count; return true; } //出栈操作 public String pop(){ //栈为空 if (this.count == 0) return null; String result = items[this.count - 1]; -- count; return result; } } 接下来看看时间复杂度：结合代码不难想到，不管是入栈还是出栈，都是在栈一端进行的惭怍，所以插入和删除的时间复杂度都是O(1)。链式栈的定义也比较的简单了，我这里给出了链式栈的简单的两个方法：入栈和出栈： public class LinkedListStack{ private int size; private Node top;//栈顶结点 //入栈 public void push(int value){ Node newNode = new Node(value, this.top); this.top = newNode; ++ this.size; } //出栈 public int pop(){ Node popNode = this.top; if (popNode == null) return null;//栈为空 this.top = popNode.next; if (this.size > 0) -- this.size; return popNode.getData(); } //栈中的结点定义 class Node{ private int data; private Node next; public Node(int data, Node next){ this.data = data; this.next = next; } public int getData(){ return this.data; } } } 还有的一些操作，比如求栈顶元素、遍历栈，你可以自己试着实现一下。 2.队列接下来再看看和栈很相似的另一种数据结构：队列。 队列跟我们常说的排队很类似，比如我们在食堂排队打饭，排在前面的人先打到饭，排在后面的人后打到饭，这种具有先进先出特点的数据结构就叫做队列。跟栈类似，队列的操作也是受限的，插入元素即入队列只能在队列尾部进行，取出元素即出队列只能在队列头部进行。 跟栈一样，队列也有两种实现方式，用数组实现的叫做顺序队列，用链表实现的叫做链式队列。 public class ArrayQueue { private String[] data; private int size;//队列容量 //队列头尾指针 private int head = 0; private int tail = 0; public ArrayQueue(int capacity) { this.data = new String[capacity]; this.size = capacity; } //入队列 public boolean enquque(String value) { //尾指针和容量大小相同，说明队列尾部没有空间了 if (tail == size) { if(head == 0) return false;//如果head == 0 &amp;&amp; tail == size，表示队列已满 //数据搬移 for(int i = head; i &lt; tail; i ++) { data[i - head] = data[i]; } //更新head和tail的值 head = 0; tail = tail - head; } data[tail] = value; ++ tail; return true; } //出队列 public String dequeue() { if(head == tail) return null;//如果head等于tail，表示队列为空 String result = data[head]; ++ head; return result; } } 上面是顺序队列的数组实现，可以看到，出队列的时间复杂度一直为O(1)。但是入队列的情况就有点不一样了，当队尾还有空间的时候，可直接入队列，时间复杂度还是O(1)，当队尾没有空间并且队头还有空间的时候，需要将数据搬移至队头，这时候的时间复杂度就为O(n)了。 3.循环队列普通的队列比较的简单，现在来看看队列的另一种形式：循环队列。 像上面那种普通的队列，当队列尾部没有空间的时候，我们就需要进行数据搬移，这样消耗的时间比较的多，循环队列能够很方便的解决这个问题。 如上图，当tail指针到达队列尾部的时候，我们不像普通队列那样进行数据搬移，而是直接将数据插入到0的位置，然后更新tail指针的位置。和普通队列一样，队列为空的判断条件还是head == tail，但是队列满的判断条件就不一样了，而是(tail + 1) % length = head。 你可以根据上面的图来理解，可以发现队列满的时候，其实还有一个空间没用，所以循环队列实际上会浪费一个存储空间。 public class CircularQueue { private String[] data; private int size; //队列头尾指针 private int head = 0; private int tail = 0; public CircularQueue(int capacity) { this.data = new String[capacity]; this.size = capacity; } //入队列 public boolean enqueue(String value) { if((tail + 1) % size == head) return false;//队列已满 data[tail] = value; tail = (tail + 1) % size; return true; } //出队列 public String dequeue() { if(head == tail) return null;//队列为空 String result = data[head]; head = (head + 1) % size; return result; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"栈与队列","slug":"栈与队列","permalink":"http://roseduan.github.io/tags/栈与队列/"}]},{"title":"Java学习笔记2——类、继承、接口","slug":"Java学习笔记2——对象与类","date":"2018-12-02T12:36:57.000Z","updated":"2018-12-09T10:59:14.446Z","comments":true,"path":"2018/12/02/java-xue-xi-bi-ji-2-dui-xiang-yu-lei/","link":"","permalink":"http://roseduan.github.io/2018/12/02/java-xue-xi-bi-ji-2-dui-xiang-yu-lei/","excerpt":"","text":"1.面向对象 1.类：类是构造对象的蓝图或模板，由类构造对象的过程称为创建类的实例。 2.对象的三个特性： 对象的行为 对象的状态 对象标识 3.类之间有常见的三种关系： 依赖（uses-a）：一个类的方法操纵另一个类的对象 聚合（has-a）：一个类的对象包含另一个类的对象 继承（is-a）：一个类继承另一个类 4.一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。 2.自定义类 1.在一个源文件当中，只能有一个公共类，可以有任意数目的非共有类。 2.构造器总是伴随着new操作符的执行被调用，不能用一个对象来调用构造器。 3.被定义为final的实例域，必须在构造器中对其进行初始化，在后续的操作中，不能修改。 4.静态变量和静态方法都属于类，不能对对象进行操作。静态方法可以访问自身类中的静态域。 5.有下面两种情况使用静态方法： 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供。例如Math.pow() 一个方法只需要访问类的静态域。 3.方法参数 1.按值调用表示方法接收的是调用者提供的值，按引用调用表示方法接收的是调用者提供的变量地址。 2.Java总是采用按值调用，方法不能修改传递给它的任何参数变量的内容。 3.一个方法不能修改一个基本数据类型的参数；一个方法可以改变一个对象参数的状态；一个方法不能让对象参数引用新的对象。 4.对象构造 1.如果多个方法有相同的名称、返回值类型，不同的参数，便产生了重载。 2.执行顺序：静态初始化块 &gt; 初始化块 &gt; 构造器 3.访问修饰符： public：可以被任意的类使用 private：只能被定义他们的类使用 default：同一个包中任意类可访问 protected：同一个包中和所属子类可访问 4.关键字this有两个用途：一是引用隐式参数，二是调用该类的其他构造器。 5.在Java中，只有基本类型不是对象。其余的类型，包括数组，无论是对象数组还是基本类型数组，都扩展于Object类。 5.类设计技巧 1.一定要保证数据私有性 2.一定要对数据初始化 3.不要在类中使用过多的基本类型，也就是说，可以用其他的类代替多个相关的基本类型的使用。 4.不是所有的实例域都需要setter和getter方法，视情况而定。 5.将职责过多的类进行分解。 6.类名和方法名要体现它们的意义和职责。 6.继承 1.使用super调用构造器的语句必须是子类构造器的第一条语句。 2.super关键字有两个用途：一是调用父类的方法，二是调用父类的构造器。 3.一个对象变量能够指示多种实际类型的现象称为多态，在运行期间能够自动地选择调用哪个方法的现象称为动态绑定。 4.在覆盖一个方法的时候，子类方法不能低于父类方法的可见性。 5.阻止继承：使用final修饰符。如果将一个类声明为final，只有其中的方法自动的成为final，而不包括实例域。 7.抽象类 1.为了程序的清晰性，包含一个或多个抽象方法的类本身必须被声明为抽象的。 2.除了抽象方法外，抽象类还可以包括具体数据和具体方法。 3.如果将一个类声明为抽象的，就不能创建这个类的对象。但是可以定义一个抽象类的对象变量，引用一个不是抽象的子类的对象。 4.equals方法：用于检测一个对象是否等于另外一个对象，即判断两个对象是否具有相同的引用。 8.反射 1.获取Class类对象的三种方式： 对象引用.getClass() Class.forName(“类路径”); 类名.class 2.Class对象有一个newInstance()方法，这个方法要求类必须有一个无参的构造器，因为该方法只调用无参构造器，否则会报错。 3.反射机制最重要的内容：检查类的结构。在java.lang.reflect包中有三个类Field、Method、Constructor分别描述类的实例域、方法、构造器。 4.Class类中的getFields、getMethods、getConstructors方法将返回类提供的public域、方法和构造器，其中包括父类的公有成员。而getDeclareFields这些方法将返回类中的全部域、方法和构造器，不包括父类的成员。 9.继承设计技巧 1.将公共操作和实例域放在父类当中 2.不要使用protected声明的实例域 10.接口 接口主要用来描述类具有什么功能，而不给出每个功能的具体实现 1.接口中的所有方法自动的属于public，因为不用提供关键字public。 2.接口不能含有实例域，也不能在接口中实现方法。接口中可以有变量，但都默认为是final的。接口中可以有静态的实现方法。","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://roseduan.github.io/categories/Java基础知识/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://roseduan.github.io/tags/Java基础/"}]},{"title":"数据结构与算法——链表","slug":"数据结构与算法——链表","date":"2018-12-02T07:13:41.000Z","updated":"2018-12-07T06:30:46.962Z","comments":true,"path":"2018/12/02/shu-ju-jie-gou-yu-suan-fa-lian-biao/","link":"","permalink":"http://roseduan.github.io/2018/12/02/shu-ju-jie-gou-yu-suan-fa-lian-biao/","excerpt":"","text":"1.概述链表可以说是最基础的数据结构之一了，使用也十分的广泛，今天就来说说链表这个数据结构。链表通常分为单链表、双向链表、循环链表，其中双链表是最常用的。 2.单链表首先来看看单链表，与数组相比，链表不需要连续的内存空间，它使用指针将不连续的内存块连接起来。其中的内存块我们称为链表的结点，为了将结点串联起来，每个结点还需要一个next指针，指向下一个结点的地址。下面是单链表的示意图： 可以从图中看到，链表的每个结点保存了数据data和指向下一个结点的指针next，其中有两个指针比较特殊，一个是头节点（第一个结点）的指针，它指向了头结点的地址，使用它我们可以遍历整个链表；另一个是尾结点（最后一个结点）的指针，它指向null，表示链表的结束。 单链表其实与我们常用的数组类似，都支持元素的插入、删除、查找，只不过单链表与数组的最大区别就是内存空间不连续，所以不用担心容量不足的问题。我们知道，数组的插入和删除操作十分的耗时，因为为了保证内存的连续性，必须进行大量的数据搬移工作。 但是链表却能够很高效的插入和删除元素，只需要改变指针的指向即可。 结合上面的图就不难理解了，单链表可以在O(1)时间复杂度内添加和删除元素，这比数组就更加有优势了。 但是有一个问题，要是我们查找一个元素呢？非常不幸，只能从链表的头结点开始遍历，然后找到元素，这样时间复杂度就为O(n)了。 这里我给出了单链表的查找和删除结点的代码，你可以结合代码来理解一下，然后动手写写其他的单链表操作。 public class SingleLinkedList { private Node head = null;//定义头结点 //1.根据值查找结点 public Node getNodeByValue(int value) { Node p = head; while (p != null &amp;&amp; p.getData() != value) { p = p.next; } return p; } //2.删除值等于给定值的结点 public void deleteByValue(int value) { if (head == null) return; Node p = head; Node pBefore = null;//用pBefore表示p前面一个结点 while (p != null &amp;&amp; p.getData() != value) { pBefore = p; p = p.next; } if (p == null) return;//说明没有找到结点 if(pBefore == null) head = head.next;//说明删除的结点是头结点 else pBefore.next = pBefore.next.next;//否则将pBefore的指针指向p的后一个结点，即删除p } //定义链表结点 class Node{ private int data; private Node next; public Node(int data, Node next) { this.data = data; this.next = next; } public int getData() { return data; } } } 3.循环链表循环链表其实与单链表的唯一区别就是，循环链表的尾结点指针指向了头结点，这样就形成了一个循环的结构，用来解决某些具有环形特点的问题。 4.双向链表我们重点来看一下双向链表，其实根据名字就能够猜个大概了，双向链表和单链表的区别就是：一个结点有两个指针，一个指针指向前面的结点，一个指针指向后面的结点。 不难想到，双向链表肯定会更加的占用内存空间，因为每个节点储存了两个指针，但是为什么空间消耗更大的双向链表的应用还要更多呢？其实很简单，运用前后两个指针，主要是为了查找和删除的效率更高！在单链表中，我们知道，插入和删除结点的时间复杂度都是O(1)，但是要删除一个值等于给定值的结点，结合上面单链表的delete方法，我们首先需要找到这个结点的前驱结点，然后再改变前驱结点的指针进行删除，删除的操作是O(1)，但是这个查找的过程就很耗时了，时间复杂度为O(n)。 但是在双向链表中就没有这个查找过程，因为每个节点自身保存了指向前驱结点的指针，这样就很方便的找到了前驱结点，然后在进行删除操作，整个时间复杂度是O(1)。 这里体现出来的思想，即利用更多的空间来换取时间上的更快的执行效率，就称为以空间换时间，反之就是以时间换空间。 这里我给出了双向链表的简单的插入和删除的方法，你可以参考，然后是实现其他的功能。 /** * @ClassName DoubleLinkedList * @Description 双向链表的实现 * @Author Rose_Duan * @Date 2018/12/5 16:04 * @Version 1.0 **/ public class DoubleLinkedList { private Node head = null;//链表的头结点 //查找含有某值的结点 public Node getNodeByValue(int value){ Node p = head; while (p != null &amp;&amp; p.getData() != value) p = p.next; return p; } //1.在链表末尾插入结点，常规插入 public void insert(int value){ Node node = new Node(value); if (head == null){ head = node; return; } Node p = head; while (p.next != null) p = p.next; p.next = node; node.prev = p; } //2.在结点之前插入含有某值的结点 public void insertBefore(Node p, int value){ if (head == null || p == null) return; Node node = new Node(value); if (p.prev == null){//说明是在头结点的前面插入 node.next = head; head.prev = node; head = node; } else { Node pBefore = p.prev; pBefore.next = node; node.prev = pBefore; node.next = p; p.prev = node; } } //3.删除某结点之前的结点 public void deleteBefore(Node p){ if (head == null || p == null) return; Node delete = p.prev; Node deleteBefore = delete.prev; if (deleteBefore == null){//删除的是头结点 head = p; head.prev = null; delete.next = null; } else { deleteBefore.next = delete.next; p.prev = delete.prev; } } //打印链表中的所有数据 public void printAll(){ if (head == null) System.out.println(\"链表为空\"); else { Node p = head; while (p != null){ System.out.print(p.getData() + \" \"); p = p.next; } } } //链表结点定义 class Node{ private int data; private Node prev;//前驱指针 private Node next;//后继指针 public Node(int data) { this.data = data; this.prev = null; this.next = null; } public int getData() { return data; } } public static void main(String[] args) { DoubleLinkedList linkedList = new DoubleLinkedList(); linkedList.insert(10); linkedList.insert(12); linkedList.insert(13); linkedList.insert(20); Node node = linkedList.getNodeByValue(12); linkedList.deleteBefore(node); Node head = linkedList.head; System.out.println(head.prev); System.out.println(head.getData()); linkedList.printAll(); } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://roseduan.github.io/tags/链表/"}]},{"title":"Java学习笔记1——基本程序设计结构","slug":"Java学习笔记1——基本程序设计结构","date":"2018-12-01T13:13:36.000Z","updated":"2018-12-02T12:43:16.642Z","comments":true,"path":"2018/12/01/java-xue-xi-bi-ji-1-ji-ben-cheng-xu-she-ji-jie-gou/","link":"","permalink":"http://roseduan.github.io/2018/12/01/java-xue-xi-bi-ji-1-ji-ben-cheng-xu-she-ji-jie-gou/","excerpt":"","text":"1.Java程序示例 /* 多行注释 多行注释 */ public class HelloWorld { //单行注释 public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 1.Java对大小写敏感 2.Java类的命名规范：首字母大写的名词，如果由多个单词组成，则每个单词的首字母都应该大写，称为驼峰式命名。 3.源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。 4.//表示单行注释，/**/表示多行注释 2.数据类型 1.Java共有8种基本数据类型： 整型：byte（1字节）、short（2字节）、int（4字节）、long（8字节） 浮点型：float（4字节）、double（8字节） 字符型：char（1字节） 布尔型：boolean Java的数据类型范围都是固定的，没有无符号类型的数据。 2.数字加上前缀：0b表示二进制，0表示八进制，0x表示十六进制 3.绝大部分的程序都采用double类型，float的数值后一个后缀F，没有后缀F的浮点数值则默认为double类型。 4.boolean类型有2个值：true和false，用来判断逻辑条件。整型值和布尔值之间不能相互转换。 5.数值类型之间的转换： 如果两个操作数中有一个是double，另一个就转换为double 否则，如果如果其中一个数是float，另一个数就转换为float 否则，如果其中一个数是long，另一个数转换为long 否则，两个操作数都转换为int 3.变量 1.变量名必须是一个以字母开头的由字母或数字组成的序列。 2.可以在一行中声明多个变量，例如int i, j;，但是不建议这样做，逐个声明变量有利于提高程序的可读性。 3.利用关键字final定义常量，习惯上，常量名全大写。 4.字符串 1.String类没有提供用于修改字符串的方法，所以String类型字符串是不可变的。 2.可以使用equals方法检测两个字符串是否相等。 3.要检测一个字符串既不为null也不是空串，可以使用if(str != null &amp;&amp; str.length != 0) 4.String常用方法： char charAt(int index)：返回index位置的字符 int compareTo(String other)：按照字典顺序比较字符串 String concat(String str)：拼接字符串 contains(CharSequence s)：查看字符串是否包含 boolean startWith(String prefix)和boolean endsWith(String suffix)：以什么开始或结束 boolean equals(Object obj)：判断是否相等 indexOf、lastIndexOf split subString：截取子字符串 toCharArray()：将字符串转换为字符数组 toUpperCase()、toLowerCase() trim()：去掉字符串头部和尾部的空格 5.大数值 1.如果基本的整数和浮点数精度不能够满足需求，可以使用java.math包中的大数值类型：BigDecimal和BigInteger。这两个类可以处理任意长度数字序列的数值。 2.BigInteger实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。 3，大数值类型实现算术运算必须使用方法：add、subtract、multiply、divide分别表示加、减、乘、除。 6.数组 1.数组是一种数据结构，用来储存同一种类型的值的集合。可以通过下标访问数组中每个元素的值。 2.创建一个数字数组时，所有的元素都会初始化为0，boolean数组的元素会初始化为false，对象数组的元素会初始化为null。 3.有一个更简单的方法打印数组中的所有值：Arrays.toString() 4.数组拷贝的两种方法： int[] data = {1,2,3,4,5}; int[] num = Arrays.copyOf(data, data.length * 2); int[] rose = new int[10]; System.arraycopy(data, 0, rose, 0, data.length); 5.数组排序：Arrays.sort()，此方法采用的是快速排序实现。","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://roseduan.github.io/categories/Java基础知识/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://roseduan.github.io/tags/Java基础/"}]},{"title":"数据结构与算法——排序（三）","slug":"数据结构与算法——排序（三）","date":"2018-11-30T07:06:54.000Z","updated":"2018-12-01T09:54:19.926Z","comments":true,"path":"2018/11/30/shu-ju-jie-gou-yu-suan-fa-pai-xu-san/","link":"","permalink":"http://roseduan.github.io/2018/11/30/shu-ju-jie-gou-yu-suan-fa-pai-xu-san/","excerpt":"","text":"1.回顾前面说到了三种最基本的排序算法，分别是冒泡排序、选择排序、插入排序，他们的平均时间复杂度都是O(n2)，适用于小规模数据的排序，其中插入排序的效率稍高，工作中使用得更多，我也推荐使用插入排序。今天讲到的三种排序算法的时间复杂度都是O(nlogn)，分别是希尔排序、归并排序、快速排序，其中后两者的使用非常的普遍。 2.希尔排序首先来看看希尔排序，希尔排序其实本质上也是一种插入排序，只是做了一些优化，其思路是：将排序的数组按照一定的增量将数据分组，每个分组用插入排序算法排序，然后增量逐步减小，当增量减小为1的时候，算法便终止，所以希尔排序又叫做“缩小增量排序”。 我们常取的原始增量为数据的大小/2，例如数据大小为length，我们将其分为leng / 2个组，然后length = length / 2，继续分下去，直到length = 1。文字看起来比较抽象，我画了图来帮助你理解： 下面是它的代码实现： /** * @ClassName ShellSort * @Description 希尔排序算法 * @Author roseduan * @Date 2018/11/30 22:30 * @Version 1.0 **/ public class ShellSort { public static void shellSort(int[] data) { int length = data.length; if(length &lt;= 1) return ; //定义增量 int step = length / 2; while(step >= 1) { for(int i = step; i &lt; length; i ++) { int value = data[i]; int j = i - step; for(; j >=0; j -= step) { if(value &lt; data[j]) data[j + step] = data[j]; else break; } data[j + step] = value; } //增量缩小 step = step / 2; } } } 很遗憾，希尔排序虽然时间复杂度为O(nlogn)，但它是一种不稳定的算法，因为分组的时候可能会错开相同的元素，分组进行插入排序的时候，元素的位置交换之后，稳定性就被破坏了。比起归并排序，它是不稳定的，比起快速排序，它的执行效率稍慢，所以希尔排序并没有应用得很广泛。 3.归并排序归并排序的思路是这样的：将排序的数据分为若干子数组，子数组排序之后，再进行合并，这样要排序的数组就能排好了。这种思想叫做分治，就是将一个大的问题分解成很多小问题，将小问题就解决了，大的问题也就解决了。用分治思想解决的问题，一般都可以用递归这种编程技巧来表示。 结合上面的图可以看到，假如我们要排序data[p……r]这个数组，首先我们将数组分为data[p……q]和data[q+1……r]，然后再进行合并，用公式可以这样表示： merge_sort(data[p……r]) = merge(merge_sort(data[p……q]), merge_sort(data[q+1……r])); merge函数表示将两个子数组进行合并。那么merge函数该怎么表示呢？ 思路是这样的：首先我们新建一个临时数组temp，大小和原始数组相同。然后使用两个指针i，j分别指向两个子数组的第一个元素，如果i所指元素 &lt; j所指元素，则将i所指元素插入temp，i向前移动；反之将j所指元素插入，j向前移动。以此类推，直到比较完成，然后将临时数组temp复制到原始数组中。 归并排序的代码是这样的： /** * @ClassName MergeSort * @Description 归并排序算法 * @Author Rose_Duan * @Date 2018/12/1 15:41 * @Version 1.0 **/ public class MergeSort { public static void mergeSort(int[] data, int n){ mergeInternally(data, 0, n - 1); } private static void mergeInternally(int[] data, int p, int r){ if (p >= r) return; //计算p到r的中间值q // 此等式相当于int q = (p + r) / 2，只不过下面这样写效率更高 int q = p + ((r - p) >> 1); //递归 //data[p r]分为data[p q]和data[q+1 r] mergeInternally(data, p, q); mergeInternally(data, q + 1, r); //合并 merge(data, p, q, r); } private static void merge(int[] data, int p, int q, int r){ int i = p; int j = q + 1; int k = 0; //新建一个临时数组，大小与data[p……r]一样 int[] temp = new int[r - p + 1]; while (i &lt;= q &amp;&amp; j &lt;= r){ if (data[i] &lt;= data[j]) temp[k ++] = data[i ++]; else temp[k ++] = data[j ++]; } //判断哪个子数组中有剩余的数据 //首先假设data[p....q]中有剩余的数据 int start = i; int end = q; //如果j小于等于r，则说明data[q+1...r]中有剩余的数据 if (j &lt;= r){ start = j; end = r; } //将剩余的元素拷贝到temp中 while (start &lt;= end){ temp[k ++] = data[start ++]; } //最后，将临时数组中的数据拷贝到data中 for(i = 0; i &lt;= r - p; i ++){ data[p + i] = temp[i]; } } } 归并排序并不是一种原地排序算法，因为很明显，我们申请了一个临时数组来保存数据，这个临时数组最大不会超过原始数组，所以空间复杂度为O(n)。归并排序的时间复杂度是O(nlogn)，并且是一种稳定的排序算法。 4.快速排序快速排序简称“快排”，它的思路和归并排序很类似，都是利用的分治思想。首先选取任意一个数据作为分区点，比分区点小的数据放在其左边，大的放在右边。 这样数组就分为了三个部分，一是分区点q，然后对p——q-1和q+1——r的数据分别再执行上图操作，这样整个数据就有序了。 归并排序当中有个merge合并函数，这里我们需要一个partition分区函数，主要的功能是实现上图的操作，将小于分区点的数据放在其左边，大于分区点的放在其右边，然后返回分区点。具体要怎么实现呢？这里用到的思路比较的巧妙：对于一个数组data[p….r]，我们选区最后一个元素data[r- 1]为分区点(也就是data[pivot])，然后用两个指针i，j指向第一个元素，如果data[j] &lt; data[pivot]，那么就互换i和j所指向的元素，然后i，j向前移动。如果data[j] &gt;= data[pivot]，那么不用交换位置，i不移动，j继续移动。 结合代码看一下： /** * @ClassName QuickSort * @Description 快速排序算法 * @Author Rose_Duan * @Date 2018/11/14 13:44 * @Version 1.0 **/ public class QuickSort { public static void quickSort(int[] data, int n){ quickSortInternally(data, 0, n - 1); } private static void quickSortInternally(int[] data, int p , int r){ if (p >= r) return; int q = partition(data, p, r);//获取分区点 //递归 quickSortInternally(data, p, q - 1); quickSortInternally(data, q + 1, r); } private static int partition(int[] data, int p, int r){ int pivot = data[r]; int i = p; for (int j = p; j &lt; r; j++) { if (data[j] &lt; pivot){ int temp = data[i]; data[i] = data[j]; data[j] = temp; i ++; } } int temp = data[i]; data[i] = data[r]; data[r] = temp; return i; } } 很明显，在partition分区函数中，我们交换了元素的顺序，这样值相同的元素的前后顺序可能会被打乱，你可以结合我前面对partition函数的描述在看一下，所以快速排序是不稳定的。快速排序的平均时间复杂度是O(nlogn)，并且是一种原地排序算法，空间复杂度是O(1)。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://roseduan.github.io/tags/排序算法/"}]},{"title":"中国的大学都是这样应对评估的吗？","slug":"难道中国的大学都是这样应对评估的吗？","date":"2018-11-29T13:45:38.000Z","updated":"2018-12-04T15:02:09.448Z","comments":true,"path":"2018/11/29/nan-dao-zhong-guo-de-da-xue-du-shi-zhe-yang-ying-dui-ping-gu-de-ma/","link":"","permalink":"http://roseduan.github.io/2018/11/29/nan-dao-zhong-guo-de-da-xue-du-shi-zhe-yang-ying-dui-ping-gu-de-ma/","excerpt":"","text":"1.还记得以前上初中还是高中的时候（有点记不清了），时不时的会有教育局的某某领导前来视察，首先学校的领导会肯定会提前广播通知：xxx领导将于xx天到我校来视察，请各班进行大扫除，注意卫生，规范个人行为………… 那个时候并没有想太多，全班人一起大扫除感觉也挺有乐趣的，擦窗户，扫地，拖地板，大伙都忙得不亦乐乎。有时候坐在座位上都有点胆战心惊，生怕自己的某些小动作被领导抓个正着，所以只能万事小心了。当时并不太懂，老师叫大家做什么就做什么，也没觉得有什么不妥。但后来我发现绝大多数学校都是这样来招呼前来的领导的时候，我甚至都有点鄙视当初毫无反抗之意的自己。 2.在大学待了几年，活得自由自在，就算有领导来视察，那也跟自己没有多大的关系了，所以不用像以前那样听老师的安排做些什么事情。上学期，我有好几次到学生处办公室那里办点事情，就发现楼梯那里贴了“离教学评估还有xx天”的一个倒计时板，看到它的第一眼，我倒是想起来高中教室里的高考倒计时。我心想还是不错的嘛，学校挺重视这个评估工作的嘛，只是当时并没有发现学校有什么变化，可能是领导们还在做准备吧。 3.到近些时候，走在校园里面，到处都能看见变化，地上的地板在翻新了，好多楼也在重新粉刷了，路口多了很多指路的牌子，一些工人整天忙个不停，那个帕子擦擦这，擦擦那。学校体育馆的操场几年没见动静，今年倒是花了血本，修了很长时间，整出了新模样。图书馆也新增了很多桌椅和其他的设施，这些都是在今年暑假开始弄的，现在我才想起来这样做是为了什么。 4.前几天我去学校图书馆，一进去就被惊呆了，借书的人排起了很长的队伍，而且每个人手中都拿了好几本书。我就很纳闷了，在学校呆了三年多，对图书馆非常的熟悉，大一还在图书馆兼职负责借还书，没来没有见过有这么多人借书的情形。后来打听明白了，原来是每个班都强制要求大家来借书，整体提高图书馆的书籍借阅情况，当然目的还是一个，让领导高兴嘛。“今年我校学生平均借阅书籍xx本，较去年提高了xx，表明我校学生…………”，皆大欢喜的结果。 我还偶然看到了一个同学的发言，虽然不知道他是否是在遵守图书馆座位规定的情况下说出这样的话，如果是的话，那他说的话就值得思考了，并且我也很欣慰，至少内心有反抗思想的人还是有的。 5.类似的情况比比皆是，比如让同学们背诵评估手册，方便领导抽查。评估口号好像是这样的：以评促建，以评促改，以评促管，评建结合，重在建设。这口号是真的好，真是辛苦学校的官员些根据学校的实际情况，构思出这么有正能量，麻痹自己，麻痹同学们的口号。以评促建，不知道你早干嘛去了，非要等到评估来的时候你才建设，其中我想重点说说学校的某个学院，学院办公室外面的装饰真是太漂亮了，我敢说全中国的大学很少能找到把办公室装饰得这么浮夸的。比较讽刺的是，学院logo下面还写着学校的校训“严谨、朴实、勤奋、创新”，不知道这个学院是对朴实有了新的理解，还是在坚持的走创新之路。 6.其实我一直在想，整个学校全体动员，是否向每一位学生传递了这样的价值观：既然学校可以为了评估而临时抱佛脚，那么学生可以为了期末考试而临时抱佛脚，评估可能过了，考试也可能过了，得到一个皆大欢喜的结果，但是学校和我们真的变得更好了吗？ 我在这个学校待了三年，从来没有抱怨过，环境也好，身边的人也好。因为它至少给了我一个平台，哺育我大学四年，我心中还是怀有感恩之情的，想写点东西，并不是针对，因为这也改变不了什么，只是心里过不去。 其实也不知道教育部评估组的某些傻逼怎么想的，干嘛一定要把到校评估的时间确定呢，然后学校像备战高考一样忙得不亦乐乎。你可以提前一点，来个突袭啊，这不是更能看到真实的情况吗？ 7.不管怎么样，学校总归是在建设的，从另一个方面来说，对每一位同学还是有好处的。对于那些已经离校的人，以后回到学校，看到这样的变化，可能会觉得欣喜，感到自豪，因为自己的母校变得更好了。但是对于一些知道情况的人，知道学校是在这样的节骨眼上进行的改变，心中可能会……额，可能会像钱钟书在《围城》里面描述的那样：心中又惊喜，又佩服，又鄙夷，种种复杂情绪化作一口浓痰吐了出去。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"与stormzhang的一次线上面基","slug":"与stormzhang的一次线上面基","date":"2018-11-29T09:38:02.000Z","updated":"2018-11-29T13:01:11.808Z","comments":true,"path":"2018/11/29/yu-stormzhang-de-yi-ci-xian-shang-mian-ji/","link":"","permalink":"http://roseduan.github.io/2018/11/29/yu-stormzhang-de-yi-ci-xian-shang-mian-ji/","excerpt":"","text":"1.现在不用隐瞒了，上次我说的加入了某个星球，其实就是stormzhang的星球。为什么要这样做呢，上次这篇文章已经说到了，对于投资自己，我是不会含糊的。 上周stormzhang在斗鱼上面开了直播，这是他第一次面向球友开直播，我也没有错过这次机会，三个小时的直播，收获还是挺大的。其实我一直都挺怀疑的，因为加入星球能得到什么呢？星主会不会拿钱跑路了？但是基于自己的判断，我还是做出了自认为正确的决定。我一直认为我看人是比较准的，当我看到他的时候，我就知道我的决定应该没错，后面三个小时的交流也证实了这一点。 2.有人问他为什么戾气这么重，是因为赚了很多钱之后很骄傲了吗？他回答说不是的，现在的网络环境很复杂，网民素质参差不齐，戾气重，主要是为了规避一些喷子、杠精等等，因为价值观跟别人不同，没必要去和别人浪费时间。现在很多人在网上表现出来的样子可能和真实生活的样子完全不一样，网上要是看谁不爽了，可以骂他一句傻逼，但是在真实生活中，就算很不喜欢一个人，你也不会当着面骂别人傻逼。 其实我很能理解，当一个人有自己的规划、有自己独立的思想的时候，不会总是花时间去和一些和自己没有必要的联系的人瞎扯，比如一个人老是对你指指点点，在你公众号后台留言骂你，你能怎么办，自己的事情还多呢，哪有功夫闲扯，只能骂他一句傻逼了事。 3.后来又说了很多，大多是关于未来的趋势，其中询问区块链的人最多。他也说到了这个，主要是对区块链持悲观态度，因为区块链对社会生产、人们的生活并没有什么实质性的改变，至少现在尚未体现出来。现在区块链的火热，其实与媒体和企业的炒作有关，当然这也是一种个人预测，因为没有人能够很准确的看到未来。还有说到关于怎么样去坚持做好一些值得做的事情，比如写作、阅读等，当然这都是老生常谈了，给我留下较为深刻印象的却是另外的两点。 4.有人问到这样一个问题：他是搞嵌入式开发的，除去自身努力，怎么样才能得到更好的发展呢？stormzhang 的回答让我印象深刻，他说嵌入式、网络，这些偏硬件层次的，不会直接和用户打交道，都是在底层忙活。要想获得好的发展，就必须进入顶级大公司，得到这些公司强大的资源和平台支持，才可能有一些机会，否则是是很艰难的。而开发、产品、运营这方面的工作，或多或少都会跟用户打交道，了解用户需求，这也是现在软件开发、产品类岗位比较火爆的原因，因为产品最终总是会面向用户的。 5.还有一个问题就更加具有代表性了，有人问到，现在在学Android开发，不知道是否来得及，以及Android开发的前景怎么样。回答是这样的：现在的Android，Java其实已经趋于饱和，机会已经不大，从头开始学的确有点晚了。但是趋于饱和并不代表没有市场，只是学的人很多，有的人已经在这个行业摸爬打滚了几年，积累了经验，企业的选择多了，那么它肯定会钟情于更加有技术能力和经验的人。 的确是这样，我们常说，有时候选择比努力更重要，因为正确的选择会让你少走很多弯路，甚至让你实现弯道超车。认准一个更加有发展趋势的行业、技术领域，早做准备，当机会来临的时候，就比别人更加有优势了。 但是怎么样去看到一些可能的趋势呢？一个方法便是多关注顶级互联网科技公司的一些发展战略，因为巨头总是喜欢投资未来，抢占市场。现在的一些公司，其实对未来趋势的嗅觉更加灵敏了，因为已经经历过一波又一波的互联网浪潮，谁也不想丧失掉在未来的发展机遇。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"数据结构与算法——排序（二）","slug":"数据结构与算法——排序（二）","date":"2018-11-29T07:52:06.000Z","updated":"2018-11-29T13:47:10.414Z","comments":true,"path":"2018/11/29/shu-ju-jie-gou-yu-suan-fa-pai-xu-er/","link":"","permalink":"http://roseduan.github.io/2018/11/29/shu-ju-jie-gou-yu-suan-fa-pai-xu-er/","excerpt":"","text":"1.回顾前面说到了冒泡排序，这种算法的思路比较的简单，就是基于两个元素之间的比较，然后交换位置。冒泡排序的平均时间复杂度是O(n2)，空间复杂度是(1)，并且是稳定的排序算法。今天继续讲述另外两种排序算法：选择排序和插入排序。 2.选择排序选择排序的思路是这样的：将要排序的数组分为未排序区间和已排序区间，遍历未排序区间，找到其最小值（或者最大值），将其插入到已排序区间的末尾。依次遍历，直到将未排序区间遍历完，整个排序操作就完成了。我画了一张图来帮助你理解其原理： 相信结合这个图你就不能理解选择排序了，下面是它的代码实现： /** * @ClassName SelectionSort * @Description 选择排序算法 * @Author roseduan * @Date 2018/11/11 21:01 * @Version 1.0 **/ public class SelectionSort { public static void selectionSort(int[] data) { int length = data.length; if (length &lt;= 1) return; for(int i = 0; i &lt; length - 1; i ++) { //查找最小值 int minIndex = i; for(int j = i + 1; j &lt; length; j ++) { if (data[j] &lt; data[minIndex]) minIndex = j; } //交换位置 int temp = data[i]; data[i] = data[minIndex]; data[minIndex] = temp; } } } 综合代码分析，不难看出，选择排序的平均时间复杂度是O(n2)，是一种原地排序算法，空间复杂度是O(1)，那么它和冒泡排序一样，是稳定的排序吗？答案是否定的，选择排序是一种不稳定的排序算法。 因为选择排序每次都要在未排序区间找到最小值，并且和前面的元素交换位置，这样就破坏了稳定性。例如一个数组[3,3,1,7,2]，第一次排序的时候，找到最小值1和第一个3交换，这样两个3的位置就乱了，所以就不稳定了。 3.插入排序插入排序的思路其实和选择排序类似，都是将排序数分为已排序区间和未排序区间，插入排序的具体做法是这样的：依次遍历未排序区间，将未排序区间的数和已排序区间的数组进行比较，将其插入到合适的位置上，保证已排序区间一直都是有序的，遍历完成排序则完成。 结合下面的图来理解一下： 是不是很简单呢？你可以思考一下它的代码实现，然后在参考我下面的代码实现： /** * @ClassName InsertionSort * @Description 插入排序算法 * @Author roseduan * @Date 2018/11/25 20:11 * @Version 1.0 **/ public class InsertionSort { public static void insertionSort(int[] data) { int length = data.length; if (length &lt;= 1) return; for(int i = 1; i &lt; length; i ++) { int value = data[i]; int j = i - 1; for(; j >= 0; j --) { if(data[j] > value) data[j + 1] = data[j]; else break; } data[j + 1] = value; } } } 综上分析，插入排序的平均时间复杂度是O(n2)，是一种原地排序算法，空间复杂度是O(1)，那么它是稳定的吗？我们来分析一下：结合上面的代码，只有当data[j] &gt; value的时候，才会交换两个元素的位置，所以这并不会破坏稳定性，例如一个数组[1,3,3,7,5]，5和7交换了位置之后，由于5&gt;3，所以并不会继续交换位置。所以我们可以得知：插入排序是稳定的排序算法。 4.总结好了，三种基本的排序算法都已经学完了，针对其是否稳定，时间复杂度等性质，我总结了一下： 其实这三种排序算法在实际的开发场景中用的并不多，因为时间复杂度较高，只适用于小规模的数据排序。但是你可以自己实现一下，锻炼一下自己的思维和编码能力。下一次讲讲述更常用的归并排序和快速排序。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://roseduan.github.io/tags/排序算法/"}]},{"title":"为什么我说看文档是最快捷有效的学习方式？","slug":"为什么我说看文档是最快捷有效的学习方式","date":"2018-11-27T08:32:56.000Z","updated":"2018-11-29T07:51:05.637Z","comments":true,"path":"2018/11/27/wei-shi-me-wo-shuo-kan-wen-dang-shi-zui-kuai-jie-you-xiao-de-xue-xi-fang-shi/","link":"","permalink":"http://roseduan.github.io/2018/11/27/wei-shi-me-wo-shuo-kan-wen-dang-shi-zui-kuai-jie-you-xiao-de-xue-xi-fang-shi/","excerpt":"","text":"1.以前我学习一门新技术的时候，总会有一个习惯的动作，那就是打开浏览器，百度搜索“xxx教程”，然后在众多列表里面寻找自己认为质量还不错的教程。 但是这样有一个很大的问题，那就是时间成本较高。我很难在短时间内快速的寻找到自己想要看到的内容，因为搜索出来的内容参差不齐，大部分是CSDN、博客园上面的博客，有的是简书、知乎等等乱七八糟的网站链接。在没有长时间的经验积累下，我就会一个一个挨着打开，然后浏览一遍内容，然后返回打开下一个……所以我说这样做的时间成本是很高的。 还有，在我刚入门的时候，比如学Java基础，总是喜欢看视频来学习，但是网上的视频资源太多了怎么办？那就需要花时间来寻找适合的教程，百度一搜，也是很多东西。现在看来，网上关于基础内容的一些教学视频大多讲得非常得啰嗦，经常性的聊一些无关的内容，我觉得这样太浪费时间了。 2.后来我发现，其实学习到的很多技术，比如Redis，Solr，SSM，Git等等，在其官方网站上面都会有详细的参考文档，这都是官方开发人员的总结教程，比较的权威，十分适合快速入门新的技术。还有一大优点是不用花时间去寻找，一般在官网的首页就能看到。但有一个很大的问题就是这些文档绝大部分都是英文的，并且我也不建议你直接鼠标右键然后翻译成简体中文，因为这种翻译的效果太差了。于是这样一道门槛把很多人都拦住了。 其实我也是这样的，看到长篇大论的英文，的确很头痛，索性放弃，去寻找其他的教程。但是后来我想，我非科班出身，起点本来就比别人低，要是还按照常规的套路，进步岂不是太慢了？所以我只能硬着头皮看官方英文文档了，刚开始肯定痛苦，但是经验积累多了，慢慢的就会好很多，顺便也能提高一下自己的英文水平，何乐而不为呢。 同理，对于学习一些较为系统的内容，比如编程语言Java、Python等，网上很难找到系统的文字教程。所以我推荐看书，虽然花点钱，但是效率高很多了，省去了寻找教学视频的时间和教学视频讲师瞎BB的时间。如果连一本书都没有耐心看下去的话，我也并不认为干其他的事情会有耐心。 3.但是对于刚入门的人来说，书上的有些内容的确很难理解，必须要视频讲授帮助理解。这种情况，看视频还是可以的，但是记住一点，那就是免费的视频大多是垃圾。遇到问题，需要借助搜索解决，那么我不推荐百度，因为百度出来的内容大部分质量堪忧，倒不如花点钱买个VPN上Google。记住一点，如果一个问题能够花钱这种方式来解决，那么这种方式一定是最好的。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"数据结构与算法——-排序（一）","slug":"数据结构与算法——排序（一）","date":"2018-11-25T14:20:39.000Z","updated":"2018-11-27T09:38:25.461Z","comments":true,"path":"2018/11/25/shu-ju-jie-gou-yu-suan-fa-pai-xu-yi/","link":"","permalink":"http://roseduan.github.io/2018/11/25/shu-ju-jie-gou-yu-suan-fa-pai-xu-yi/","excerpt":"","text":"1.导言因为这是排序算法系列的第一篇文章，所以多啰嗦几句。 排序是很常见的算法之一，现在很多编程语言都集成了一些排序算法，比如Java 的Arrays.sort()方法，这种方式让我们可以不在乎内部实现细节而直接调用，在实际的软件开发当中也会经常使用到。但是站在开发者的角度而言，知其然必须知其所以然。多练练排序算法，不仅能够让我们知道一些排序方法的底层实现细节，更能够锻炼我们的思维，提升编程能力。现在很多技术面试也会涉及到基本的排序算法，所以多练习是有好处的。 文中涉及到的代码都是Java实现的，但是不会涉及到太多的Java语言特性，并且我会加上详细的注释，帮助你理解代码并且转换成你熟悉的编程语言。 常见的排序算法有以下10种： 冒泡排序、选择排序、插入排序，平均时间复杂度都是O(n2) 希尔排序、归并排序、快速排序、堆排序，平均时间复杂度都是O(nlogn) 计数排序、基数排序、桶排序，平均时间复杂度都是O(n + k) 在开始具体的排序算法讲解之前，先得明白两个概念： 原地排序：指的是在排序的过程当中不会占用额外的存储空间，空间复杂度为O(1)。 排序算法的稳定性：一个稳定的排序，指的是在排序之后，相同元素的前后顺序不会被改变，反之就称为不稳定。举个例子：一个数组[3，5，1，4，9，6，6，12]有两个6（为了区分，我把一个6加上了下划线），如果排序之后是这样的：[1，3，4，5，6，6，9，12]（加下划线的6仍然在前面），就说明这是一个稳定的排序算法。 2.言归正传冒泡排序的思路其实很简单，一个数据跟它相邻的数据进行大小的比较，如果满足大小关系，就将这两个数据交换位置。一直重复这个操作，就能将数据排序。 举个例子，假如有数组a[3,5,1,4,9,6]，第一次冒泡的操作如下图所示： 重复进行这个操作，6次冒泡之后，数据排序完成。 根据这个思路，你很容易能够写出下面的代码实现冒泡排序： public class BubbleSort { //data表示整型数组，n表示数组大小 public static void bubbleSort(int[] data, int n){ //数组大小小于等于1，无须排序，返回空 if (n &lt;= 1) return; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n - i - 1; j++) { //如果data[j] > data[j + 1]，交换两个数据的位置 if (data[j] > data[j + 1]){ int temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; } } } } } 但是这个排序算法还可以进行优化，当冒泡操作已经没有数据交换的时候，说明排序已经完成，就不用在进行冒泡操作了。例如上面的例子，第一次冒泡之后，数据为[3,1,4,5,6,9]，再进行一次冒泡，数据变为[1,3,4,5,6,9]，此时已经完成了排序，就可以结束循环了。 所以针对这个数组的排序，上面的代码需要6次冒泡才能完成，其中有4次都是不需要的。所以可以对代码进行优化： public class BubbleSort { //优化后的冒泡排序 //data表示整型数组，n表示数组大小 public static void bubbleSort(int[] data, int n){ //数组大小小于等于1，无须排序，返回空 if (n &lt;= 1) return; for (int i = 0; i &lt; n; i++) { boolean flag = false;//判断是否有数据交换 for (int j = 0; j &lt; n - i - 1; j++) { //如果data[j] > data[j + 1]，交换两个数据的位置 if (data[j] > data[j + 1]){ int temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; flag = true;//表示有数据交换 } } //如果没有数据交换，则直接退出循环 if (!flag) break; } } } 好了，冒泡排序的基本思路和代码都已经实现，最后总结一下： 冒泡排序是基于数据比较的 最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n2)，平均时间复杂度是O(n2) 冒泡排序是原地排序算法，并且是稳定的。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://roseduan.github.io/tags/排序算法/"}]},{"title":"培训机构的小姐姐是如何说服你的","slug":"培训机构的小姐姐是如何说服你的","date":"2018-11-21T08:48:27.000Z","updated":"2018-11-24T09:28:39.463Z","comments":true,"path":"2018/11/21/pei-xun-ji-gou-de-xiao-jie-jie-shi-ru-he-shuo-fu-ni-de/","link":"","permalink":"http://roseduan.github.io/2018/11/21/pei-xun-ji-gou-de-xiao-jie-jie-shi-ru-he-shuo-fu-ni-de/","excerpt":"","text":"1.秋招已经接近尾声，我在成都也已经找了好多家公司面试了，但都不是很顺利。归根结底，还是自己的技术能力不够吧，在有了生存的压迫之下，自己的学习才能够有紧迫性，希望抓紧时间。但是今天我主要想说的确实另外的一件事。 2.前天到一家公司面试，说起奇怪，这家公司的地址给我的感觉跟其他的不一样，我以前面试的公司一般都是在某个写字楼，但是这家公司在一个较为低矮的房子里。我一走进去，就能看见每一层楼梯都写着“……教育，专注于培养专业技术人才……”，那一刻我就明白了，原来这公司是培训机构！ 那天还早，我又没有其他的地方可去，所以我索性就直接进去看看了。果不其然，里面有很多教室，有很多人正在上课。我跟其他的几个人在一起听了他们对公司的介绍，然后一个自称技术经理的人说要带着我们花三天时间做一个小的项目，算是对我们的一个技术检验。如果通过，就可以直接推荐去公司。 但是我下午还有其他的面试，我不打算在那里多待，就给负责人说了我下午要走。负责人说既然这样的话，那我就直接给你安排技术面试吧。我心想还不错啊，技术面试要是过了的话，就可以直接去公司了。结果，她所说的技术面试就是安排一个人给你洗脑，让你去他们的培训。 3.我很无语啊，我就这样不明所以的和她聊了一个多小时，大多数时候都是她在说。后来我总结了一下，她的套路基本上是这样的： 首先她知道，我最近在找工作，而且还不太顺利，然后她就拿出了他们的培训课程体系让我看看，我说大部分我都是学过的，但都不是很精通，有些还没学过呢。她就介绍他们的课程怎么怎么好，老师多么专业，而且他们现在还在做十二周年活动，这个月报名的话，费用会比平时少很多。但是这种套路我很熟悉了，别说这个月了，就算明年你再去报名，费用还是可以商量的。 然后她会给你说他们这里的学生的就业情况，拿到的工资基本上都是8K，9K，10K以上的，而且大部分都是非计算机专业，零基础前来培训的。她就会说，你是计算机专业的，有这方面的基础，在这里培训几个月，把自己的技术弄扎实，毕业的时候在找个好工作，完全是没问题的。 然后她会拿出他们学员跟她的微信聊天记录，基本都是就业工资的问题，让你明确她说的是没错的。她还会举几个特里来刺激你，比如某个非计算机专业的女生，学Java开发，零基础，就业工资18K，听起来实在是很诱人。她说人家一个女生都能取得这样的成就，那么一个男生就更加没有理由犹豫了。 还有的特例，比如说有个学员已经找到了工作，但是主动辞职前来培训，主要是想把自己的技术在巩固一下。所以她就给你说，就算你现在运气好，找到了一个实习的工作，但是你的压力会特别的大，这样工作下去，你的技术等各方面的能力是很难有长进的。 现在的培训机构很聪明了，都是打着招聘的幌子把你忽悠过去，然后就指出你的技术方面的问题，然后就给你洗脑。其实我心里并没有很讨厌给我稀里糊涂讲了一大堆的那位工作人员，毕竟这也是别人的工作，我得尊重一个努力对待自己工作的人，但是很可惜，她找错目标对象了。 其实我心里对培训机构并不排斥，因为这也是一条出路，不然就不会有那么多的培训机构产生了。 4.我在那里还遇到一个人，他是前来了解IT这行业的。跟他简单聊了几句，才知道他是12年毕业的，这几年没怎么工作，又没有什么一技之长，所以对未来十分的迷茫。他想从事开发方面的工作，但是又碍于各种因素而畏手畏脚，比如年纪比较大了，学习的难度可能比较高等等。在他的眼里，我看到了迷茫、不知所措和对未来的恐惧。的确，在这个竞争日益激烈的社会，自身硬实力是生存下去的根本，还有认准行业很重要，俗话说，站在趋势的风口下，猪都会飞！","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"报到贴","slug":"报到贴","date":"2018-11-19T13:40:09.000Z","updated":"2018-11-22T15:04:24.393Z","comments":true,"path":"2018/11/19/bao-dao-tie/","link":"","permalink":"http://roseduan.github.io/2018/11/19/bao-dao-tie/","excerpt":"","text":"1.说来惭愧，在去年的这个时候，我就已经想要搭建自己的博客了，并且折腾了一天，基本上完成了初步的搭建。但是我并没有使用起来，这个博客也就荒废在这里了。大概一年之后，可能是外部因素的刺激，也可能是自身的觉悟使然，让我又重新搭建起自己的博客。浪费了一年时间之后，有一种悔不当初的复杂心情，也有重新来过的轻快愉悦，在这里，我写下roseduan的个人博客的第一篇文章。 2.前段时间，我看到了公众号【码农翻身】里面的一篇文章，里面有说到写作对于一个程序员有多么的重要。具体的内容不必赘述，只想阐述其中的一点： 一个知识点学没学透彻，一个很有效的判断的方法就是你能不能够向别人讲述清楚这个知识点。很多时候，我们在学习的时候，知识在内心有个大致的概念，感觉自己弄懂了，但是要你自己表述出来，我们常常感到很困难，这就说明我们其实并没有彻底弄懂这个知识。那该怎么办，我们总不能老是拿别人来做自己的知识练习对象，‘哎哎，我今天学了数据库，我给你讲讲吧！’，刚开始别人可能还有兴趣听一听，但是长此以往没有人受得了。 所以，写作的优势就能够体现出来了。写作逼着你去思考，去总结，去想怎么把这个问题说明白。其实这就直接锻炼了我们的文字组织能力和语言表达能力。 以上，是近期直接导致我想要重新开始写博客的原因，因为这个观点戳中了我内心最真实的想法。长期以来，我接触到的这方面的东西实在不少，总是建议我们应该写作，应该坚持下去。但是碍于自己的写作意识不够和不能够更好坚持下去的缘由，我迟迟未能在这一片天地开拓出自己的空间，但现在，是时候了。 3.互联网时代的好处之一便是将一些远在天边的人和自己以某种方式相联系，让我能够从中学习到别人身上的优点，看到别人的光环，并知道别人是怎么做到这一切的。我很幸运的能够接触到一些行业内的比较厉害的人，跟我类似的也大有人在：非科班出身，自学编程，成为行业大牛，互联网大V。我从这些人身上看到了很多共同的优点，其中之一便是长期坚持写作。虽说我跟他们的差距非常的大，但这并不妨碍我在心中播下梦想的种子，因为有期待就有前进的动力。 4.我的写作经验大都是在我的公众号【roseduan】上面积累的，但是更新连续性并不是很好，经常出现较长时间的停更。而且这上面都是非技术性的文章，所以只要脑子没有打开，没有新的思考的话，就比较难长时间的更新。但是我不会放弃的，公众号与博客，将是我长期写作的地方。困难将可以预见，那就是我能不能长时间的坚持下去，还有就是初期的写作不会博得太多的关注，还有以后的时间安排问题。这些困难基本上是每个人都会遇到的，有的人中途放弃了，有的人挺下来了，这也是考验一个人最直接的方式吧。 5.我大四了，在学校已经没有课程了，仅剩的任务便是毕业论文，可以说我的大学生活基本上结束了。在不久的以后面临的便是社会的考验和职场的洗礼。对于技术人来说，初入职场需要注意些什么，需要培养哪些软技能，我已经听说了不少，无非是写作、英语、演讲、投资理财等等，却没有机会实际的感触一下。但是在大学期间从写作开始，我觉得很不错了。 ​","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]}]}