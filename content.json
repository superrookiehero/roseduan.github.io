{"meta":{"title":"roseduan","subtitle":"roseduan 写字的地方","description":"Stay hungry Stay foolish","author":"roseduan","url":"http://roseduan.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-05-05T13:23:33.000Z","updated":"2019-05-06T14:43:29.464Z","comments":true,"path":"categories/index.html","permalink":"http://roseduan.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-05-10T13:39:37.000Z","updated":"2019-05-11T09:52:36.957Z","comments":true,"path":"about/index.html","permalink":"http://roseduan.github.io/about/index.html","excerpt":"","text":"关于我 Java developer，非科班出身，大三开始自学编程。喜欢 Java、Python 语言，热爱数据结构与算法，喜欢捣鼓新的技术，时常关注圈内热点信息。 轻度强迫症，追求完美，利己主义者，极简主义者。 自信乐观，相信可以通过自身的努力让自己变得更好，成为自己想成为的人。 终身学习者，现阶段，正在疯狂弥补计算机基础方面的知识，毕竟和别人的差距太大，想要弯道超车，得看自己付出了多少。 最喜欢的一句话乔老爷子的： Stay hungry，stay foolish. 他在 2005 年的斯坦福大学的毕业演讲非常的出名，被我当作人生箴言。 我的追求很简单，做自己喜欢的事，冷静面对处理人生路上必经的那些不幸和痛苦，让自己的开心和快乐多一点，发现世界的美好。 兴趣爱好 阅读是第一爱好，大学期间看了不少书，比较喜欢文学类相关书籍，最喜欢的书籍有毛姆的《月亮与六便士》、《人生的枷锁》、《刀锋》，村上春树的《挪威的森林》，钱钟书的《围城》。 喜欢写作分享，技术类和非技术都涉及。 阅读和写作，应该是占据了我绝大部分业余时间吧。 爱运动，喜欢足球，C 罗忠粉；在学校时喜欢打网球，喜欢纳达尔。 联系我 除了本站，你还可以在这些地方找到我： Github：https://github.com/roseduan SegementFault：https://segmentfault.com/u/roseduan CSDN：https://blog.csdn.net/rose_duanm 简书：https://www.jianshu.com/u/4dfac3fb4458 知乎：https://www.zhihu.com/people/roseduan/activities 微信公众号：roseduan，欢迎扫码关注我！"},{"title":"friends","date":"2019-05-05T13:11:43.000Z","updated":"2019-05-05T13:12:57.369Z","comments":true,"path":"friends/index.html","permalink":"http://roseduan.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-05T13:23:44.000Z","updated":"2019-05-05T13:24:43.601Z","comments":true,"path":"tags/index.html","permalink":"http://roseduan.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-05T13:30:16.546Z","updated":"2019-05-05T13:30:16.546Z","comments":true,"path":"categories/Java基础知识/index.html","permalink":"http://roseduan.github.io/categories/Java基础知识/index.html","excerpt":"","text":"分类: Java基础知识 | roseduan的个人博客 roseduan的个人博客 首页 标签 分类 归档 关于 友情链接 roseduan的个人博客 Stay hungry, stay foolish. 首页 标签 分类 归档 关于 友情链接 Fork Me .nav-transparent .github-corner { display: none !important; } .github-corner { position: absolute; z-index: 10; top: 0; right: 0; border: 0; transform: scale(1.1); } .github-corner svg { color: #0f9d58; fill: #fff; height: 64px; width: 64px; } .github-corner:hover .octo-arm { animation: a 0.56s ease-in-out; } .github-corner .octo-arm { animation: none; } @keyframes a { 0%, to { transform: rotate(0); } 20%, 60% { transform: rotate(-25deg); } 40%, 80% { transform: rotate(10deg); } } 博客正在重建中………… Stay hungry, stay foolish. // Dynamically switch banner pictures every day. $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &nbsp;&nbsp;文章分类 Java基础知识 4 无事杂谈 15 数据结构与算法 8 Java学习笔记4——集合 1.对于标准集合中的任何集合，都可以使用foreach循环，遍历整个集合。 1.队列 1.双端队列：在队列的头部和尾部都可以添加、删除元素， 2018-12-11 Java基础知识 Java基础 Java学习笔记3——异常和泛型 一、异常 1.异常分类 所有的异常都是由Throwable继承而来的，分为Error和Exception。 error表示Java运行时系统 2018-12-09 Java基础知识 Java基础 Java学习笔记2——类、继承、接口 1.面向对象 1.类：类是构造对象的蓝图或模板，由类构造对象的过程称为创建类的实例。 2.对象的三个特性： 对象的行为 对象的状态 对象标 2018-12-02 Java基础知识 Java基础 Java学习笔记1——基本程序设计结构 1.Java程序示例 /* 多行注释 多行注释 */ public class HelloWorld { //单行注释 2018-12-01 Java基础知识 Java基础 本站由&copy;Blinkfox基于 Hexo 的 hexo-theme-matery主题搭建. 本站总访问量 次,&nbsp;访客数 人. &nbsp;&nbsp;搜索 searchFunc(\"/\" + \"search.xml\", 'searchInput', 'searchResult');"},{"title":"","date":"2019-05-05T13:30:16.546Z","updated":"2019-05-05T13:30:16.546Z","comments":true,"path":"categories/数据结构与算法/index.html","permalink":"http://roseduan.github.io/categories/数据结构与算法/index.html","excerpt":"","text":"分类: 数据结构与算法 | roseduan的个人博客 roseduan的个人博客 首页 标签 分类 归档 关于 友情链接 roseduan的个人博客 Stay hungry, stay foolish. 首页 标签 分类 归档 关于 友情链接 Fork Me .nav-transparent .github-corner { display: none !important; } .github-corner { position: absolute; z-index: 10; top: 0; right: 0; border: 0; transform: scale(1.1); } .github-corner svg { color: #0f9d58; fill: #fff; height: 64px; width: 64px; } .github-corner:hover .octo-arm { animation: a 0.56s ease-in-out; } .github-corner .octo-arm { animation: none; } @keyframes a { 0%, to { transform: rotate(0); } 20%, 60% { transform: rotate(-25deg); } 40%, 80% { transform: rotate(10deg); } } 博客正在重建中………… Stay hungry, stay foolish. // Dynamically switch banner pictures every day. $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &nbsp;&nbsp;文章分类 Java基础知识 4 无事杂谈 15 数据结构与算法 8 数据结构与算法——堆和堆排序 1.什么是堆 堆（Heap），其实是一种特殊的二叉树，主要满足了二叉树的两个条件：1. 堆是一种完全二叉树，还记得完全二叉树的定义吗？叶节点 2018-12-23 数据结构与算法 堆和堆排序 数据结构与算法——二分查找 1.二分查找的实现二分查找的思路其实比较的简单，在生活当中的应用也十分的广泛：在一个有序的数据集合中，我们要查找一个数据，就直接取数据集中间 2018-12-11 数据结构与算法 二分查找 数据结构与算法——排序（四） 1.回顾前面已经说了几种基于元素比较的排序，其中归并和快速排序的应用稍多，今天就来讨论几种线性排序，这几种排序对数据的要求比较的高，但是如果 2018-12-09 数据结构与算法 排序 数据结构与算法——栈与队列 1.栈前面说到了链表，其实常见的、简单的数据结构还有栈和队列，今天就来看看这两种数据结构。 栈其实很好理解，举个例子：办公桌上的一堆文件，后 2018-12-07 数据结构与算法 栈与队列 数据结构与算法——链表 1.概述链表可以说是最基础的数据结构之一了，使用也十分的广泛，今天就来说说链表这个数据结构。链表通常分为单链表、双向链表、循环链表，其中双链 2018-12-02 数据结构与算法 链表 数据结构与算法——排序（三） 1.回顾前面说到了三种最基本的排序算法，分别是冒泡排序、选择排序、插入排序，他们的平均时间复杂度都是O(n2)，适用于小规模数据的排序，其中 2018-11-30 数据结构与算法 排序算法 数据结构与算法——排序（二） 1.回顾前面说到了冒泡排序，这种算法的思路比较的简单，就是基于两个元素之间的比较，然后交换位置。冒泡排序的平均时间复杂度是O(n2)，空间复 2018-11-29 数据结构与算法 排序算法 数据结构与算法——-排序（一） 1.导言因为这是排序算法系列的第一篇文章，所以多啰嗦几句。 排序是很常见的算法之一，现在很多编程语言都集成了一些排序算法，比如Java 的A 2018-11-25 数据结构与算法 排序算法 本站由&copy;Blinkfox基于 Hexo 的 hexo-theme-matery主题搭建. 本站总访问量 次,&nbsp;访客数 人. &nbsp;&nbsp;搜索 searchFunc(\"/\" + \"search.xml\", 'searchInput', 'searchResult');"},{"title":"","date":"2019-05-05T13:30:16.556Z","updated":"2019-05-05T13:30:16.556Z","comments":true,"path":"categories/无事杂谈/index.html","permalink":"http://roseduan.github.io/categories/无事杂谈/index.html","excerpt":"","text":"分类: 无事杂谈 | roseduan的个人博客 roseduan的个人博客 首页 标签 分类 归档 关于 友情链接 roseduan的个人博客 Stay hungry, stay foolish. 首页 标签 分类 归档 关于 友情链接 Fork Me .nav-transparent .github-corner { display: none !important; } .github-corner { position: absolute; z-index: 10; top: 0; right: 0; border: 0; transform: scale(1.1); } .github-corner svg { color: #0f9d58; fill: #fff; height: 64px; width: 64px; } .github-corner:hover .octo-arm { animation: a 0.56s ease-in-out; } .github-corner .octo-arm { animation: none; } @keyframes a { 0%, to { transform: rotate(0); } 20%, 60% { transform: rotate(-25deg); } 40%, 80% { transform: rotate(10deg); } } 博客正在重建中………… Stay hungry, stay foolish. // Dynamically switch banner pictures every day. $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &nbsp;&nbsp;文章分类 Java基础知识 4 无事杂谈 15 数据结构与算法 8 职场中，能说会写是巨大的优势 1. 入职一个多月，观察到了一个很普遍的现象：一个团队的 leader 每天都花费了很多的时间在沟通上面。 从早上的团队小会议开始，说说昨 2019-01-22 无事杂谈 无事杂谈 追女孩子好难。。。 1. 一室友，周末的时候，给一个女生发微信，想要约出来看电影。结果很惨，人家一天都没回复他，到了晚上的时候才说：对不起啊，才看到消息。。。 2019-01-16 无事杂谈 无事杂谈 放寒假了，听说你又要去兼职 1. 不管是放什么假，学生朋友们都喜欢去做点兼职，暑假最频繁，寒假也不少，有的甚至平时在校期间的周末都会去做兼职，做的什么呢？大抵是送外卖 2019-01-13 无事杂谈 无事杂谈 该学点什么计算机基础好呢 1. 昨晚在知乎上面看到了一个问题：现在的程序员应该学些什么计算机基础知识，以及有哪些推荐的书呢？我想了一会，打算写一些自己知道的东西。说 2019-01-10 无事杂谈 无事杂谈 坚持零碎的输出其实也挺重要的 1. 写作这件事，说来还真挺不简单，一是需要长期坚持写下去，能够有持续性的输出，最忌讳的是三天打鱼两天晒网，这样效果很不好，我深有体会，因 2019-01-07 无事杂谈 无事杂谈 我们是怎样被大学上了的？ 1. 还记得三年前的那个金秋九月，你刚走进大学校园的时候，就被周围的热闹景象吸引了，热情的学长学姐接过你的行李箱，带你走进宿舍楼。你为一路 2019-01-04 无事杂谈 无事杂谈 说说2018年的这些事 1. 先说说大环境吧。 2018 年，注定是不平凡的一年，有太多的事情一次又一次出现在我们的视野之中，金立进入了破产清算；锤子科技遭遇生存危 2019-01-01 无事杂谈 无事杂谈 和女朋友的一周年 1. 话说，今天，2019年1月1日，我和女朋友在一起刚好一年了。去年这个时候，我花了三天时间将她追到手，从约出来见面到吃个饭聊个天到确定关 2019-01-01 无事杂谈 无事杂谈 地铁上的乞讨者 1. 一件小事，却引发了我一些思考。 前不久，我在地铁上的时候，正在玩自己的手机。突然迎面走来一个女生，年龄不大，20岁左右，穿着一件红色的 2019-01-01 无事杂谈 无事杂谈 秋招以4个offer结束 1.我的秋招终于结束了，从十月份开始，到现在差不多两个月的时间，收获算不上多么的丰富，成果算不上多么骄傲，但是自己已经尽了力了，问心无愧。 2018-12-07 无事杂谈 无事杂谈 中国的大学都是这样应对评估的吗？ 1.还记得以前上初中还是高中的时候（有点记不清了），时不时的会有教育局的某某领导前来视察，首先学校的领导会肯定会提前广播通知：xxx领导将于 2018-11-29 无事杂谈 无事杂谈 与stormzhang的一次线上面基 1.现在不用隐瞒了，上次我说的加入了某个星球，其实就是stormzhang的星球。为什么要这样做呢，上次这篇文章已经说到了，对于投资自己，我 2018-11-29 无事杂谈 无事杂谈 1 / 2 本站由&copy;Blinkfox基于 Hexo 的 hexo-theme-matery主题搭建. 本站总访问量 次,&nbsp;访客数 人. &nbsp;&nbsp;搜索 searchFunc(\"/\" + \"search.xml\", 'searchInput', 'searchResult');"},{"title":"","date":"2019-05-05T13:30:16.591Z","updated":"2019-05-05T13:30:16.591Z","comments":true,"path":"categories/无事杂谈/page/2/index.html","permalink":"http://roseduan.github.io/categories/无事杂谈/page/2/index.html","excerpt":"","text":"分类: 无事杂谈 | roseduan的个人博客 roseduan的个人博客 首页 标签 分类 归档 关于 友情链接 roseduan的个人博客 Stay hungry, stay foolish. 首页 标签 分类 归档 关于 友情链接 Fork Me .nav-transparent .github-corner { display: none !important; } .github-corner { position: absolute; z-index: 10; top: 0; right: 0; border: 0; transform: scale(1.1); } .github-corner svg { color: #0f9d58; fill: #fff; height: 64px; width: 64px; } .github-corner:hover .octo-arm { animation: a 0.56s ease-in-out; } .github-corner .octo-arm { animation: none; } @keyframes a { 0%, to { transform: rotate(0); } 20%, 60% { transform: rotate(-25deg); } 40%, 80% { transform: rotate(10deg); } } 博客正在重建中………… Stay hungry, stay foolish. // Dynamically switch banner pictures every day. $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); &nbsp;&nbsp;文章分类 Java基础知识 4 无事杂谈 15 数据结构与算法 8 为什么我说看文档是最快捷有效的学习方式？ 1.以前我学习一门新技术的时候，总会有一个习惯的动作，那就是打开浏览器，百度搜索“xxx教程”，然后在众多列表里面寻找自己认为质量还不错的教 2018-11-27 无事杂谈 无事杂谈 培训机构的小姐姐是如何说服你的 1.秋招已经接近尾声，我在成都也已经找了好多家公司面试了，但都不是很顺利。归根结底，还是自己的技术能力不够吧，在有了生存的压迫之下，自己的学 2018-11-21 无事杂谈 无事杂谈 报到贴 1.说来惭愧，在去年的这个时候，我就已经想要搭建自己的博客了，并且折腾了一天，基本上完成了初步的搭建。但是我并没有使用起来，这个博客也就荒废 2018-11-19 无事杂谈 无事杂谈 2 / 2 本站由&copy;Blinkfox基于 Hexo 的 hexo-theme-matery主题搭建. 本站总访问量 次,&nbsp;访客数 人. &nbsp;&nbsp;搜索 searchFunc(\"/\" + \"search.xml\", 'searchInput', 'searchResult');"}],"posts":[{"title":"女人是世界灵感的来源么？","slug":"女人是世界灵感的来源么？","date":"2019-05-15T13:57:44.000Z","updated":"2019-05-15T14:01:39.098Z","comments":true,"path":"2019/05/15/nu-ren-shi-shi-jie-ling-gan-de-lai-yuan-me/","link":"","permalink":"http://roseduan.github.io/2019/05/15/nu-ren-shi-shi-jie-ling-gan-de-lai-yuan-me/","excerpt":"","text":"1. 有一部电影，叫做《社交网络》，讲的是天才马克·扎克伯格的故事，我还挺喜欢的，前前后后看了几遍。欣赏完一部电影或是电视剧，我习惯在豆瓣上面看看它的短评或是影评，直到我看见了这一个短评，觉得挺有道理，于是想写点东西。 2. 剧中扎克伯格创立 Facebook 的缘由，虽然是虚构，但还是非常有意思：那是在 2003 年，扎克伯格还是个哈佛大学生，在酒吧和女友大吵了一架之后，女友提出了分手，这让扎克伯格十分的恼怒。 他飞奔回宿舍，拿起啤酒，打开电脑，在自己的博客上面发文，破口大骂自己的女友。室友在旁边无意之间提出了一个想法，说能不能把学校女生的照片找来，对比看看谁更漂亮，扎克伯格心领神会，马上开始了这个想法的实践。 他利用自己天才般的技术，攻击了学校的宿舍系统，拿到了学校女生的照片，并且使用自己好友提供的一个计算公式，很快便完成了整个网站的搭建。他和朋友用邮箱将网站链接发给了学校的人，短短两个小时，网站的请求达到了 2.2 万次，几乎使哈佛大学的校园服务器崩溃，引起了极大的轰动。 后来的事情大家都知道了，Facebook 慢慢发展壮大，成为了世界上最大的社交网站。 3. 除此之外，电影中出现了一个叫肖恩·派克的人，扎克伯格十分欣赏他，后来他也加入了 Facebook。他曾经创办过一个产品叫做 Napster，缘由是这样的：肖恩·派克在高中的时候，喜欢一个女孩，但是这个女孩和学校的曲棍球队长在一起，他想干一番大事业，把这个女孩抢过来，于是 Napster 就这样被创建起来了。这个 Napster 也挺厉害的，是一个在线的音乐共享服务，在当时甚至掀起了互联网音乐的革命。 4. 1977年，有一个斯坦福大学的 MBA 毕业生，名叫罗伊·雷蒙德，他想给自己的妻子买内衣，但是他又不能在百货商场买，因为太尴尬了。于是他从银行借了 4 万美元，又从朋友手中借了 4 万美元，在斯坦福的一个购物中心开了一家内衣店。这家店从男性的角度出发，采用复古风的装饰，墙上贴满了内衣海报供男士参考，营业员热情好客，让前来购买内衣的男士一点也不会感到尴尬。 这家店第一年就为罗伊·雷蒙德赚了 50 万美元，此后的五年，罗伊又相继开了 5 家分店，然后他将所有的内衣店连同品牌，以 500 万美元的价格一起出售了。出售仅两年后，这个内衣品牌的估值达到了 5 亿美元。 当年罗伊·雷蒙德创建的内衣品牌，叫做「维多利亚的秘密」，就是现在人们所熟知的「维密」。 5. 三个伟大的产品，创立的缘由都多少和女人有关，扎克伯格和女友分手后建立了 Facebook；肖恩·派克为了追求自己喜欢的女孩子，创建了 Napster；罗伊·雷蒙德当时只想给自己的妻子买内衣，却创建了风靡全球的内衣品牌维密。 有个名词叫做「异性效应」，指的是异性之间的接触会产生一种相互吸引力和激发力，并能够让人从中体验到难以言表的感情追求，对生活或学习产生积极的影响。常说的男女搭配，干活不累，就是这么个道理。其实与异性的接触，是人类最原始的本能，而最原始的本能，可以最大程度上激发人的创造力和灵感。 对于少数的天才，异性效应可以是影响甚至改变世界的灵感来源，Facebook、Napster、维密，只是冰山一角。对于大多数普通人，异性效应不一定能激发灵感，却也能转化为积极向上的力量。 6. 比如你喜欢的女孩子，遇到了啥问题，找你帮忙解决。你当然会放下手上的一切工作，绞尽脑汁也要想到解决办法，并且浑身都充斥着一种快乐愉悦的感觉，这个时候你可能会忘记吃饭，忘记睡觉，专注的做一件事情，创造力和灵感也能够最大限度的被激发出来。 再比如，上学时，你喜欢的某个女孩子成绩很好，但是你的成绩却很差。女孩子对你说，你要是考到全班前 5 名或是和我一样考上某个大学，我就做你的女朋友，你肯定像打了鸡血一样努力。虽说这样的情节可能出现在电视剧中较多，但是不可否认现实中也的确存在。 一个人成年后，异性效应可以来自自己的妻子，比如不能让妻子受苦受累，过上更好的生活，于是你会更加努力的工作。 不得不相信，女人，或者说异性，在某种意义上的确可以激发创造力和动力，甚至是世界灵感的来源。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}],"author":"roseduan"},{"title":"Java 并发理论基础(一)","slug":"Java-并发理论基础-一","date":"2019-05-11T09:00:16.000Z","updated":"2019-05-11T09:56:00.951Z","comments":true,"path":"2019/05/11/java-bing-fa-li-lun-ji-chu-yi/","link":"","permalink":"http://roseduan.github.io/2019/05/11/java-bing-fa-li-lun-ji-chu-yi/","excerpt":"","text":"一、并发编程的核心问题1.分工各个线程自己做自己的事情，需要分工明确。 2.同步线程之间的协作问题，例如线程之间的互相等待，线程通知另外的线程。 3.互斥互斥指的是同一时刻，只允许一个线程访问共享变量，在 Java 中，实现互斥的方案主要是锁。 二、并发 bug 的源头计算机的 CPU、内存、I/O 设备的速度一直存在较大的差异，依次是 CPU &gt; 内存 &gt; I/O 设备，为了权衡这三者的速度差异，主要提出了三种解决办法： CPU 增加了缓存，均衡和内存的速度差异 发明了进程、线程，分时复用 CPU，提高 CPU 的使用效率 编译指令优化，更好的利用缓存 三种解决办法虽然有效，但是也带来了另外的三个问题，分别就是并发 bug 产生的源头。 1.可见性问题如果是单核 CPU，多个线程操作的都是同一个 CPU 缓存，那么一个线程修改了共享变量，另一个线程肯定能马上看到。 如果是多核 CPU ，每个 CPU 都有自己的缓存，这样线程对共享变量的修改便对其他线程不可见了，类似下图这样： 2.原子性问题为什么会有线程切换？一个线程在执行的过程中，可能会进行耗时的 I/O 操作，这时线程需要等待 I/O 操作完成。线程在等待的过程中，可以释放 CPU 的使用权，让另一个线程执行，这样能够提高 CPU 的使用率。 例如上图，两个线程同时对变量 count 加 1，线程 A 在执行的过程中切换到了线程 B，最后导致写入到内存的值都是 1，与预期不符。 3.有序性问题首先看一段很经典的获取单例对象的代码： public class Singleton { private static Singleton instance; //Java 获取单例对象 public Singleton getInstance(){ if (instance == null){ synchronized (Singleton.class){ if (instance == null){ instance = new Singleton(); } } } return instance; } } 程序的逻辑是：首先判断 instance 是否为空，如果为空，对其加锁，然后再判断是否为空，此时为空的话则初始化 instance 对象。 如果线程 A 和 B 同时执行方法，在 synchronized 处，一个线程会被阻塞，假设被阻塞的是线程 B，此时线程 A 进入并初始化 instance，然后唤醒线程 B，线程 B 进入的时候，发现 instance 不为空了，所以不会创建对象。 但是因为有序性问题的存在，这段代码也不是想象的那么完美，我们期望的初始化对象的过程是这样的：1.分配内存；2.初始化对象；3.将内存地址赋给 instance。但是经过编译优化之后，却是这样的： 1.分配内存 2.将内存地址赋给 instance 3.在内存上面初始化对象 这样，如果线程 A 执行到了第二步，然后切换到 线程 B，线程 B 就会认为 instance 不为空然后直接返回了，实际上 instance 还没有初始化。 最后，总结一下，导致并发问题的三个源头 原子性：一个线程在执行的过程当中不被中断。 可见性：一个线程修改了共享变量，另一个线程能够马上看到，就叫做可见性。 有序性：编译指令重排导致的问题。 三、Java 内存模型Java 内存模型主要是为了解决并发源头的可见性和有序性问题，即按需禁用缓存和编译优化。主要提供的解决办法是：volatile、synchronized、final 这三个 Java 中的关键字，以及 happens-before 规则。 1. volatile 关键字其含义是禁用 CPU 缓存，线程需要直接从内存中读取或者写入变量，保证可见性。 2. happens-before 规则happens-before 规则的主要含义是前面的操作对后面的操作是可见的，主要有以下几项： 程序的顺序性规则：指的是在一个线程中，按照程序的顺序，前面的操作 happens-before 后续的操作。 volatile 变量规则：被 volatile 修饰的变量，其写操作 happens-before 这个变量的读操作。也就是说写操作对后续的读操作是可见的。 传递性规则：如果 A happens-before B，并且 B happens-before C，那么 A 一定 happens-before C。 管程中的锁规则：一个锁的解锁 happens-before 于这个锁的加锁操作。 线程 start() 规则：主线程 A 启动子线程 B 后，子线程 B 能够看到线程 A 在启动子线程 B 之前的操作，举个例子： public class ThreadStart { private static int count = 0; public static void main(String[] args) { Thread B = new Thread(() -> { count = 1; System.out.println(\"子线程：\" + count); }); B.start(); } } 由于 count 是在启动线程 B 之前修改的，对线程 B 可见，所以程序将会打印出 1。 线程 join() 规则：主线程 A 等待子线程 B 完成后，主线程能够看到子线程的操作。还是上面的例子，改造一下： public class ThreadStart { private static int count = 0; public static void main(String[] args) throws InterruptedException { Thread B = new Thread(() -> { count = 1; System.out.println(\"子线程：\" + count); }); B.start(); B.join(); System.out.println(\"主线程：\" + count); } } 这里调用了 B 线程的 join 方法，表示主线程等待子线程执行完毕，所以主线程能够看到 count 的修改，所以打印出 1。 线程中断规则：对线程 interrupt() 方法的调用 happens-before 被中断线程的代码检测到中断事件的发生，通过 Thread.isInterrupted() 方法检测是否有中断发生。 对象终结规则：一个对象的初始化完成（构造方法执行结束） happens-before 其 finalize() 方法的开始。 3. final 关键字这个关键字的含义是被其修饰的变量不可变，告诉编译器可以任意进行优化。 4. synchronized 关键字Java 提供的同步原语，主要是为了实现互斥锁，解决原子性问题。 四、互斥锁1. 互斥锁模型互斥锁主要是为了解决原子性问题，保证临界区在线程操作期间的中间状态不可见。互斥锁的一般模型如下： 2. synchronized 的用法synchronized 可以修饰静态方法，相当于锁定当前类的 Class 对象。 也可以修饰非静态方法，相当于锁定当前类的对象 this 。 public class Test { /** * 修饰静态方法，相当于 synchronized(Test.class) */ public synchronized static void test1(){ System.out.println(\"Test1\"); } /** * 修饰非静态方法，相当于 synchronized(this) */ public synchronized void test2(){ System.out.println(\"Test2\"); } } 一把锁可以锁定多个资源，但是不能用多把锁锁定同一个资源。 在加锁的时候，需要注意锁和锁定资源之间的关系。如果多个资源之间没有关系，可以每个资源分配一把锁，这叫做细粒度锁；如果资源之间存在关联，可以使用粒度更大的锁。 五、死锁死锁指的是一组相互竞争资源的线程互相等待，导致线程永久阻塞的情况。 1.死锁产生的条件 互斥：共享资源 A 和 B 只能被一个线程占用 占有且等待：线程占有一个资源 A 后，等待资源 B，并且不会释放资源 A 不可抢占：一个线程不能抢占其他线程占有的资源 循环等待：线程 T1 等待线程 T2 持有的资源，线程 T2 等待线程 T1 持有的资源 程序示例： public class Account { private int balance; public void transfer(Account target, int amt){ synchronized (this){ synchronized (target){ if (this.balance >= amt){ target.balance += amt; } } } } } 一个账户类中的转账操作，先对 this 加锁，然后对目标账户 target 加锁，如果线程 T1 执行 A 转 B，线程 T2 执行 B 转 A。两个线程同时执行，线程 T1 持有 A 的锁，并申请 B，线程 T2 持有 B 的锁，并申请 A，两个线程就会互相等待出现死锁。 2. 如何规避死锁问题由于死锁必须具备上面的全部四个条件，才会产生，所以，可以破坏其中一个条件，就可以避免死锁。其中第一个条件无法干预，因为使用锁的目的就是为了达到互斥的效果。 对于“占有且等待”条件，解决办法是可以一次性申请所需要的资源，例如上面的 A 和 B，这样就不会出现等待资源的情况了。仍然使用上面的程序改造作为示例： public class Account { //初始化管理资源的容器 private static Monitor monitor = new Monitor(); private int balance; public void transfer(Account target, int amt){ //一直申请全部的资源，直到成功 while (true){ if (monitor.apply(this, target)){ break; } } try { synchronized (this){ synchronized (target){ if (this.balance >= amt){ target.balance += amt; } } } } finally { //结束后，释放所有的资源 monitor.free(this, target); } } } //申请和释放资源的容器 final class Monitor{ private List&lt;Object> res = new ArrayList&lt;>(2); /** * 一次性申请资源 */ public synchronized boolean apply(Object resource1, Object resource2){ if (res.contains(resource1) || res.contains(resource2)){ return false; } else { res.add(resource1); res.add(resource2); return true; } } /** * 归还资源 */ public void free(Object resource1, Object resource2){ res.remove(resource1); res.remove(resource2); } } 对于“不可抢占”条件：如果线程无法等待到另一个线程的资源，可以主动释放自己持有的资源。synchronized 无法解决这个问题，可以使用 Java SDK 并发包中的 Lock 来实现。 对于“循环等待”条件，可以给需要申请的资源排序，按序从小到大申请并锁定资源，这样就避免了循环等待。还是使用上面的转账程序作为示例： public class Account { //账户ID，假设是有大小顺序的 private int accountId; private int balance; public void transfer(Account target, int amt){ Account small = this; Account big = target; if (this.accountId > big.accountId){ small = target; big = this; } //先锁定序号小的资源 synchronized (small){ //再锁定序号大的资源 synchronized (big){ if (this.balance >= amt){ target.balance += amt; } } } } } 在实际的生产中，需要根据实际情况，预先考虑死锁可能出现的情形，然后针对性的选择方法进行避免。","categories":[{"name":"Java并发编程实战","slug":"Java并发编程实战","permalink":"http://roseduan.github.io/categories/Java并发编程实战/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://roseduan.github.io/tags/Java并发/"}],"author":"roseduan"},{"title":"Python 学习笔记(一)——基础知识","slug":"Python-学习笔记-一-——基础知识","date":"2019-05-10T14:16:17.000Z","updated":"2019-05-10T14:23:55.190Z","comments":true,"path":"2019/05/10/python-xue-xi-bi-ji-yi-ji-chu-zhi-shi/","link":"","permalink":"http://roseduan.github.io/2019/05/10/python-xue-xi-bi-ji-yi-ji-chu-zhi-shi/","excerpt":"","text":"第一章 变量和简单数据类型 1. 变量 1.变量的命名： 只能包含数字、字母、下划线，不能以数字开头 变量名不能包含空格 变量名应该简短又具有描述性：name 比 n 好，student_name 比 s_n 好 谨慎使用字母 l 和 o，容易和数字 1 和 0 混淆 2.字符串常用函数： title()：首字母大写的显示字符串 upper()：全大写 lower()：全小写 去除空白：rstrip()、lstrip()、strip() 3.使用 + 号来拼接字符串 4.函数 str() 可以将非字符串值转换为字符串 2. 数字 1.Python 使用 ** 表示乘方运算，例如 3 ** 3 ，表示 3 的 3 次方 第二章 列表 什么是列表？Python 中的列表由一系列按特定顺序排列的元素组成，相当于 Java 中的数组。 1.访问列表元素：除了可以按照常规的下标来访问，Python 还支持负数下标，-1 表示返回列表的倒数第一个元素，-2 表示倒数第二个，-3 表示倒数第三个，以此类推。 2.往列表中添加元素： append() 方法可以追加元素至末尾 insert() 方法可以插入到具体的位置 3.删除列表元素 如果知道元素在列表中的下标，可以使用 del 删除，例如 del names[0] pop() 方法可以弹出列表最后一个元素，并且可以继续使用弹出的元素。pop 函数还可以指定元素的下标 如果不知道删除元素的下标，只知道元素的值，可以使用 remove 方法 4.排序列表中的元素：使用 sort() 方法，如果需要反序排列，则在方法中加上 reverse = True 5.临时排序，可以使用 sorted() 函数，不会影响到原有的列表，例如 sorted(names)，也可以添加 reverse = True 6.反转列表的排列顺序：reverse() 方法 7.确定列表的长度：使用函数 len() 8.循环打印列表： names=[\"Lanister\", \"Stark\", \"Byrathen\", \"Thyrell\"] for name in names : print(name) 9.函数 range() 可以创建数字列表，使用方式： for i in range(1,6): print(i) 将会打印数字 1-5 ，还可以使用函数 list() 将 range 转换为列表，例如 list(range(1, 6)) 使用函数 range 的时候，还可以指定步长，例如 range(2, 11, 2)，将会打印 10 以内的偶数 10.可以对数字列表进行处理的几个函数：max、min、sum 11.使用列表解析可以简化代码，例如 cubic = [i ** 3 for i in range(1, 11)] ，这行代码将 1-10 的立方值作为列表 cubic 的值。 12.处理切片：Python 中，将列表的部分元素称为切片。 使用下标打印列表元素： players = [\"Rose\", \"Freya\", \"Jack\", \"Bob\", \"Maria\"] # ['Rose', 'Freya', 'Jack'] print(players[0:3]) # 没有指定第一个索引，则从列表开头开始 # ['Rose', 'Freya'] print(players[:2]) # 没有指定最后一个索引，则打印至列表末尾 # ['Bob', 'Maria'] print(players[3:]) # 使用负数下标，打印最后三个数 print(players[-3:]) 13.复制列表： 复制一个列表的所有元素： players = [\"Rose\", \"Freya\", \"Jack\", \"Bob\", \"Maria\"] sub_players = players[:] # 这种方式不行 # sub_players = players 也可以结合上面的方式复制切片 元组：不可变的列表称为元组 元组的定义方式：names = (“rose”, “Jamie”)，这里使用的是圆括号，并且不能通过下标来修改元素的值。 虽然不能够修改元组的值，但是可以通过重新赋值来改变元组： dimensions = (\"kit\", \"ned\") dimensions = (\"Jack\", \"Rose\") print(dimensions) 14.判断列表中是否包含特定的值，使用关键字 in，返回布尔值 players = [\"Rose\", \"Freya\", \"Jack\", \"Bob\", \"Maria\"] print(\"Yara\" in players) 同样的，如果判断不包含，可以使用 not in 第三章 字典 在 python 中，字典表示的是一系列键-值对。字典使用大括号定义，类似于 json 格式的数据。 1.添加键值对： alien = {\"color\": \"red\", \"points\": 5} alien[\"name\"] = \"rose\" print(alien) # 打印结果： # {'color': 'red', 'points': 5, 'name': 'rose'} 2.删除字典中的键值对：使用 del 命令，例如 del alien[&quot;color&quot;] 3.遍历字典：需要使用到字典的 items() 方法 favorite_numbers = { \"Jack\": 2, \"Iring\": 3, \"Paul\": 7, \"Rose\": 10 } for k, v in favorite_numbers.items(): print(\"name = \" + k) print(\"value = \" + str(v) + \"\\n\") 遍历字典的键或者值，分别使用字典的 keys() 和 values() 方法。 可以结合前面的关键字 in 判断某个键或者值是否在字典中。 可以使用 sorted() 函数对字典的键或者值进行排序。 可以使用 list 函数将字典的键或者值转换为列表： keys = list(favorite_numbers.keys()) sorted_keys = sorted(keys) print(sorted_keys) 4.set() 函数可以将字典中的键或者值去除重复的显示出来： set_values = set(favorite_numbers.values()) print(set_values) set() 函数也可以用于列表的去重 字典和列表 1.在列表中存储字典 alien_0 = {\"color\": \"red\", \"points\": 5, \"speed\": \"slow\"} alien_1 = {\"color\": \"black\", \"points\": 3, \"speed\": \"medium\"} alien_2 = {\"color\": \"green\", \"points\": 2, \"speed\": \"slow\"} aliens = [alien_0, alien_1, alien_2] 2.在字典中存储列表： pizza = { \"crust\": \"thick\", \"toppings\": [\"mushrooms\", \"extra cheese\"] } print(\"you order a pizza named \" + pizza[\"crust\"]) print(\"The toppings are :\") for topping in pizza[\"toppings\"]: print(\"\\t\" + topping) 3.字典中存储字典： users = { \"user1\": { \"name\": \"Jack\", \"age\": 29, \"time\": \"yesterday\" }, \"user2\": { \"name\": \"Rose\", \"age\": 13, \"time\": \"just now\" } } for user, attr in users.items(): print(\"The visitors : \" + user) print(\"Basic information:\") for k, v in attr.items(): print(\"\\t\" + k + \" : \" + str(v)) 注意，如果包含非字符串类型的数据，需要使用 str() 函数将其转换。 第四章 用户输入和 while 循环 1.Python 中的 input() 函数处理用户输入，并且可以保存输入的值，进行再次使用： pro = \"Please input some info:\" pro += \"\\nYou are not a shy person, right?\\n\" message = input(pro) print(\"The info you want to say is : \" + message) input() 可以接收参数，可以当作输入的提示。 input() 会将输入的内容解析为字符串。 Python 2.7 使用 row_input() 函数进行输入，而不是 input() 函数。 2.如果输入的是数字，可以使用 int() 函数 age = int(input(\"What`s your age?\")) print(\"you age is \" + str(age)) 使用 int() 函数需要将 input() 函数嵌套在里面。 3.while 循环的基本使用方式： prompt = \"What`s you age?\" prompt += \"\\nEnter '-1' to end the program\\n\" age = int(input(prompt)) while age != -1: if age &lt; 3: print(\"The ticket is free\\n\") elif age &lt;= 12: print(\"The ticket are 10 dollars\\n\") else: print(\"The ticket are 15 dollars\\n\") age = int(input(prompt)) 和 if 条件类似，将条件表达式写在 while 关键字后面，主要不要出现死循环。 4.while 循环可以将列表作为条件表达式： users = [\"alice\", \"rose\", \"candace\", \"jack\"] while users: user = users.pop() print(\"Verifying user : \" + user) 当然需要在循环体中避免死循环，这里是使用 pop() 函数依次删除列表中的值。","categories":[{"name":"python","slug":"python","permalink":"http://roseduan.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://roseduan.github.io/tags/python/"}],"author":"roseduan"},{"title":"该学点什么计算机基础好呢","slug":"该学点什么计算机基础好呢","date":"2019-01-10T14:08:59.000Z","updated":"2019-01-10T15:23:16.041Z","comments":true,"path":"2019/01/10/gai-xue-dian-shi-me-ji-suan-ji-ji-chu-hao-ni/","link":"","permalink":"http://roseduan.github.io/2019/01/10/gai-xue-dian-shi-me-ji-suan-ji-ji-chu-hao-ni/","excerpt":"","text":"1. 昨晚在知乎上面看到了一个问题：现在的程序员应该学些什么计算机基础知识，以及有哪些推荐的书呢？我想了一会，打算写一些自己知道的东西。说来很滑稽，一个非科班出身，技术很渣，对计算机基础更是尚未入门的人，却要来谈谈计算机基础知识，也不知道是谁给我的勇气。相信读者中有比较厉害的人，要是我说的不对或是不全面，欢迎指正和补充。 2. 看到过一句话，说是在面试的时候，面试官对你基础知识的重视程度，跟公司的质量成正比。要是面试官完全不在乎你的基础，那么很有可能，你是被招去当码农使唤的。很明显，现在好多人对于计算机基础是不太重视的，可能唯一的用处就是找工作面试的时候吧，所以我看到很多人在面试前临时抱佛脚，补充基础的，当然也包括我。在面试当中，大多数情况下，越优秀的公司对计算机基础越重视，比如很多一线互联网大厂如腾讯、阿里、华为等等，在面试的时候就喜欢考算法，看面试者的逻辑思维能力和编程能力。 很多人，比如现在的我，在遇到内存，多线程，并发，TCP/IP，编译，位图，动态规划等等概念的时候，就一脸懵逼，这就是对计算机基础不了解。计算机基础，就像一栋楼的根基，想要把楼盖的高，根基必须要稳定，否则我们的技术体系框架很容易一碰就倒。 3. 前面的我提到的几个概念，分别属于不同领域的基础知识。一是计算机系统，什么内存管理、进程线程、同步异步等等都属于这方面。相应的书籍有很经典的《深入理解计算机系统》，这本书搞懂了，就基本上没问题。我买了这本书，但是，有点难，阅读起来很困难。二是计算机网络，常见的知识比如 OSI 分层，TCP/UDP 区别，DNS 解析，HTTP。这块的知识我只看过《图解TCP/IP》，理解起来还是有点困难，好像还有一本相同风格的《图解HTTP》，这两本书都不错，适合入门。其他的进阶书籍，可以选择《计算机网络：自顶向下方法》。三是数据结构与算法，这一方面在面试中很常见，什么链表、队列、栈、散列表、树、排序，对程序员都挺重要的。相应的书籍有适合入门的《大话数据结构》、《算法图解》，语言相关的可以选择经典的《数据结构与算法分析：C/C++/Java/Python 语言描述》，进阶的书籍有《算法导论》。其他的还有，比如计算机组成原理，编译原理，数据库系统，Linux，甚至数学，都算是比较基础的东西。但是人的精力有限，不可能面面俱到，可以结合自己的技术方向有选择性的学习一些。比如前端、Java、Python，可以选择学习数据结构与算法，HTTP，数据库。像 C 语言这种偏低层的，对基础的要求就会更高。 4. 学习基础知识能够对我们有什么改变？就目前我所能感知的，就是，对一些底层的东西有了了解，比如学了数据结构与算法，我知道了 Java 的集合框架，比如 Map、List、Set 底层都是用的什么数据结构来支撑，Collections.sort() 原来是用了归并排序等等，现在学习到新东西，总是会想它的底层是用什么实现的，为什么会这样做。这是对我们思维上的改变，让我们不仅仅是重复的堆砌业务代码，而是真正学会思考，提升自己的技术能力。 5. 所以，多学点总是有好处的，特别是还在学校学习的人，时间很充裕。别看到现在什么人工智能、大数据、网络爬虫、云计算多么火，然后就取跟随潮流，其实揭开它们的面纱，也就那么回事。相反，那些底层的东西，基础的知识，很少有人去看，很少有人去坚持学习的东西，才是最宝贵的。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"我们是怎样被大学上了的？","slug":"我们是怎样被大学上了的","date":"2019-01-04T11:22:55.000Z","updated":"2019-05-09T14:56:07.783Z","comments":true,"path":"2019/01/04/wo-men-shi-zen-yang-bei-da-xue-shang-liao-de/","link":"","permalink":"http://roseduan.github.io/2019/01/04/wo-men-shi-zen-yang-bei-da-xue-shang-liao-de/","excerpt":"","text":"1. 还记得三年前的那个金秋九月，你刚走进大学校园的时候，就被周围的热闹景象吸引了，热情的学长学姐接过你的行李箱，带你走进宿舍楼。你为一路上的校园美景所陶醉，蓝天白云，时不时滑过脸庞的微风，高耸的图书馆，肃然的教学楼，至今仍历历在目。 2. 大学第一年，你接触到了很多新的课程，其中有的你很喜欢，有的你不喜欢。周围是全新的环境，新的老师，新的同学，新的教室，于是，每一堂课，你都不会缺席。但是你学习成绩又一般，说不上太好，也谈不上太差，几乎没有挂科，所以没啥心气把成绩再往上提一提。你家境并不殷实，父母都在外打工，你总是跟奖学金无缘，所以只能申请助学金聊以自慰。 你几乎不去图书馆，一下课就会回到寝室，呆坐在椅子上或躺在床上，刷刷手机上的新闻，QQ空间动态，微信朋友圈。然后看看一些搞笑的视频，或者是一些新出的电影电视剧。周末的时候，你一般会睡到中午才醒来，然后吃个饭，下午一恍惚很快就过去了。 你根据自己的兴趣参与了一些社团学生会，跟其他人在一起，你总是很沉默，一直都是听别人讲。偶尔你会去看看学校举办的篮球赛，歌唱比赛，但你总是旁观者，为别人喝彩的同时，心里却有一些失落。你会幻想自己也是一个篮球高手，或是唱歌很好听，然后赢得很多人的青睐。 3. 大学第二年，第三年。周围的一切你都已经很熟悉了，每天的生活好像都差不多，起床，上课，吃饭，玩手机电脑，睡觉。有时候你会看到某些厉害的人，心里很震惊，同时也暗下决心要努力一把，那一刻，你觉得自己很厉害，很励志，斗志昂然。可是，事情没坚持几天，你就有点撑不住了，注意力分散，然后想想，还是算了吧。于是，每一天，你好像都在重复昨天的生活。 你偶尔会想到自己毕业之后该做什么呢，自己好像没啥特长，也没有什么特别喜欢的事情，究竟该考研还是直接工作，你心里没什么打算。你心存侥幸，万一毕业的时候能找到一个好工作呢，万一我考研时运气不错，成绩很好呢。总之，离毕业还远 ，你总是想，到时候再说吧。 放暑假的时候，你会很无聊，没事喜欢逛逛qq空间，微信朋友圈。偶尔会看到一个同学晒出自己在某个地方旅行的照片，阳光明媚，风景秀丽，惹得你很羡慕。同时也在幻想着自己周游世界的美妙，也暗下决心想要存钱，以后也来一次旅行。可是，新学期到来的时候，一切幻想又烟消云散了，你又重复着那些索然无味的日子。 4. 大学第四年，你发现身边的同学都好像变得很忙碌了。他们有的成天待在图书馆，早出晚归，为了考研而努力。有的在到处搜集招聘信息，参加招聘会和面试，为了找到心仪的工作而疲于奔命。而你，却不知道自己该干嘛，学校的课程也基本上结束了，随之而来的是外出实习。 你懒得做简历，因为发现自己没什么可以写上去的经历，所以你选择了一家很一般的公司，面试很水，去了就能过。你又没有其他的选择，所以只能收拾行囊开始自己的第一次工作经历。 工作很无趣，并且很累，你打心底里不喜欢，却也没有心气尝试去找另一份工作，想想还是将就一下算了。工作之余，你偶尔会在心里抱怨，为什么自己的专业只能做这样的工作呢，真是个垃圾学校，垃圾专业。你很不甘心，但无奈自己也没有什么能力找到更好的工作，于是，你不得不重复那苟延残喘的生活。 实习结束了，你回到学校，课程已经所剩无几，最重要的事情便是毕业论文了，日子还是和以前那样不紧不慢的过着。偶尔导师会在群里催促你完成毕业论文，这时候你才想起这事，然后在网上寻找一些现成的东西，东拼西凑，总算过了导师这关。到了大学最后一个学期，完成了毕业答辩，办好了离校手续的时候，你突然发现，自己的大学生活就要结束了。纵然心中有万般不舍，你还是要收拾自己的行李，最后再去吃一顿食堂的饭菜，喝一杯最喜欢的奶茶，逛一下最熟悉的校园，在最熟悉的床上睡最后一晚。 5. 你不知道自己的下一站在哪里，没有什么想要做的工作，父母打电话问你的打算，你总是支支吾吾，他们叫你回去，你又丢不下这面子，婉言拒绝。你不得不找一份工作，但是自己又没有什么突出的能力，所以工作很一般，工资远远不如自己所想象的那样，面对毕业之后的生存压力，你总是感慨，却又无可奈何。身边的同学，他们有的你和你一样迷茫不知所措；有的考上了理想的大学，去读研究生；有的找到了心仪的工作，激动的向人生的下一站出发；有的虽然大学打了四年的游戏，但是家里有钱，父母早就安排好了工作。 终于，你还是拖着行李箱走出待了四年的大学校园，走到门口，你总是忍不住停下脚步。回头望去，蓝天白云还在，微风还有，图书馆，教学楼，它们还是在那里矗立着；同学们总是脚步匆匆，有的脸上挂着笑容，有的神情严肃，这一切都还在，熟悉又陌生。只是你，却不得不和自己的大学和青春说再见。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"数据结构与算法——排序（四）","slug":"数据结构与算法——排序（四）","date":"2018-12-09T06:38:29.000Z","updated":"2018-12-12T08:55:50.608Z","comments":true,"path":"2018/12/09/shu-ju-jie-gou-yu-suan-fa-pai-xu-si/","link":"","permalink":"http://roseduan.github.io/2018/12/09/shu-ju-jie-gou-yu-suan-fa-pai-xu-si/","excerpt":"","text":"1.回顾前面已经说了几种基于元素比较的排序，其中归并和快速排序的应用稍多，今天就来讨论几种线性排序，这几种排序对数据的要求比较的高，但是如果能够应用起来的话，将会非常的高效，时间复杂度都能达到O(n)的程度。 2.桶排序桶排序的思路很简单，将一定范围的数据按照其大小，分别放在有序的桶内，然后桶内分别排序，然后再取出来，数据就全部有序了。例如我们要排序一组大小在1-50的订单金额，可以像下图这样做： 桶排序的时间复杂度可以达到O(n)，但是它对数据的要求十分的苛刻，首先数据在每个子范围必须是差不多的，不能出现有些桶的数据非常的多，而有些桶的数据又十分的少的情况。在极端情况下，假如全部的数据都在一个桶内的话，时间复杂度会退化为O(nlogn)了。 这里我模仿了一个桶排序，要排序的数据的范围在0-999之间，然后用链表初始化10个桶，每个桶存储的数据范围为：[0-99]、[100-199]、[200-299]、……、[900-999]。代码如下： public class BucketSort { //模拟一个桶排序，data中的数据在0-1000之间 public static void bucketSort(int[] data) { int index = 0; //使用链表模拟桶，新建10个桶 ArrayList&lt;LinkedList&lt;Integer>> buckets = new ArrayList&lt;>(); //初始化桶 for(int i = 0; i &lt; 10; i ++) { buckets.add(new LinkedList&lt;>()); } //扫描数据，将其放入桶内 for(int i = 0; i &lt; data.length; i ++) { int bucketNum = data[i] / 100; buckets.get(bucketNum).add(data[i]); } //将桶内的数据进行排序 for(int i = 0; i &lt; 10; i ++) { //使用Collections.sort()方法将桶内数据排序 Collections.sort(buckets.get(i)); //排序之后，将数据拷贝到data中 for(int j = 0; j &lt; buckets.get(i).size(); j ++) { data[index ++] = buckets.get(i).get(j); } } } public static void main(String[] args) { // TODO Auto-generated method stub Random random = new Random(); int[] data = new int[1000]; for(int i = 0; i &lt; 1000; i ++) { data[i] = random.nextInt(1000); } System.out.println(\"排序之前：\" + Arrays.toString(data)); BucketSort.bucketSort(data); System.out.println(\"排序之后：\" + Arrays.toString(data)); } } 3.计数排序计数排序其实是桶排序的一种特殊情况，假如要排序的数据的范围并不大，最大值是n，那么我们可以初始化n个桶，每个桶内存放数值相同的数据，这样就省去了桶内排序这一步骤。然后按照桶的大小依次取出数据，数据就是有序的了。 例如，需要给10万人按照年龄排序，应该怎么做呢？使用计数排序就能够很有效的解决，我们可以假设，10万人中，年龄最小的是1，年龄最大的是120，那么我们可以初始化120个桶，将年龄相同的放如到一个桶中，这样数据整体就有序了。 这里我模拟了一个计数排序：假如要给班上的100个人按照成绩进行排序，成绩最大值是10，最小值是0，那么可以用11个桶，每个桶的下标表示成绩即0-10。 public class CountingSort { //假设有100个考生，分数在0-10之间 public static void countingSort(int[] data) { int index = 0; //新建11个桶，每个桶内保存相同的分数 //使用链表模拟桶，新建11个桶 ArrayList&lt;LinkedList&lt;Integer>> buckets = new ArrayList&lt;>(); //初始化桶 for(int i = 0; i &lt; 11; i ++) { buckets.add(new LinkedList&lt;>()); } //将数据放入到桶中 for(int i = 0; i &lt; data.length; i ++) { buckets.get(data[i]).add(data[i]); } //将数据取出来 for(int i = 0; i &lt; 11; i ++) { for(int j = 0; j &lt; buckets.get(i).size(); j ++) { data[index ++] = buckets.get(i).get(j); } } } public static void main(String[] args) { // TODO Auto-generated method stub //100个考生，分数在0-10之间 int[] data = new int[100]; for (int i = 0; i &lt; data.length; i++) { data[i] = (int) (Math.random() * 11); } System.out.println(Arrays.toString(data)); CountingSort.countingSort(data); System.out.println(Arrays.toString(data)); } } 其实可以发现，计数排序和桶排序在代码上的区别就是：计数排序没有桶内排序这一环节。其他都是类似的。 4.基数排序首先思考一个问题，假如要对10万个手机号码进行排序，应该怎么做呢？手机号码有11位，显然不太适合上面的两种桶排序和计数排序，还记得前面说到的稳定排序吗？我们可以借助稳定的排序，从手机号码的最后一位开始比较，最后按照第一位排序，因为是稳定的，后面位数的号码不会被打乱，排完之后，整个手机号码就有序了。 我是用几个简单的数组来实现这个排序的过程：","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://roseduan.github.io/tags/排序/"}]},{"title":"数据结构与算法——栈与队列","slug":"数据结构与算法——栈与队列","date":"2018-12-07T06:31:11.000Z","updated":"2018-12-08T07:57:16.080Z","comments":true,"path":"2018/12/07/shu-ju-jie-gou-yu-suan-fa-zhan-yu-dui-lie/","link":"","permalink":"http://roseduan.github.io/2018/12/07/shu-ju-jie-gou-yu-suan-fa-zhan-yu-dui-lie/","excerpt":"","text":"1.栈前面说到了链表，其实常见的、简单的数据结构还有栈和队列，今天就来看看这两种数据结构。 栈其实很好理解，举个例子：办公桌上的一堆文件，后放上去的、位于最上方的，总是最先拿到的；而先放进去的，反而会被压在最后，所以总是最后才能拿到。这种满足了先进后出、后进先出的特点的数据结构，就叫做栈。 很明显，栈是一种操作受限的数据结构，插入和删除都只能在一端进行，插入操作叫做入栈，删除叫做出栈。那么怎么实现一个栈呢？有两种方式，一是利用数组来实现，这种叫做顺序栈，二是利用链表来实现，叫做链式栈。这里来看看怎么用数组来实现一个顺序栈。 /** * @ClassName ArrayStack * @Description 用数组实现顺序栈 * @Author Rose_Duan * @Date 2018/11/4 16:43 * @Version 1.0 **/ public class ArrayStack { private String[] items; private int count;//栈中元素的个数 private int n;//栈容量 //不带参的构造器，默认栈容量大小是10 public ArrayStack() { this(10); } public ArrayStack(int capacity) { this.items = new String[capacity]; this.count = 0; this.n = capacity; } //入栈操作 public boolean push(String item){ //数组容量已满，则无法插入 if (this.count == n) return false; items[count] = item; ++ this.count; return true; } //出栈操作 public String pop(){ //栈为空 if (this.count == 0) return null; String result = items[this.count - 1]; -- count; return result; } } 接下来看看时间复杂度：结合代码不难想到，不管是入栈还是出栈，都是在栈一端进行的惭怍，所以插入和删除的时间复杂度都是O(1)。链式栈的定义也比较的简单了，我这里给出了链式栈的简单的两个方法：入栈和出栈： public class LinkedListStack{ private int size; private Node top;//栈顶结点 //入栈 public void push(int value){ Node newNode = new Node(value, this.top); this.top = newNode; ++ this.size; } //出栈 public int pop(){ Node popNode = this.top; if (popNode == null) return null;//栈为空 this.top = popNode.next; if (this.size > 0) -- this.size; return popNode.getData(); } //栈中的结点定义 class Node{ private int data; private Node next; public Node(int data, Node next){ this.data = data; this.next = next; } public int getData(){ return this.data; } } } 还有的一些操作，比如求栈顶元素、遍历栈，你可以自己试着实现一下。 2.队列接下来再看看和栈很相似的另一种数据结构：队列。 队列跟我们常说的排队很类似，比如我们在食堂排队打饭，排在前面的人先打到饭，排在后面的人后打到饭，这种具有先进先出特点的数据结构就叫做队列。跟栈类似，队列的操作也是受限的，插入元素即入队列只能在队列尾部进行，取出元素即出队列只能在队列头部进行。 跟栈一样，队列也有两种实现方式，用数组实现的叫做顺序队列，用链表实现的叫做链式队列。 public class ArrayQueue { private String[] data; private int size;//队列容量 //队列头尾指针 private int head = 0; private int tail = 0; public ArrayQueue(int capacity) { this.data = new String[capacity]; this.size = capacity; } //入队列 public boolean enquque(String value) { //尾指针和容量大小相同，说明队列尾部没有空间了 if (tail == size) { if(head == 0) return false;//如果head == 0 &amp;&amp; tail == size，表示队列已满 //数据搬移 for(int i = head; i &lt; tail; i ++) { data[i - head] = data[i]; } //更新head和tail的值 head = 0; tail = tail - head; } data[tail] = value; ++ tail; return true; } //出队列 public String dequeue() { if(head == tail) return null;//如果head等于tail，表示队列为空 String result = data[head]; ++ head; return result; } } 上面是顺序队列的数组实现，可以看到，出队列的时间复杂度一直为O(1)。但是入队列的情况就有点不一样了，当队尾还有空间的时候，可直接入队列，时间复杂度还是O(1)，当队尾没有空间并且队头还有空间的时候，需要将数据搬移至队头，这时候的时间复杂度就为O(n)了。 3.循环队列普通的队列比较的简单，现在来看看队列的另一种形式：循环队列。 像上面那种普通的队列，当队列尾部没有空间的时候，我们就需要进行数据搬移，这样消耗的时间比较的多，循环队列能够很方便的解决这个问题。 如上图，当tail指针到达队列尾部的时候，我们不像普通队列那样进行数据搬移，而是直接将数据插入到0的位置，然后更新tail指针的位置。和普通队列一样，队列为空的判断条件还是head == tail，但是队列满的判断条件就不一样了，而是(tail + 1) % length = head。 你可以根据上面的图来理解，可以发现队列满的时候，其实还有一个空间没用，所以循环队列实际上会浪费一个存储空间。 public class CircularQueue { private String[] data; private int size; //队列头尾指针 private int head = 0; private int tail = 0; public CircularQueue(int capacity) { this.data = new String[capacity]; this.size = capacity; } //入队列 public boolean enqueue(String value) { if((tail + 1) % size == head) return false;//队列已满 data[tail] = value; tail = (tail + 1) % size; return true; } //出队列 public String dequeue() { if(head == tail) return null;//队列为空 String result = data[head]; head = (head + 1) % size; return result; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"栈与队列","slug":"栈与队列","permalink":"http://roseduan.github.io/tags/栈与队列/"}]},{"title":"数据结构与算法——链表","slug":"数据结构与算法——链表","date":"2018-12-02T07:13:41.000Z","updated":"2018-12-07T06:30:46.962Z","comments":true,"path":"2018/12/02/shu-ju-jie-gou-yu-suan-fa-lian-biao/","link":"","permalink":"http://roseduan.github.io/2018/12/02/shu-ju-jie-gou-yu-suan-fa-lian-biao/","excerpt":"","text":"1.概述链表可以说是最基础的数据结构之一了，使用也十分的广泛，今天就来说说链表这个数据结构。链表通常分为单链表、双向链表、循环链表，其中双链表是最常用的。 2.单链表首先来看看单链表，与数组相比，链表不需要连续的内存空间，它使用指针将不连续的内存块连接起来。其中的内存块我们称为链表的结点，为了将结点串联起来，每个结点还需要一个next指针，指向下一个结点的地址。下面是单链表的示意图： 可以从图中看到，链表的每个结点保存了数据data和指向下一个结点的指针next，其中有两个指针比较特殊，一个是头节点（第一个结点）的指针，它指向了头结点的地址，使用它我们可以遍历整个链表；另一个是尾结点（最后一个结点）的指针，它指向null，表示链表的结束。 单链表其实与我们常用的数组类似，都支持元素的插入、删除、查找，只不过单链表与数组的最大区别就是内存空间不连续，所以不用担心容量不足的问题。我们知道，数组的插入和删除操作十分的耗时，因为为了保证内存的连续性，必须进行大量的数据搬移工作。 但是链表却能够很高效的插入和删除元素，只需要改变指针的指向即可。 结合上面的图就不难理解了，单链表可以在O(1)时间复杂度内添加和删除元素，这比数组就更加有优势了。 但是有一个问题，要是我们查找一个元素呢？非常不幸，只能从链表的头结点开始遍历，然后找到元素，这样时间复杂度就为O(n)了。 这里我给出了单链表的查找和删除结点的代码，你可以结合代码来理解一下，然后动手写写其他的单链表操作。 public class SingleLinkedList { private Node head = null;//定义头结点 //1.根据值查找结点 public Node getNodeByValue(int value) { Node p = head; while (p != null &amp;&amp; p.getData() != value) { p = p.next; } return p; } //2.删除值等于给定值的结点 public void deleteByValue(int value) { if (head == null) return; Node p = head; Node pBefore = null;//用pBefore表示p前面一个结点 while (p != null &amp;&amp; p.getData() != value) { pBefore = p; p = p.next; } if (p == null) return;//说明没有找到结点 if(pBefore == null) head = head.next;//说明删除的结点是头结点 else pBefore.next = pBefore.next.next;//否则将pBefore的指针指向p的后一个结点，即删除p } //定义链表结点 class Node{ private int data; private Node next; public Node(int data, Node next) { this.data = data; this.next = next; } public int getData() { return data; } } } 3.循环链表循环链表其实与单链表的唯一区别就是，循环链表的尾结点指针指向了头结点，这样就形成了一个循环的结构，用来解决某些具有环形特点的问题。 4.双向链表我们重点来看一下双向链表，其实根据名字就能够猜个大概了，双向链表和单链表的区别就是：一个结点有两个指针，一个指针指向前面的结点，一个指针指向后面的结点。 不难想到，双向链表肯定会更加的占用内存空间，因为每个节点储存了两个指针，但是为什么空间消耗更大的双向链表的应用还要更多呢？其实很简单，运用前后两个指针，主要是为了查找和删除的效率更高！在单链表中，我们知道，插入和删除结点的时间复杂度都是O(1)，但是要删除一个值等于给定值的结点，结合上面单链表的delete方法，我们首先需要找到这个结点的前驱结点，然后再改变前驱结点的指针进行删除，删除的操作是O(1)，但是这个查找的过程就很耗时了，时间复杂度为O(n)。 但是在双向链表中就没有这个查找过程，因为每个节点自身保存了指向前驱结点的指针，这样就很方便的找到了前驱结点，然后在进行删除操作，整个时间复杂度是O(1)。 这里体现出来的思想，即利用更多的空间来换取时间上的更快的执行效率，就称为以空间换时间，反之就是以时间换空间。 这里我给出了双向链表的简单的插入和删除的方法，你可以参考，然后是实现其他的功能。 /** * @ClassName DoubleLinkedList * @Description 双向链表的实现 * @Author Rose_Duan * @Date 2018/12/5 16:04 * @Version 1.0 **/ public class DoubleLinkedList { private Node head = null;//链表的头结点 //查找含有某值的结点 public Node getNodeByValue(int value){ Node p = head; while (p != null &amp;&amp; p.getData() != value) p = p.next; return p; } //1.在链表末尾插入结点，常规插入 public void insert(int value){ Node node = new Node(value); if (head == null){ head = node; return; } Node p = head; while (p.next != null) p = p.next; p.next = node; node.prev = p; } //2.在结点之前插入含有某值的结点 public void insertBefore(Node p, int value){ if (head == null || p == null) return; Node node = new Node(value); if (p.prev == null){//说明是在头结点的前面插入 node.next = head; head.prev = node; head = node; } else { Node pBefore = p.prev; pBefore.next = node; node.prev = pBefore; node.next = p; p.prev = node; } } //3.删除某结点之前的结点 public void deleteBefore(Node p){ if (head == null || p == null) return; Node delete = p.prev; Node deleteBefore = delete.prev; if (deleteBefore == null){//删除的是头结点 head = p; head.prev = null; delete.next = null; } else { deleteBefore.next = delete.next; p.prev = delete.prev; } } //打印链表中的所有数据 public void printAll(){ if (head == null) System.out.println(\"链表为空\"); else { Node p = head; while (p != null){ System.out.print(p.getData() + \" \"); p = p.next; } } } //链表结点定义 class Node{ private int data; private Node prev;//前驱指针 private Node next;//后继指针 public Node(int data) { this.data = data; this.prev = null; this.next = null; } public int getData() { return data; } } public static void main(String[] args) { DoubleLinkedList linkedList = new DoubleLinkedList(); linkedList.insert(10); linkedList.insert(12); linkedList.insert(13); linkedList.insert(20); Node node = linkedList.getNodeByValue(12); linkedList.deleteBefore(node); Node head = linkedList.head; System.out.println(head.prev); System.out.println(head.getData()); linkedList.printAll(); } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://roseduan.github.io/tags/链表/"}]},{"title":"Java学习笔记1——基本程序设计结构","slug":"Java学习笔记1——基本程序设计结构","date":"2018-12-01T13:13:36.000Z","updated":"2018-12-02T12:43:16.642Z","comments":true,"path":"2018/12/01/java-xue-xi-bi-ji-1-ji-ben-cheng-xu-she-ji-jie-gou/","link":"","permalink":"http://roseduan.github.io/2018/12/01/java-xue-xi-bi-ji-1-ji-ben-cheng-xu-she-ji-jie-gou/","excerpt":"","text":"1.Java程序示例 /* 多行注释 多行注释 */ public class HelloWorld { //单行注释 public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 1.Java对大小写敏感 2.Java类的命名规范：首字母大写的名词，如果由多个单词组成，则每个单词的首字母都应该大写，称为驼峰式命名。 3.源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。 4.//表示单行注释，/**/表示多行注释 2.数据类型 1.Java共有8种基本数据类型： 整型：byte（1字节）、short（2字节）、int（4字节）、long（8字节） 浮点型：float（4字节）、double（8字节） 字符型：char（1字节） 布尔型：boolean Java的数据类型范围都是固定的，没有无符号类型的数据。 2.数字加上前缀：0b表示二进制，0表示八进制，0x表示十六进制 3.绝大部分的程序都采用double类型，float的数值后一个后缀F，没有后缀F的浮点数值则默认为double类型。 4.boolean类型有2个值：true和false，用来判断逻辑条件。整型值和布尔值之间不能相互转换。 5.数值类型之间的转换： 如果两个操作数中有一个是double，另一个就转换为double 否则，如果如果其中一个数是float，另一个数就转换为float 否则，如果其中一个数是long，另一个数转换为long 否则，两个操作数都转换为int 3.变量 1.变量名必须是一个以字母开头的由字母或数字组成的序列。 2.可以在一行中声明多个变量，例如int i, j;，但是不建议这样做，逐个声明变量有利于提高程序的可读性。 3.利用关键字final定义常量，习惯上，常量名全大写。 4.字符串 1.String类没有提供用于修改字符串的方法，所以String类型字符串是不可变的。 2.可以使用equals方法检测两个字符串是否相等。 3.要检测一个字符串既不为null也不是空串，可以使用if(str != null &amp;&amp; str.length != 0) 4.String常用方法： char charAt(int index)：返回index位置的字符 int compareTo(String other)：按照字典顺序比较字符串 String concat(String str)：拼接字符串 contains(CharSequence s)：查看字符串是否包含 boolean startWith(String prefix)和boolean endsWith(String suffix)：以什么开始或结束 boolean equals(Object obj)：判断是否相等 indexOf、lastIndexOf split subString：截取子字符串 toCharArray()：将字符串转换为字符数组 toUpperCase()、toLowerCase() trim()：去掉字符串头部和尾部的空格 5.大数值 1.如果基本的整数和浮点数精度不能够满足需求，可以使用java.math包中的大数值类型：BigDecimal和BigInteger。这两个类可以处理任意长度数字序列的数值。 2.BigInteger实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。 3，大数值类型实现算术运算必须使用方法：add、subtract、multiply、divide分别表示加、减、乘、除。 6.数组 1.数组是一种数据结构，用来储存同一种类型的值的集合。可以通过下标访问数组中每个元素的值。 2.创建一个数字数组时，所有的元素都会初始化为0，boolean数组的元素会初始化为false，对象数组的元素会初始化为null。 3.有一个更简单的方法打印数组中的所有值：Arrays.toString() 4.数组拷贝的两种方法： int[] data = {1,2,3,4,5}; int[] num = Arrays.copyOf(data, data.length * 2); int[] rose = new int[10]; System.arraycopy(data, 0, rose, 0, data.length); 5.数组排序：Arrays.sort()，此方法采用的是快速排序实现。","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://roseduan.github.io/categories/Java基础知识/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://roseduan.github.io/tags/Java基础/"}]},{"title":"数据结构与算法——排序（三）","slug":"数据结构与算法——排序（三）","date":"2018-11-30T07:06:54.000Z","updated":"2018-12-01T09:54:19.926Z","comments":true,"path":"2018/11/30/shu-ju-jie-gou-yu-suan-fa-pai-xu-san/","link":"","permalink":"http://roseduan.github.io/2018/11/30/shu-ju-jie-gou-yu-suan-fa-pai-xu-san/","excerpt":"","text":"1.回顾前面说到了三种最基本的排序算法，分别是冒泡排序、选择排序、插入排序，他们的平均时间复杂度都是O(n2)，适用于小规模数据的排序，其中插入排序的效率稍高，工作中使用得更多，我也推荐使用插入排序。今天讲到的三种排序算法的时间复杂度都是O(nlogn)，分别是希尔排序、归并排序、快速排序，其中后两者的使用非常的普遍。 2.希尔排序首先来看看希尔排序，希尔排序其实本质上也是一种插入排序，只是做了一些优化，其思路是：将排序的数组按照一定的增量将数据分组，每个分组用插入排序算法排序，然后增量逐步减小，当增量减小为1的时候，算法便终止，所以希尔排序又叫做“缩小增量排序”。 我们常取的原始增量为数据的大小/2，例如数据大小为length，我们将其分为leng / 2个组，然后length = length / 2，继续分下去，直到length = 1。文字看起来比较抽象，我画了图来帮助你理解： 下面是它的代码实现： /** * @ClassName ShellSort * @Description 希尔排序算法 * @Author roseduan * @Date 2018/11/30 22:30 * @Version 1.0 **/ public class ShellSort { public static void shellSort(int[] data) { int length = data.length; if(length &lt;= 1) return ; //定义增量 int step = length / 2; while(step >= 1) { for(int i = step; i &lt; length; i ++) { int value = data[i]; int j = i - step; for(; j >=0; j -= step) { if(value &lt; data[j]) data[j + step] = data[j]; else break; } data[j + step] = value; } //增量缩小 step = step / 2; } } } 很遗憾，希尔排序虽然时间复杂度为O(nlogn)，但它是一种不稳定的算法，因为分组的时候可能会错开相同的元素，分组进行插入排序的时候，元素的位置交换之后，稳定性就被破坏了。比起归并排序，它是不稳定的，比起快速排序，它的执行效率稍慢，所以希尔排序并没有应用得很广泛。 3.归并排序归并排序的思路是这样的：将排序的数据分为若干子数组，子数组排序之后，再进行合并，这样要排序的数组就能排好了。这种思想叫做分治，就是将一个大的问题分解成很多小问题，将小问题就解决了，大的问题也就解决了。用分治思想解决的问题，一般都可以用递归这种编程技巧来表示。 结合上面的图可以看到，假如我们要排序data[p……r]这个数组，首先我们将数组分为data[p……q]和data[q+1……r]，然后再进行合并，用公式可以这样表示： merge_sort(data[p……r]) = merge(merge_sort(data[p……q]), merge_sort(data[q+1……r])); merge函数表示将两个子数组进行合并。那么merge函数该怎么表示呢？ 思路是这样的：首先我们新建一个临时数组temp，大小和原始数组相同。然后使用两个指针i，j分别指向两个子数组的第一个元素，如果i所指元素 &lt; j所指元素，则将i所指元素插入temp，i向前移动；反之将j所指元素插入，j向前移动。以此类推，直到比较完成，然后将临时数组temp复制到原始数组中。 归并排序的代码是这样的： /** * @ClassName MergeSort * @Description 归并排序算法 * @Author Rose_Duan * @Date 2018/12/1 15:41 * @Version 1.0 **/ public class MergeSort { public static void mergeSort(int[] data, int n){ mergeInternally(data, 0, n - 1); } private static void mergeInternally(int[] data, int p, int r){ if (p >= r) return; //计算p到r的中间值q // 此等式相当于int q = (p + r) / 2，只不过下面这样写效率更高 int q = p + ((r - p) >> 1); //递归 //data[p r]分为data[p q]和data[q+1 r] mergeInternally(data, p, q); mergeInternally(data, q + 1, r); //合并 merge(data, p, q, r); } private static void merge(int[] data, int p, int q, int r){ int i = p; int j = q + 1; int k = 0; //新建一个临时数组，大小与data[p……r]一样 int[] temp = new int[r - p + 1]; while (i &lt;= q &amp;&amp; j &lt;= r){ if (data[i] &lt;= data[j]) temp[k ++] = data[i ++]; else temp[k ++] = data[j ++]; } //判断哪个子数组中有剩余的数据 //首先假设data[p....q]中有剩余的数据 int start = i; int end = q; //如果j小于等于r，则说明data[q+1...r]中有剩余的数据 if (j &lt;= r){ start = j; end = r; } //将剩余的元素拷贝到temp中 while (start &lt;= end){ temp[k ++] = data[start ++]; } //最后，将临时数组中的数据拷贝到data中 for(i = 0; i &lt;= r - p; i ++){ data[p + i] = temp[i]; } } } 归并排序并不是一种原地排序算法，因为很明显，我们申请了一个临时数组来保存数据，这个临时数组最大不会超过原始数组，所以空间复杂度为O(n)。归并排序的时间复杂度是O(nlogn)，并且是一种稳定的排序算法。 4.快速排序快速排序简称“快排”，它的思路和归并排序很类似，都是利用的分治思想。首先选取任意一个数据作为分区点，比分区点小的数据放在其左边，大的放在右边。 这样数组就分为了三个部分，一是分区点q，然后对p——q-1和q+1——r的数据分别再执行上图操作，这样整个数据就有序了。 归并排序当中有个merge合并函数，这里我们需要一个partition分区函数，主要的功能是实现上图的操作，将小于分区点的数据放在其左边，大于分区点的放在其右边，然后返回分区点。具体要怎么实现呢？这里用到的思路比较的巧妙：对于一个数组data[p….r]，我们选区最后一个元素data[r- 1]为分区点(也就是data[pivot])，然后用两个指针i，j指向第一个元素，如果data[j] &lt; data[pivot]，那么就互换i和j所指向的元素，然后i，j向前移动。如果data[j] &gt;= data[pivot]，那么不用交换位置，i不移动，j继续移动。 结合代码看一下： /** * @ClassName QuickSort * @Description 快速排序算法 * @Author Rose_Duan * @Date 2018/11/14 13:44 * @Version 1.0 **/ public class QuickSort { public static void quickSort(int[] data, int n){ quickSortInternally(data, 0, n - 1); } private static void quickSortInternally(int[] data, int p , int r){ if (p >= r) return; int q = partition(data, p, r);//获取分区点 //递归 quickSortInternally(data, p, q - 1); quickSortInternally(data, q + 1, r); } private static int partition(int[] data, int p, int r){ int pivot = data[r]; int i = p; for (int j = p; j &lt; r; j++) { if (data[j] &lt; pivot){ int temp = data[i]; data[i] = data[j]; data[j] = temp; i ++; } } int temp = data[i]; data[i] = data[r]; data[r] = temp; return i; } } 很明显，在partition分区函数中，我们交换了元素的顺序，这样值相同的元素的前后顺序可能会被打乱，你可以结合我前面对partition函数的描述在看一下，所以快速排序是不稳定的。快速排序的平均时间复杂度是O(nlogn)，并且是一种原地排序算法，空间复杂度是O(1)。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://roseduan.github.io/tags/排序算法/"}]},{"title":"数据结构与算法——排序（二）","slug":"数据结构与算法——排序（二）","date":"2018-11-29T07:52:06.000Z","updated":"2018-11-29T13:47:10.414Z","comments":true,"path":"2018/11/29/shu-ju-jie-gou-yu-suan-fa-pai-xu-er/","link":"","permalink":"http://roseduan.github.io/2018/11/29/shu-ju-jie-gou-yu-suan-fa-pai-xu-er/","excerpt":"","text":"1.回顾前面说到了冒泡排序，这种算法的思路比较的简单，就是基于两个元素之间的比较，然后交换位置。冒泡排序的平均时间复杂度是O(n2)，空间复杂度是(1)，并且是稳定的排序算法。今天继续讲述另外两种排序算法：选择排序和插入排序。 2.选择排序选择排序的思路是这样的：将要排序的数组分为未排序区间和已排序区间，遍历未排序区间，找到其最小值（或者最大值），将其插入到已排序区间的末尾。依次遍历，直到将未排序区间遍历完，整个排序操作就完成了。我画了一张图来帮助你理解其原理： 相信结合这个图你就不能理解选择排序了，下面是它的代码实现： /** * @ClassName SelectionSort * @Description 选择排序算法 * @Author roseduan * @Date 2018/11/11 21:01 * @Version 1.0 **/ public class SelectionSort { public static void selectionSort(int[] data) { int length = data.length; if (length &lt;= 1) return; for(int i = 0; i &lt; length - 1; i ++) { //查找最小值 int minIndex = i; for(int j = i + 1; j &lt; length; j ++) { if (data[j] &lt; data[minIndex]) minIndex = j; } //交换位置 int temp = data[i]; data[i] = data[minIndex]; data[minIndex] = temp; } } } 综合代码分析，不难看出，选择排序的平均时间复杂度是O(n2)，是一种原地排序算法，空间复杂度是O(1)，那么它和冒泡排序一样，是稳定的排序吗？答案是否定的，选择排序是一种不稳定的排序算法。 因为选择排序每次都要在未排序区间找到最小值，并且和前面的元素交换位置，这样就破坏了稳定性。例如一个数组[3,3,1,7,2]，第一次排序的时候，找到最小值1和第一个3交换，这样两个3的位置就乱了，所以就不稳定了。 3.插入排序插入排序的思路其实和选择排序类似，都是将排序数分为已排序区间和未排序区间，插入排序的具体做法是这样的：依次遍历未排序区间，将未排序区间的数和已排序区间的数组进行比较，将其插入到合适的位置上，保证已排序区间一直都是有序的，遍历完成排序则完成。 结合下面的图来理解一下： 是不是很简单呢？你可以思考一下它的代码实现，然后在参考我下面的代码实现： /** * @ClassName InsertionSort * @Description 插入排序算法 * @Author roseduan * @Date 2018/11/25 20:11 * @Version 1.0 **/ public class InsertionSort { public static void insertionSort(int[] data) { int length = data.length; if (length &lt;= 1) return; for(int i = 1; i &lt; length; i ++) { int value = data[i]; int j = i - 1; for(; j >= 0; j --) { if(data[j] > value) data[j + 1] = data[j]; else break; } data[j + 1] = value; } } } 综上分析，插入排序的平均时间复杂度是O(n2)，是一种原地排序算法，空间复杂度是O(1)，那么它是稳定的吗？我们来分析一下：结合上面的代码，只有当data[j] &gt; value的时候，才会交换两个元素的位置，所以这并不会破坏稳定性，例如一个数组[1,3,3,7,5]，5和7交换了位置之后，由于5&gt;3，所以并不会继续交换位置。所以我们可以得知：插入排序是稳定的排序算法。 4.总结好了，三种基本的排序算法都已经学完了，针对其是否稳定，时间复杂度等性质，我总结了一下： 其实这三种排序算法在实际的开发场景中用的并不多，因为时间复杂度较高，只适用于小规模的数据排序。但是你可以自己实现一下，锻炼一下自己的思维和编码能力。下一次讲讲述更常用的归并排序和快速排序。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://roseduan.github.io/tags/排序算法/"}]},{"title":"为什么我说看文档是最快捷有效的学习方式？","slug":"为什么我说看文档是最快捷有效的学习方式","date":"2018-11-27T08:32:56.000Z","updated":"2018-11-29T07:51:05.637Z","comments":true,"path":"2018/11/27/wei-shi-me-wo-shuo-kan-wen-dang-shi-zui-kuai-jie-you-xiao-de-xue-xi-fang-shi/","link":"","permalink":"http://roseduan.github.io/2018/11/27/wei-shi-me-wo-shuo-kan-wen-dang-shi-zui-kuai-jie-you-xiao-de-xue-xi-fang-shi/","excerpt":"","text":"1.以前我学习一门新技术的时候，总会有一个习惯的动作，那就是打开浏览器，百度搜索“xxx教程”，然后在众多列表里面寻找自己认为质量还不错的教程。 但是这样有一个很大的问题，那就是时间成本较高。我很难在短时间内快速的寻找到自己想要看到的内容，因为搜索出来的内容参差不齐，大部分是CSDN、博客园上面的博客，有的是简书、知乎等等乱七八糟的网站链接。在没有长时间的经验积累下，我就会一个一个挨着打开，然后浏览一遍内容，然后返回打开下一个……所以我说这样做的时间成本是很高的。 还有，在我刚入门的时候，比如学Java基础，总是喜欢看视频来学习，但是网上的视频资源太多了怎么办？那就需要花时间来寻找适合的教程，百度一搜，也是很多东西。现在看来，网上关于基础内容的一些教学视频大多讲得非常得啰嗦，经常性的聊一些无关的内容，我觉得这样太浪费时间了。 2.后来我发现，其实学习到的很多技术，比如Redis，Solr，SSM，Git等等，在其官方网站上面都会有详细的参考文档，这都是官方开发人员的总结教程，比较的权威，十分适合快速入门新的技术。还有一大优点是不用花时间去寻找，一般在官网的首页就能看到。但有一个很大的问题就是这些文档绝大部分都是英文的，并且我也不建议你直接鼠标右键然后翻译成简体中文，因为这种翻译的效果太差了。于是这样一道门槛把很多人都拦住了。 其实我也是这样的，看到长篇大论的英文，的确很头痛，索性放弃，去寻找其他的教程。但是后来我想，我非科班出身，起点本来就比别人低，要是还按照常规的套路，进步岂不是太慢了？所以我只能硬着头皮看官方英文文档了，刚开始肯定痛苦，但是经验积累多了，慢慢的就会好很多，顺便也能提高一下自己的英文水平，何乐而不为呢。 同理，对于学习一些较为系统的内容，比如编程语言Java、Python等，网上很难找到系统的文字教程。所以我推荐看书，虽然花点钱，但是效率高很多了，省去了寻找教学视频的时间和教学视频讲师瞎BB的时间。如果连一本书都没有耐心看下去的话，我也并不认为干其他的事情会有耐心。 3.但是对于刚入门的人来说，书上的有些内容的确很难理解，必须要视频讲授帮助理解。这种情况，看视频还是可以的，但是记住一点，那就是免费的视频大多是垃圾。遇到问题，需要借助搜索解决，那么我不推荐百度，因为百度出来的内容大部分质量堪忧，倒不如花点钱买个VPN上Google。记住一点，如果一个问题能够花钱这种方式来解决，那么这种方式一定是最好的。","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}]},{"title":"数据结构与算法——-排序（一）","slug":"数据结构与算法——排序（一）","date":"2018-11-25T14:20:39.000Z","updated":"2019-05-09T14:56:50.886Z","comments":true,"path":"2018/11/25/shu-ju-jie-gou-yu-suan-fa-pai-xu-yi/","link":"","permalink":"http://roseduan.github.io/2018/11/25/shu-ju-jie-gou-yu-suan-fa-pai-xu-yi/","excerpt":"","text":"1.导言因为这是排序算法系列的第一篇文章，所以多啰嗦几句。 排序是很常见的算法之一，现在很多编程语言都集成了一些排序算法，比如Java 的Arrays.sort()方法，这种方式让我们可以不在乎内部实现细节而直接调用，在实际的软件开发当中也会经常使用到。但是站在开发者的角度而言，知其然必须知其所以然。多练练排序算法，不仅能够让我们知道一些排序方法的底层实现细节，更能够锻炼我们的思维，提升编程能力。现在很多技术面试也会涉及到基本的排序算法，所以多练习是有好处的。 文中涉及到的代码都是Java实现的，但是不会涉及到太多的Java语言特性，并且我会加上详细的注释，帮助你理解代码并且转换成你熟悉的编程语言。 常见的排序算法有以下10种： 冒泡排序、选择排序、插入排序，平均时间复杂度都是O(n2) 希尔排序、归并排序、快速排序、堆排序，平均时间复杂度都是O(nlogn) 计数排序、基数排序、桶排序，平均时间复杂度都是O(n + k) 在开始具体的排序算法讲解之前，先得明白两个概念： 原地排序：指的是在排序的过程当中不会占用额外的存储空间，空间复杂度为O(1)。 排序算法的稳定性：一个稳定的排序，指的是在排序之后，相同元素的前后顺序不会被改变，反之就称为不稳定。举个例子：一个数组[3，5，1，4，9，6，6，12]有两个6（为了区分，我把一个6加上了下划线），如果排序之后是这样的：[1，3，4，5，6，6，9，12]（加下划线的6仍然在前面），就说明这是一个稳定的排序算法。 2.言归正传冒泡排序的思路其实很简单，一个数据跟它相邻的数据进行大小的比较，如果满足大小关系，就将这两个数据交换位置。一直重复这个操作，就能将数据排序。 举个例子，假如有数组a[3,5,1,4,9,6]，第一次冒泡的操作如下图所示： 重复进行这个操作，6次冒泡之后，数据排序完成。 根据这个思路，你很容易能够写出下面的代码实现冒泡排序： public class BubbleSort { //data表示整型数组，n表示数组大小 public static void bubbleSort(int[] data, int n){ //数组大小小于等于1，无须排序，返回空 if (n &lt;= 1) return; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n - i - 1; j++) { //如果data[j] > data[j + 1]，交换两个数据的位置 if (data[j] > data[j + 1]){ int temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; } } } } } 但是这个排序算法还可以进行优化，当冒泡操作已经没有数据交换的时候，说明排序已经完成，就不用在进行冒泡操作了。例如上面的例子，第一次冒泡之后，数据为[3,1,4,5,6,9]，再进行一次冒泡，数据变为[1,3,4,5,6,9]，此时已经完成了排序，就可以结束循环了。 所以针对这个数组的排序，上面的代码需要6次冒泡才能完成，其中有4次都是不需要的。所以可以对代码进行优化： public class BubbleSort { //优化后的冒泡排序 //data表示整型数组，n表示数组大小 public static void bubbleSort(int[] data, int n){ //数组大小小于等于1，无须排序，返回空 if (n &lt;= 1) return; for (int i = 0; i &lt; n; i++) { boolean flag = false;//判断是否有数据交换 for (int j = 0; j &lt; n - i - 1; j++) { //如果data[j] > data[j + 1]，交换两个数据的位置 if (data[j] > data[j + 1]){ int temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; flag = true;//表示有数据交换 } } //如果没有数据交换，则直接退出循环 if (!flag) break; } } } 好了，冒泡排序的基本思路和代码都已经实现，最后总结一下： 冒泡排序是基于数据比较的 最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n2)，平均时间复杂度是O(n2) 冒泡排序是原地排序算法，并且是稳定的。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://roseduan.github.io/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://roseduan.github.io/tags/排序算法/"}]},{"title":"报到贴","slug":"报到贴","date":"2018-11-19T13:40:09.000Z","updated":"2019-05-09T14:55:43.930Z","comments":true,"path":"2018/11/19/bao-dao-tie/","link":"","permalink":"http://roseduan.github.io/2018/11/19/bao-dao-tie/","excerpt":"","text":"1.说来惭愧，在去年的这个时候，我就已经想要搭建自己的博客了，并且折腾了一天，基本上完成了初步的搭建。但是我并没有使用起来，这个博客也就荒废在这里了。大概一年之后，可能是外部因素的刺激，也可能是自身的觉悟使然，让我又重新搭建起自己的博客。浪费了一年时间之后，有一种悔不当初的复杂心情，也有重新来过的轻快愉悦，在这里，我写下roseduan的个人博客的第一篇文章。 2.前段时间，我看到了公众号【码农翻身】里面的一篇文章，里面有说到写作对于一个程序员有多么的重要。具体的内容不必赘述，只想阐述其中的一点： 一个知识点学没学透彻，一个很有效的判断的方法就是你能不能够向别人讲述清楚这个知识点。很多时候，我们在学习的时候，知识在内心有个大致的概念，感觉自己弄懂了，但是要你自己表述出来，我们常常感到很困难，这就说明我们其实并没有彻底弄懂这个知识。那该怎么办，我们总不能老是拿别人来做自己的知识练习对象，‘哎哎，我今天学了数据库，我给你讲讲吧！’，刚开始别人可能还有兴趣听一听，但是长此以往没有人受得了。 所以，写作的优势就能够体现出来了。写作逼着你去思考，去总结，去想怎么把这个问题说明白。其实这就直接锻炼了我们的文字组织能力和语言表达能力。 以上，是近期直接导致我想要重新开始写博客的原因，因为这个观点戳中了我内心最真实的想法。长期以来，我接触到的这方面的东西实在不少，总是建议我们应该写作，应该坚持下去。但是碍于自己的写作意识不够和不能够更好坚持下去的缘由，我迟迟未能在这一片天地开拓出自己的空间，但现在，是时候了。 3.互联网时代的好处之一便是将一些远在天边的人和自己以某种方式相联系，让我能够从中学习到别人身上的优点，看到别人的光环，并知道别人是怎么做到这一切的。我很幸运的能够接触到一些行业内的比较厉害的人，跟我类似的也大有人在：非科班出身，自学编程，成为行业大牛，互联网大V。我从这些人身上看到了很多共同的优点，其中之一便是长期坚持写作。虽说我跟他们的差距非常的大，但这并不妨碍我在心中播下梦想的种子，因为有期待就有前进的动力。 4.我的写作经验大都是在我的公众号【roseduan】上面积累的，但是更新连续性并不是很好，经常出现较长时间的停更。而且这上面都是非技术性的文章，所以只要脑子没有打开，没有新的思考的话，就比较难长时间的更新。但是我不会放弃的，公众号与博客，将是我长期写作的地方。困难将可以预见，那就是我能不能长时间的坚持下去，还有就是初期的写作不会博得太多的关注，还有以后的时间安排问题。这些困难基本上是每个人都会遇到的，有的人中途放弃了，有的人挺下来了，这也是考验一个人最直接的方式吧。 5.我大四了，在学校已经没有课程了，仅剩的任务便是毕业论文，可以说我的大学生活基本上结束了。在不久的以后面临的便是社会的考验和职场的洗礼。对于技术人来说，初入职场需要注意些什么，需要培养哪些软技能，我已经听说了不少，无非是写作、英语、演讲、投资理财等等，却没有机会实际的感触一下。但是在大学期间从写作开始，我觉得很不错了。 ​","categories":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/categories/无事杂谈/"}],"tags":[{"name":"无事杂谈","slug":"无事杂谈","permalink":"http://roseduan.github.io/tags/无事杂谈/"}],"author":"roseduan"}]}